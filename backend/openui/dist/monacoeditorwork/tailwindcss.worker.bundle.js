(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/dlv@1.1.3/node_modules/dlv/dist/dlv.umd.js
  var require_dlv_umd = __commonJS({
    "node_modules/.pnpm/dlv@1.1.3/node_modules/dlv/dist/dlv.umd.js"(exports, module) {
      !function(t2, n2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = function(t3, n3, e5, i2, o2) {
          for (n3 = n3.split ? n3.split(".") : n3, i2 = 0; i2 < n3.length; i2++) t3 = t3 ? t3[n3[i2]] : o2;
          return t3 === o2 ? e5 : t3;
        } : "function" == typeof define && define.amd ? define(function() {
          return function(t3, n3, e5, i2, o2) {
            for (n3 = n3.split ? n3.split(".") : n3, i2 = 0; i2 < n3.length; i2++) t3 = t3 ? t3[n3[i2]] : o2;
            return t3 === o2 ? e5 : t3;
          };
        }) : t2.dlv = function(t3, n3, e5, i2, o2) {
          for (n3 = n3.split ? n3.split(".") : n3, i2 = 0; i2 < n3.length; i2++) t3 = t3 ? t3[n3[i2]] : o2;
          return t3 === o2 ? e5 : t3;
        };
      }(exports);
    }
  });

  // node_modules/.pnpm/picocolors@1.1.0/node_modules/picocolors/picocolors.browser.js
  var require_picocolors_browser = __commonJS({
    "node_modules/.pnpm/picocolors@1.1.0/node_modules/picocolors/picocolors.browser.js"(exports, module) {
      var x2 = String;
      var create = function() {
        return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2, blackBright: x2, redBright: x2, greenBright: x2, yellowBright: x2, blueBright: x2, magentaBright: x2, cyanBright: x2, whiteBright: x2, bgBlackBright: x2, bgRedBright: x2, bgGreenBright: x2, bgYellowBright: x2, bgBlueBright: x2, bgMagentaBright: x2, bgCyanBright: x2, bgWhiteBright: x2 };
      };
      module.exports = create();
      module.exports.createColors = create;
    }
  });

  // (disabled):node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/terminal-highlight
  var require_terminal_highlight = __commonJS({
    "(disabled):node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/terminal-highlight"() {
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/css-syntax-error.js
  var require_css_syntax_error = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/css-syntax-error.js"(exports, module) {
      "use strict";
      var pico = require_picocolors_browser();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError2 = class _CssSyntaxError extends Error {
        constructor(message, line, column, source, file, plugin2) {
          super(message);
          this.name = "CssSyntaxError";
          this.reason = message;
          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin2) {
            this.plugin = plugin2;
          }
          if (typeof line !== "undefined" && typeof column !== "undefined") {
            if (typeof line === "number") {
              this.line = line;
              this.column = column;
            } else {
              this.line = line.line;
              this.column = line.column;
              this.endLine = column.line;
              this.endColumn = column.column;
            }
          }
          this.setMessage();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _CssSyntaxError);
          }
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "";
          this.message += this.file ? this.file : "<css input>";
          if (typeof this.line !== "undefined") {
            this.message += ":" + this.line + ":" + this.column;
          }
          this.message += ": " + this.reason;
        }
        showSourceCode(color2) {
          if (!this.source) return "";
          let css = this.source;
          if (color2 == null) color2 = pico.isColorSupported;
          let aside = (text2) => text2;
          let mark = (text2) => text2;
          let highlight = (text2) => text2;
          if (color2) {
            let { bold, gray, red } = pico.createColors(true);
            mark = (text2) => bold(red(text2));
            aside = (text2) => gray(text2);
            if (terminalHighlight) {
              highlight = (text2) => terminalHighlight(text2);
            }
          }
          let lines = css.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);
          let maxWidth = String(end).length;
          return lines.slice(start, end).map((line, index2) => {
            let number2 = start + 1 + index2;
            let gutter = " " + (" " + number2).slice(-maxWidth) + " | ";
            if (number2 === this.line) {
              if (line.length > 160) {
                let padding = 20;
                let subLineStart = Math.max(0, this.column - padding);
                let subLineEnd = Math.max(
                  this.column + padding,
                  this.endColumn + padding
                );
                let subLine = line.slice(subLineStart, subLineEnd);
                let spacing2 = aside(gutter.replace(/\d/g, " ")) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
                return mark(">") + aside(gutter) + highlight(subLine) + "\n " + spacing2 + mark("^");
              }
              let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + highlight(line) + "\n " + spacing + mark("^");
            }
            return " " + aside(gutter) + highlight(line);
          }).join("\n");
        }
        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = "\n\n" + code + "\n";
          }
          return this.name + ": " + this.message + code;
        }
      };
      module.exports = CssSyntaxError2;
      CssSyntaxError2.default = CssSyntaxError2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/stringifier.js
  var require_stringifier = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/stringifier.js"(exports, module) {
      "use strict";
      var DEFAULT_RAW = {
        after: "\n",
        beforeClose: "\n",
        beforeComment: "\n",
        beforeDecl: "\n",
        beforeOpen: " ",
        beforeRule: "\n",
        colon: ": ",
        commentLeft: " ",
        commentRight: " ",
        emptyBody: "",
        indent: "    ",
        semicolon: false
      };
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      var Stringifier = class {
        constructor(builder) {
          this.builder = builder;
        }
        atrule(node, semicolon) {
          let name = "@" + node.name;
          let params = node.params ? this.rawValue(node, "params") : "";
          if (typeof node.raws.afterName !== "undefined") {
            name += node.raws.afterName;
          } else if (params) {
            name += " ";
          }
          if (node.nodes) {
            this.block(node, name + params);
          } else {
            let end = (node.raws.between || "") + (semicolon ? ";" : "");
            this.builder(name + params + end, node);
          }
        }
        beforeAfter(node, detect) {
          let value2;
          if (node.type === "decl") {
            value2 = this.raw(node, null, "beforeDecl");
          } else if (node.type === "comment") {
            value2 = this.raw(node, null, "beforeComment");
          } else if (detect === "before") {
            value2 = this.raw(node, null, "beforeRule");
          } else {
            value2 = this.raw(node, null, "beforeClose");
          }
          let buf = node.parent;
          let depth = 0;
          while (buf && buf.type !== "root") {
            depth += 1;
            buf = buf.parent;
          }
          if (value2.includes("\n")) {
            let indent = this.raw(node, null, "indent");
            if (indent.length) {
              for (let step = 0; step < depth; step++) value2 += indent;
            }
          }
          return value2;
        }
        block(node, start) {
          let between = this.raw(node, "between", "beforeOpen");
          this.builder(start + between + "{", node, "start");
          let after;
          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, "after");
          } else {
            after = this.raw(node, "after", "emptyBody");
          }
          if (after) this.builder(after);
          this.builder("}", node, "end");
        }
        body(node) {
          let last = node.nodes.length - 1;
          while (last > 0) {
            if (node.nodes[last].type !== "comment") break;
            last -= 1;
          }
          let semicolon = this.raw(node, "semicolon");
          for (let i2 = 0; i2 < node.nodes.length; i2++) {
            let child = node.nodes[i2];
            let before = this.raw(child, "before");
            if (before) this.builder(before);
            this.stringify(child, last !== i2 || semicolon);
          }
        }
        comment(node) {
          let left = this.raw(node, "left", "commentLeft");
          let right = this.raw(node, "right", "commentRight");
          this.builder("/*" + left + node.text + right + "*/", node);
        }
        decl(node, semicolon) {
          let between = this.raw(node, "between", "colon");
          let string = node.prop + between + this.rawValue(node, "value");
          if (node.important) {
            string += node.raws.important || " !important";
          }
          if (semicolon) string += ";";
          this.builder(string, node);
        }
        document(node) {
          this.body(node);
        }
        raw(node, own, detect) {
          let value2;
          if (!detect) detect = own;
          if (own) {
            value2 = node.raws[own];
            if (typeof value2 !== "undefined") return value2;
          }
          let parent = node.parent;
          if (detect === "before") {
            if (!parent || parent.type === "root" && parent.first === node) {
              return "";
            }
            if (parent && parent.type === "document") {
              return "";
            }
          }
          if (!parent) return DEFAULT_RAW[detect];
          let root2 = node.root();
          if (!root2.rawCache) root2.rawCache = {};
          if (typeof root2.rawCache[detect] !== "undefined") {
            return root2.rawCache[detect];
          }
          if (detect === "before" || detect === "after") {
            return this.beforeAfter(node, detect);
          } else {
            let method = "raw" + capitalize(detect);
            if (this[method]) {
              value2 = this[method](root2, node);
            } else {
              root2.walk((i2) => {
                value2 = i2.raws[own];
                if (typeof value2 !== "undefined") return false;
              });
            }
          }
          if (typeof value2 === "undefined") value2 = DEFAULT_RAW[detect];
          root2.rawCache[detect] = value2;
          return value2;
        }
        rawBeforeClose(root2) {
          let value2;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length > 0) {
              if (typeof i2.raws.after !== "undefined") {
                value2 = i2.raws.after;
                if (value2.includes("\n")) {
                  value2 = value2.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value2) value2 = value2.replace(/\S/g, "");
          return value2;
        }
        rawBeforeComment(root2, node) {
          let value2;
          root2.walkComments((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value2 = i2.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value2 === "undefined") {
            value2 = this.raw(node, null, "beforeDecl");
          } else if (value2) {
            value2 = value2.replace(/\S/g, "");
          }
          return value2;
        }
        rawBeforeDecl(root2, node) {
          let value2;
          root2.walkDecls((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value2 = i2.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value2 === "undefined") {
            value2 = this.raw(node, null, "beforeRule");
          } else if (value2) {
            value2 = value2.replace(/\S/g, "");
          }
          return value2;
        }
        rawBeforeOpen(root2) {
          let value2;
          root2.walk((i2) => {
            if (i2.type !== "decl") {
              value2 = i2.raws.between;
              if (typeof value2 !== "undefined") return false;
            }
          });
          return value2;
        }
        rawBeforeRule(root2) {
          let value2;
          root2.walk((i2) => {
            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
              if (typeof i2.raws.before !== "undefined") {
                value2 = i2.raws.before;
                if (value2.includes("\n")) {
                  value2 = value2.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value2) value2 = value2.replace(/\S/g, "");
          return value2;
        }
        rawColon(root2) {
          let value2;
          root2.walkDecls((i2) => {
            if (typeof i2.raws.between !== "undefined") {
              value2 = i2.raws.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
          return value2;
        }
        rawEmptyBody(root2) {
          let value2;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length === 0) {
              value2 = i2.raws.after;
              if (typeof value2 !== "undefined") return false;
            }
          });
          return value2;
        }
        rawIndent(root2) {
          if (root2.raws.indent) return root2.raws.indent;
          let value2;
          root2.walk((i2) => {
            let p4 = i2.parent;
            if (p4 && p4 !== root2 && p4.parent && p4.parent === root2) {
              if (typeof i2.raws.before !== "undefined") {
                let parts = i2.raws.before.split("\n");
                value2 = parts[parts.length - 1];
                value2 = value2.replace(/\S/g, "");
                return false;
              }
            }
          });
          return value2;
        }
        rawSemicolon(root2) {
          let value2;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
              value2 = i2.raws.semicolon;
              if (typeof value2 !== "undefined") return false;
            }
          });
          return value2;
        }
        rawValue(node, prop) {
          let value2 = node[prop];
          let raw = node.raws[prop];
          if (raw && raw.value === value2) {
            return raw.raw;
          }
          return value2;
        }
        root(node) {
          this.body(node);
          if (node.raws.after) this.builder(node.raws.after);
        }
        rule(node) {
          this.block(node, this.rawValue(node, "selector"));
          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, "end");
          }
        }
        stringify(node, semicolon) {
          if (!this[node.type]) {
            throw new Error(
              "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
            );
          }
          this[node.type](node, semicolon);
        }
      };
      module.exports = Stringifier;
      Stringifier.default = Stringifier;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/stringify.js"(exports, module) {
      "use strict";
      var Stringifier = require_stringifier();
      function stringify3(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      }
      module.exports = stringify3;
      stringify3.default = stringify3;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/symbols.js
  var require_symbols = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/symbols.js"(exports, module) {
      "use strict";
      module.exports.isClean = Symbol("isClean");
      module.exports.my = Symbol("my");
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/node.js
  var require_node = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/node.js"(exports, module) {
      "use strict";
      var CssSyntaxError2 = require_css_syntax_error();
      var Stringifier = require_stringifier();
      var stringify3 = require_stringify();
      var { isClean, my } = require_symbols();
      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();
        for (let i2 in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
            continue;
          }
          if (i2 === "proxyCache") continue;
          let value2 = obj[i2];
          let type = typeof value2;
          if (i2 === "parent" && type === "object") {
            if (parent) cloned[i2] = parent;
          } else if (i2 === "source") {
            cloned[i2] = value2;
          } else if (Array.isArray(value2)) {
            cloned[i2] = value2.map((j2) => cloneNode(j2, cloned));
          } else {
            if (type === "object" && value2 !== null) value2 = cloneNode(value2);
            cloned[i2] = value2;
          }
        }
        return cloned;
      }
      var Node3 = class {
        constructor(defaults3 = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;
          for (let name in defaults3) {
            if (name === "nodes") {
              this.nodes = [];
              for (let node of defaults3[name]) {
                if (typeof node.clone === "function") {
                  this.append(node.clone());
                } else {
                  this.append(node);
                }
              }
            } else {
              this[name] = defaults3[name];
            }
          }
        }
        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s2 = this.source;
            error.stack = error.stack.replace(
              /\n\s{4}at /,
              `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
            );
          }
          return error;
        }
        after(add) {
          this.parent.insertAfter(this, add);
          return this;
        }
        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }
        before(add) {
          this.parent.insertBefore(this, add);
          return this;
        }
        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween) delete this.raws.between;
        }
        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }
        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }
        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }
        error(message, opts = {}) {
          if (this.source) {
            let { end, start } = this.rangeBy(opts);
            return this.source.input.error(
              message,
              { column: start.column, line: start.line },
              { column: end.column, line: end.line },
              opts
            );
          }
          return new CssSyntaxError2(message);
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value2) {
              if (node[prop] === value2) return true;
              node[prop] = value2;
              if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
              prop === "text") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        /* c8 ignore next 3 */
        markClean() {
          this[isClean] = true;
        }
        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next = this;
            while (next = next.parent) {
              next[isClean] = false;
            }
          }
        }
        next() {
          if (!this.parent) return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 + 1];
        }
        positionBy(opts, stringRepresentation) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index, stringRepresentation);
          } else if (opts.word) {
            stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);
          }
          return pos;
        }
        positionInside(index2, stringRepresentation) {
          let string = stringRepresentation || this.toString();
          let column = this.source.start.column;
          let line = this.source.start.line;
          for (let i2 = 0; i2 < index2; i2++) {
            if (string[i2] === "\n") {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }
          return { column, line };
        }
        prev() {
          if (!this.parent) return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 - 1];
        }
        rangeBy(opts) {
          let start = {
            column: this.source.start.column,
            line: this.source.start.line
          };
          let end = this.source.end ? {
            column: this.source.end.column + 1,
            line: this.source.end.line
          } : {
            column: start.column + 1,
            line: start.line
          };
          if (opts.word) {
            let stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1) {
              start = this.positionInside(index2, stringRepresentation);
              end = this.positionInside(
                index2 + opts.word.length,
                stringRepresentation
              );
            }
          } else {
            if (opts.start) {
              start = {
                column: opts.start.column,
                line: opts.start.line
              };
            } else if (opts.index) {
              start = this.positionInside(opts.index);
            }
            if (opts.end) {
              end = {
                column: opts.end.column,
                line: opts.end.line
              };
            } else if (typeof opts.endIndex === "number") {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }
          if (end.line < start.line || end.line === start.line && end.column <= start.column) {
            end = { column: start.column + 1, line: start.line };
          }
          return { end, start };
        }
        raw(prop, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop, defaultType);
        }
        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        }
        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node of nodes) {
              if (node === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node);
                bookmark = node;
              } else {
                this.parent.insertBefore(bookmark, node);
              }
            }
            if (!foundSelf) {
              this.remove();
            }
          }
          return this;
        }
        root() {
          let result = this;
          while (result.parent && result.parent.type !== "document") {
            result = result.parent;
          }
          return result;
        }
        toJSON(_2, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || /* @__PURE__ */ new Map();
          let inputsNextIndex = 0;
          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              continue;
            }
            if (name === "parent" || name === "proxyCache") continue;
            let value2 = this[name];
            if (Array.isArray(value2)) {
              fixed[name] = value2.map((i2) => {
                if (typeof i2 === "object" && i2.toJSON) {
                  return i2.toJSON(null, inputs);
                } else {
                  return i2;
                }
              });
            } else if (typeof value2 === "object" && value2.toJSON) {
              fixed[name] = value2.toJSON(null, inputs);
            } else if (name === "source") {
              let inputId = inputs.get(value2.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value2.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                end: value2.end,
                inputId,
                start: value2.start
              };
            } else {
              fixed[name] = value2;
            }
          }
          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
          }
          return fixed;
        }
        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }
        toString(stringifier = stringify3) {
          if (stringifier.stringify) stringifier = stringifier.stringify;
          let result = "";
          stringifier(this, (i2) => {
            result += i2;
          });
          return result;
        }
        warn(result, text2, opts) {
          let data = { node: this };
          for (let i2 in opts) data[i2] = opts[i2];
          return result.warn(text2, data);
        }
        get proxyOf() {
          return this;
        }
      };
      module.exports = Node3;
      Node3.default = Node3;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/comment.js
  var require_comment = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/comment.js"(exports, module) {
      "use strict";
      var Node3 = require_node();
      var Comment2 = class extends Node3 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "comment";
        }
      };
      module.exports = Comment2;
      Comment2.default = Comment2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/declaration.js
  var require_declaration = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/declaration.js"(exports, module) {
      "use strict";
      var Node3 = require_node();
      var Declaration2 = class extends Node3 {
        constructor(defaults3) {
          if (defaults3 && typeof defaults3.value !== "undefined" && typeof defaults3.value !== "string") {
            defaults3 = { ...defaults3, value: String(defaults3.value) };
          }
          super(defaults3);
          this.type = "decl";
        }
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
      };
      module.exports = Declaration2;
      Declaration2.default = Declaration2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/container.js
  var require_container = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/container.js"(exports, module) {
      "use strict";
      var Comment2 = require_comment();
      var Declaration2 = require_declaration();
      var Node3 = require_node();
      var { isClean, my } = require_symbols();
      var AtRule2;
      var parse5;
      var Root2;
      var Rule2;
      function cleanSource(nodes) {
        return nodes.map((i2) => {
          if (i2.nodes) i2.nodes = cleanSource(i2.nodes);
          delete i2.source;
          return i2;
        });
      }
      function markTreeDirty(node) {
        node[isClean] = false;
        if (node.proxyOf.nodes) {
          for (let i2 of node.proxyOf.nodes) {
            markTreeDirty(i2);
          }
        }
      }
      var Container2 = class _Container extends Node3 {
        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node of nodes) this.proxyOf.nodes.push(node);
          }
          this.markDirty();
          return this;
        }
        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node of this.nodes) node.cleanRaws(keepBetween);
          }
        }
        each(callback) {
          if (!this.proxyOf.nodes) return void 0;
          let iterator = this.getIterator();
          let index2, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index2 = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index2], index2);
            if (result === false) break;
            this.indexes[iterator] += 1;
          }
          delete this.indexes[iterator];
          return result;
        }
        every(condition) {
          return this.nodes.every(condition);
        }
        getIterator() {
          if (!this.lastEach) this.lastEach = 0;
          if (!this.indexes) this.indexes = {};
          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;
          return iterator;
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (!node[prop]) {
                return node[prop];
              } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
                return (...args) => {
                  return node[prop](
                    ...args.map((i2) => {
                      if (typeof i2 === "function") {
                        return (child, index2) => i2(child.toProxy(), index2);
                      } else {
                        return i2;
                      }
                    })
                  );
                };
              } else if (prop === "every" || prop === "some") {
                return (cb) => {
                  return node[prop](
                    (child, ...other) => cb(child.toProxy(), ...other)
                  );
                };
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else if (prop === "nodes") {
                return node.nodes.map((i2) => i2.toProxy());
              } else if (prop === "first" || prop === "last") {
                return node[prop].toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value2) {
              if (node[prop] === value2) return true;
              node[prop] = value2;
              if (prop === "name" || prop === "params" || prop === "selector") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        index(child) {
          if (typeof child === "number") return child;
          if (child.proxyOf) child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }
        insertAfter(exist, add) {
          let existIndex = this.index(exist);
          let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
          existIndex = this.index(exist);
          for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (existIndex < index2) {
              this.indexes[id] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        insertBefore(exist, add) {
          let existIndex = this.index(exist);
          let type = existIndex === 0 ? "prepend" : false;
          let nodes = this.normalize(
            add,
            this.proxyOf.nodes[existIndex],
            type
          ).reverse();
          existIndex = this.index(exist);
          for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (existIndex <= index2) {
              this.indexes[id] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        normalize(nodes, sample) {
          if (typeof nodes === "string") {
            nodes = cleanSource(parse5(nodes).nodes);
          } else if (typeof nodes === "undefined") {
            nodes = [];
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent) i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type === "root" && this.type !== "document") {
            nodes = nodes.nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent) i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === "undefined") {
              throw new Error("Value field is missed in node creation");
            } else if (typeof nodes.value !== "string") {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration2(nodes)];
          } else if (nodes.selector || nodes.selectors) {
            nodes = [new Rule2(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule2(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment2(nodes)];
          } else {
            throw new Error("Unknown node type in node creation");
          }
          let processed = nodes.map((i2) => {
            if (!i2[my]) _Container.rebuild(i2);
            i2 = i2.proxyOf;
            if (i2.parent) i2.parent.removeChild(i2);
            if (i2[isClean]) markTreeDirty(i2);
            if (!i2.raws) i2.raws = {};
            if (typeof i2.raws.before === "undefined") {
              if (sample && typeof sample.raws.before !== "undefined") {
                i2.raws.before = sample.raws.before.replace(/\S/g, "");
              }
            }
            i2.parent = this.proxyOf;
            return i2;
          });
          return processed;
        }
        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, "prepend").reverse();
            for (let node of nodes) this.proxyOf.nodes.unshift(node);
            for (let id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }
        removeAll() {
          for (let node of this.proxyOf.nodes) node.parent = void 0;
          this.proxyOf.nodes = [];
          this.markDirty();
          return this;
        }
        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = void 0;
          this.proxyOf.nodes.splice(child, 1);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (index2 >= child) {
              this.indexes[id] = index2 - 1;
            }
          }
          this.markDirty();
          return this;
        }
        replaceValues(pattern2, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }
          this.walkDecls((decl3) => {
            if (opts.props && !opts.props.includes(decl3.prop)) return;
            if (opts.fast && !decl3.value.includes(opts.fast)) return;
            decl3.value = decl3.value.replace(pattern2, callback);
          });
          this.markDirty();
          return this;
        }
        some(condition) {
          return this.nodes.some(condition);
        }
        walk(callback) {
          return this.each((child, i2) => {
            let result;
            try {
              result = callback(child, i2);
            } catch (e5) {
              throw child.addToError(e5);
            }
            if (result !== false && child.walk) {
              result = child.walk(callback);
            }
            return result;
          });
        }
        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child, i2) => {
              if (child.type === "atrule") {
                return callback(child, i2);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "atrule" && name.test(child.name)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "atrule" && child.name === name) {
              return callback(child, i2);
            }
          });
        }
        walkComments(callback) {
          return this.walk((child, i2) => {
            if (child.type === "comment") {
              return callback(child, i2);
            }
          });
        }
        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i2) => {
              if (child.type === "decl") {
                return callback(child, i2);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "decl" && prop.test(child.prop)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "decl" && child.prop === prop) {
              return callback(child, i2);
            }
          });
        }
        walkRules(selector, callback) {
          if (!callback) {
            callback = selector;
            return this.walk((child, i2) => {
              if (child.type === "rule") {
                return callback(child, i2);
              }
            });
          }
          if (selector instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "rule" && selector.test(child.selector)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "rule" && child.selector === selector) {
              return callback(child, i2);
            }
          });
        }
        get first() {
          if (!this.proxyOf.nodes) return void 0;
          return this.proxyOf.nodes[0];
        }
        get last() {
          if (!this.proxyOf.nodes) return void 0;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
      };
      Container2.registerParse = (dependant) => {
        parse5 = dependant;
      };
      Container2.registerRule = (dependant) => {
        Rule2 = dependant;
      };
      Container2.registerAtRule = (dependant) => {
        AtRule2 = dependant;
      };
      Container2.registerRoot = (dependant) => {
        Root2 = dependant;
      };
      module.exports = Container2;
      Container2.default = Container2;
      Container2.rebuild = (node) => {
        if (node.type === "atrule") {
          Object.setPrototypeOf(node, AtRule2.prototype);
        } else if (node.type === "rule") {
          Object.setPrototypeOf(node, Rule2.prototype);
        } else if (node.type === "decl") {
          Object.setPrototypeOf(node, Declaration2.prototype);
        } else if (node.type === "comment") {
          Object.setPrototypeOf(node, Comment2.prototype);
        } else if (node.type === "root") {
          Object.setPrototypeOf(node, Root2.prototype);
        }
        node[my] = true;
        if (node.nodes) {
          node.nodes.forEach((child) => {
            Container2.rebuild(child);
          });
        }
      };
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/at-rule.js
  var require_at_rule = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/at-rule.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var AtRule2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "atrule";
        }
        append(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.append(...children);
        }
        prepend(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.prepend(...children);
        }
      };
      module.exports = AtRule2;
      AtRule2.default = AtRule2;
      Container2.registerAtRule(AtRule2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/document.js
  var require_document = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/document.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var LazyResult;
      var Processor2;
      var Document2 = class extends Container2 {
        constructor(defaults3) {
          super({ type: "document", ...defaults3 });
          if (!this.nodes) {
            this.nodes = [];
          }
        }
        toResult(opts = {}) {
          let lazy2 = new LazyResult(new Processor2(), this, opts);
          return lazy2.stringify();
        }
      };
      Document2.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Document2.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Document2;
      Document2.default = Document2;
    }
  });

  // node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs
  var require_non_secure = __commonJS({
    "node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs"(exports, module) {
      var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      var customAlphabet = (alphabet, defaultSize = 21) => {
        return (size = defaultSize) => {
          let id = "";
          let i2 = size;
          while (i2--) {
            id += alphabet[Math.random() * alphabet.length | 0];
          }
          return id;
        };
      };
      var nanoid = (size = 21) => {
        let id = "";
        let i2 = size;
        while (i2--) {
          id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
      };
      module.exports = { nanoid, customAlphabet };
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // (disabled):node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "(disabled):node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js"() {
    }
  });

  // (disabled):url
  var require_url = __commonJS({
    "(disabled):url"() {
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/previous-map.js
  var require_previous_map = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/previous-map.js"(exports, module) {
      "use strict";
      var { existsSync, readFileSync } = require_fs();
      var { dirname: dirname2, join: join2 } = require_path();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      function fromBase64(str) {
        if (Buffer) {
          return Buffer.from(str, "base64").toString();
        } else {
          return window.atob(str);
        }
      }
      var PreviousMap = class {
        constructor(css, opts) {
          if (opts.map === false) return;
          this.loadAnnotation(css);
          this.inline = this.startWith(this.annotation, "data:");
          let prev = opts.map ? opts.map.prev : void 0;
          let text2 = this.loadMap(opts.from, prev);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile) this.root = dirname2(this.mapFile);
          if (text2) this.text = text2;
        }
        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }
        decodeInline(text2) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;
          let uriMatch = text2.match(charsetUri) || text2.match(uri);
          if (uriMatch) {
            return decodeURIComponent(text2.substr(uriMatch[0].length));
          }
          let baseUriMatch = text2.match(baseCharsetUri) || text2.match(baseUri);
          if (baseUriMatch) {
            return fromBase64(text2.substr(baseUriMatch[0].length));
          }
          let encoding = text2.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + encoding);
        }
        getAnnotationURL(sourceMapString) {
          return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        isMap(map) {
          if (typeof map !== "object") return false;
          return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
        }
        loadAnnotation(css) {
          let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
          if (!comments) return;
          let start = css.lastIndexOf(comments.pop());
          let end = css.indexOf("*/", start);
          if (start > -1 && end > -1) {
            this.annotation = this.getAnnotationURL(css.substring(start, end));
          }
        }
        loadFile(path) {
          this.root = dirname2(path);
          if (existsSync(path)) {
            this.mapFile = path;
            return readFileSync(path, "utf-8").toString().trim();
          }
        }
        loadMap(file, prev) {
          if (prev === false) return false;
          if (prev) {
            if (typeof prev === "string") {
              return prev;
            } else if (typeof prev === "function") {
              let prevPath = prev(file);
              if (prevPath) {
                let map = this.loadFile(prevPath);
                if (!map) {
                  throw new Error(
                    "Unable to load previous source map: " + prevPath.toString()
                  );
                }
                return map;
              }
            } else if (prev instanceof SourceMapConsumer) {
              return SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof SourceMapGenerator) {
              return prev.toString();
            } else if (this.isMap(prev)) {
              return JSON.stringify(prev);
            } else {
              throw new Error(
                "Unsupported previous source map format: " + prev.toString()
              );
            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map = this.annotation;
            if (file) map = join2(dirname2(file), map);
            return this.loadFile(map);
          }
        }
        startWith(string, start) {
          if (!string) return false;
          return string.substr(0, start.length) === start;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
      };
      module.exports = PreviousMap;
      PreviousMap.default = PreviousMap;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/input.js
  var require_input = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/input.js"(exports, module) {
      "use strict";
      var { nanoid } = require_non_secure();
      var { isAbsolute, resolve: resolve2 } = require_path();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { fileURLToPath, pathToFileURL } = require_url();
      var CssSyntaxError2 = require_css_syntax_error();
      var PreviousMap = require_previous_map();
      var terminalHighlight = require_terminal_highlight();
      var fromOffsetCache = Symbol("fromOffsetCache");
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(resolve2 && isAbsolute);
      var Input2 = class {
        constructor(css, opts = {}) {
          if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }
          this.css = css.toString();
          if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }
          if (opts.from) {
            if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
              this.file = opts.from;
            } else {
              this.file = resolve2(opts.from);
            }
          }
          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file) this.file = this.mapResolve(file);
            }
          }
          if (!this.file) {
            this.id = "<input css " + nanoid(6) + ">";
          }
          if (this.map) this.map.file = this.from;
        }
        error(message, line, column, opts = {}) {
          let endColumn, endLine, result;
          if (line && typeof line === "object") {
            let start = line;
            let end = column;
            if (typeof start.offset === "number") {
              let pos = this.fromOffset(start.offset);
              line = pos.line;
              column = pos.col;
            } else {
              line = start.line;
              column = start.column;
            }
            if (typeof end.offset === "number") {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }
          let origin = this.origin(line, column, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError2(
              message,
              origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
              origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
              origin.source,
              origin.file,
              opts.plugin
            );
          } else {
            result = new CssSyntaxError2(
              message,
              endLine === void 0 ? line : { column, line },
              endLine === void 0 ? column : { column: endColumn, line: endLine },
              this.css,
              this.file,
              opts.plugin
            );
          }
          result.input = { column, endColumn, endLine, line, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }
          return result;
        }
        fromOffset(offset) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split("\n");
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;
            for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
              lineToIndex[i2] = prevIndex;
              prevIndex += lines[i2].length + 1;
            }
            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];
          let min = 0;
          if (offset >= lastLine) {
            min = lineToIndex.length - 1;
          } else {
            let max2 = lineToIndex.length - 2;
            let mid;
            while (min < max2) {
              mid = min + (max2 - min >> 1);
              if (offset < lineToIndex[mid]) {
                max2 = mid - 1;
              } else if (offset >= lineToIndex[mid + 1]) {
                min = mid + 1;
              } else {
                min = mid;
                break;
              }
            }
          }
          return {
            col: offset - lineToIndex[min] + 1,
            line: min + 1
          };
        }
        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve2(this.map.consumer().sourceRoot || this.map.root || ".", file);
        }
        origin(line, column, endLine, endColumn) {
          if (!this.map) return false;
          let consumer = this.map.consumer();
          let from = consumer.originalPositionFor({ column, line });
          if (!from.source) return false;
          let to;
          if (typeof endLine === "number") {
            to = consumer.originalPositionFor({ column: endColumn, line: endLine });
          }
          let fromUrl;
          if (isAbsolute(from.source)) {
            fromUrl = pathToFileURL(from.source);
          } else {
            fromUrl = new URL(
              from.source,
              this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
            );
          }
          let result = {
            column: from.column,
            endColumn: to && to.column,
            endLine: to && to.line,
            line: from.line,
            url: fromUrl.toString()
          };
          if (fromUrl.protocol === "file:") {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }
          let source = consumer.sourceContentFor(from.source);
          if (source) result.source = source;
          return result;
        }
        toJSON() {
          let json = {};
          for (let name of ["hasBOM", "css", "file", "id"]) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = { ...this.map };
            if (json.map.consumerCache) {
              json.map.consumerCache = void 0;
            }
          }
          return json;
        }
        get from() {
          return this.file || this.id;
        }
      };
      module.exports = Input2;
      Input2.default = Input2;
      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input2);
      }
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/root.js
  var require_root = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/root.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var LazyResult;
      var Processor2;
      var Root2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "root";
          if (!this.nodes) this.nodes = [];
        }
        normalize(child, sample, type) {
          let nodes = super.normalize(child);
          if (sample) {
            if (type === "prepend") {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node of nodes) {
                node.raws.before = sample.raws.before;
              }
            }
          }
          return nodes;
        }
        removeChild(child, ignore) {
          let index2 = this.index(child);
          if (!ignore && index2 === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index2].raws.before;
          }
          return super.removeChild(child);
        }
        toResult(opts = {}) {
          let lazy2 = new LazyResult(new Processor2(), this, opts);
          return lazy2.stringify();
        }
      };
      Root2.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Root2.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Root2;
      Root2.default = Root2;
      Container2.registerRoot(Root2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/list.js
  var require_list = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/list.js"(exports, module) {
      "use strict";
      var list3 = {
        comma(string) {
          return list3.split(string, [","], true);
        },
        space(string) {
          let spaces = [" ", "\n", "	"];
          return list3.split(string, spaces);
        },
        split(string, separators, last) {
          let array = [];
          let current = "";
          let split = false;
          let func = 0;
          let inQuote = false;
          let prevQuote = "";
          let escape2 = false;
          for (let letter of string) {
            if (escape2) {
              escape2 = false;
            } else if (letter === "\\") {
              escape2 = true;
            } else if (inQuote) {
              if (letter === prevQuote) {
                inQuote = false;
              }
            } else if (letter === '"' || letter === "'") {
              inQuote = true;
              prevQuote = letter;
            } else if (letter === "(") {
              func += 1;
            } else if (letter === ")") {
              if (func > 0) func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter)) split = true;
            }
            if (split) {
              if (current !== "") array.push(current.trim());
              current = "";
              split = false;
            } else {
              current += letter;
            }
          }
          if (last || current !== "") array.push(current.trim());
          return array;
        }
      };
      module.exports = list3;
      list3.default = list3;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/rule.js
  var require_rule = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/rule.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var list3 = require_list();
      var Rule2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "rule";
          if (!this.nodes) this.nodes = [];
        }
        get selectors() {
          return list3.comma(this.selector);
        }
        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep2);
        }
      };
      module.exports = Rule2;
      Rule2.default = Rule2;
      Container2.registerRule(Rule2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/fromJSON.js
  var require_fromJSON = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/fromJSON.js"(exports, module) {
      "use strict";
      var AtRule2 = require_at_rule();
      var Comment2 = require_comment();
      var Declaration2 = require_declaration();
      var Input2 = require_input();
      var PreviousMap = require_previous_map();
      var Root2 = require_root();
      var Rule2 = require_rule();
      function fromJSON2(json, inputs) {
        if (Array.isArray(json)) return json.map((n2) => fromJSON2(n2));
        let { inputs: ownInputs, ...defaults3 } = json;
        if (ownInputs) {
          inputs = [];
          for (let input of ownInputs) {
            let inputHydrated = { ...input, __proto__: Input2.prototype };
            if (inputHydrated.map) {
              inputHydrated.map = {
                ...inputHydrated.map,
                __proto__: PreviousMap.prototype
              };
            }
            inputs.push(inputHydrated);
          }
        }
        if (defaults3.nodes) {
          defaults3.nodes = json.nodes.map((n2) => fromJSON2(n2, inputs));
        }
        if (defaults3.source) {
          let { inputId, ...source } = defaults3.source;
          defaults3.source = source;
          if (inputId != null) {
            defaults3.source.input = inputs[inputId];
          }
        }
        if (defaults3.type === "root") {
          return new Root2(defaults3);
        } else if (defaults3.type === "decl") {
          return new Declaration2(defaults3);
        } else if (defaults3.type === "rule") {
          return new Rule2(defaults3);
        } else if (defaults3.type === "comment") {
          return new Comment2(defaults3);
        } else if (defaults3.type === "atrule") {
          return new AtRule2(defaults3);
        } else {
          throw new Error("Unknown node type: " + json.type);
        }
      }
      module.exports = fromJSON2;
      fromJSON2.default = fromJSON2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/map-generator.js
  var require_map_generator = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/map-generator.js"(exports, module) {
      "use strict";
      var { dirname: dirname2, relative: relative2, resolve: resolve2, sep: sep2 } = require_path();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { pathToFileURL } = require_url();
      var Input2 = require_input();
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(dirname2 && resolve2 && relative2 && sep2);
      var MapGenerator = class {
        constructor(stringify3, root2, opts, cssString) {
          this.stringify = stringify3;
          this.mapOpts = opts.map || {};
          this.root = root2;
          this.opts = opts;
          this.css = cssString;
          this.originalCSS = cssString;
          this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
          this.memoizedFileURLs = /* @__PURE__ */ new Map();
          this.memoizedPaths = /* @__PURE__ */ new Map();
          this.memoizedURLs = /* @__PURE__ */ new Map();
        }
        addAnnotation() {
          let content;
          if (this.isInline()) {
            content = "data:application/json;base64," + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === "string") {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === "function") {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + ".map";
          }
          let eol = "\n";
          if (this.css.includes("\r\n")) eol = "\r\n";
          this.css += eol + "/*# sourceMappingURL=" + content + " */";
        }
        applyPrevMaps() {
          for (let prev of this.previous()) {
            let from = this.toUrl(this.path(prev.file));
            let root2 = prev.root || dirname2(prev.file);
            let map;
            if (this.mapOpts.sourcesContent === false) {
              map = new SourceMapConsumer(prev.text);
              if (map.sourcesContent) {
                map.sourcesContent = null;
              }
            } else {
              map = prev.consumer();
            }
            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
          }
        }
        clearAnnotation() {
          if (this.mapOpts.annotation === false) return;
          if (this.root) {
            let node;
            for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
              node = this.root.nodes[i2];
              if (node.type !== "comment") continue;
              if (node.text.startsWith("# sourceMappingURL=")) {
                this.root.removeChild(i2);
              }
            }
          } else if (this.css) {
            this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
          }
        }
        generate() {
          this.clearAnnotation();
          if (pathAvailable && sourceMapAvailable && this.isMap()) {
            return this.generateMap();
          } else {
            let result = "";
            this.stringify(this.root, (i2) => {
              result += i2;
            });
            return [result];
          }
        }
        generateMap() {
          if (this.root) {
            this.generateString();
          } else if (this.previous().length === 1) {
            let prev = this.previous()[0].consumer();
            prev.file = this.outputFile();
            this.map = SourceMapGenerator.fromSourceMap(prev, {
              ignoreInvalidMapping: true
            });
          } else {
            this.map = new SourceMapGenerator({
              file: this.outputFile(),
              ignoreInvalidMapping: true
            });
            this.map.addMapping({
              generated: { column: 0, line: 1 },
              original: { column: 0, line: 1 },
              source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
            });
          }
          if (this.isSourcesContent()) this.setSourcesContent();
          if (this.root && this.previous().length > 0) this.applyPrevMaps();
          if (this.isAnnotation()) this.addAnnotation();
          if (this.isInline()) {
            return [this.css];
          } else {
            return [this.css, this.map];
          }
        }
        generateString() {
          this.css = "";
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          let line = 1;
          let column = 1;
          let noSource = "<no source>";
          let mapping = {
            generated: { column: 0, line: 0 },
            original: { column: 0, line: 0 },
            source: ""
          };
          let last, lines;
          this.stringify(this.root, (str, node, type) => {
            this.css += str;
            if (node && type !== "end") {
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              if (node.source && node.source.start) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.start.line;
                mapping.original.column = node.source.start.column - 1;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                this.map.addMapping(mapping);
              }
            }
            lines = str.match(/\n/g);
            if (lines) {
              line += lines.length;
              last = str.lastIndexOf("\n");
              column = str.length - last;
            } else {
              column += str.length;
            }
            if (node && type !== "start") {
              let p4 = node.parent || { raws: {} };
              let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
              if (!childless || node !== p4.last || p4.raws.semicolon) {
                if (node.source && node.source.end) {
                  mapping.source = this.sourcePath(node);
                  mapping.original.line = node.source.end.line;
                  mapping.original.column = node.source.end.column - 1;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 2;
                  this.map.addMapping(mapping);
                } else {
                  mapping.source = noSource;
                  mapping.original.line = 1;
                  mapping.original.column = 0;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 1;
                  this.map.addMapping(mapping);
                }
              }
            }
          });
        }
        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== "undefined") {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.annotation);
          }
          return true;
        }
        isInline() {
          if (typeof this.mapOpts.inline !== "undefined") {
            return this.mapOpts.inline;
          }
          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== "undefined" && annotation !== true) {
            return false;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.inline);
          }
          return true;
        }
        isMap() {
          if (typeof this.opts.map !== "undefined") {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }
        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== "undefined") {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.withContent());
          }
          return true;
        }
        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          } else if (this.opts.from) {
            return this.path(this.opts.from);
          } else {
            return "to.css";
          }
        }
        path(file) {
          if (this.mapOpts.absolute) return file;
          if (file.charCodeAt(0) === 60) return file;
          if (/^\w+:\/\//.test(file)) return file;
          let cached = this.memoizedPaths.get(file);
          if (cached) return cached;
          let from = this.opts.to ? dirname2(this.opts.to) : ".";
          if (typeof this.mapOpts.annotation === "string") {
            from = dirname2(resolve2(from, this.mapOpts.annotation));
          }
          let path = relative2(from, file);
          this.memoizedPaths.set(file, path);
          return path;
        }
        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            if (this.root) {
              this.root.walk((node) => {
                if (node.source && node.source.input.map) {
                  let map = node.source.input.map;
                  if (!this.previousMaps.includes(map)) {
                    this.previousMaps.push(map);
                  }
                }
              });
            } else {
              let input = new Input2(this.originalCSS, this.opts);
              if (input.map) this.previousMaps.push(input.map);
            }
          }
          return this.previousMaps;
        }
        setSourcesContent() {
          let already = {};
          if (this.root) {
            this.root.walk((node) => {
              if (node.source) {
                let from = node.source.input.from;
                if (from && !already[from]) {
                  already[from] = true;
                  let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                  this.map.setSourceContent(fromUrl, node.source.input.css);
                }
              }
            });
          } else if (this.css) {
            let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(from, this.css);
          }
        }
        sourcePath(node) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.usesFileUrls) {
            return this.toFileUrl(node.source.input.from);
          } else {
            return this.toUrl(this.path(node.source.input.from));
          }
        }
        toBase64(str) {
          if (Buffer) {
            return Buffer.from(str).toString("base64");
          } else {
            return window.btoa(unescape(encodeURIComponent(str)));
          }
        }
        toFileUrl(path) {
          let cached = this.memoizedFileURLs.get(path);
          if (cached) return cached;
          if (pathToFileURL) {
            let fileURL = pathToFileURL(path).toString();
            this.memoizedFileURLs.set(path, fileURL);
            return fileURL;
          } else {
            throw new Error(
              "`map.absolute` option is not available in this PostCSS build"
            );
          }
        }
        toUrl(path) {
          let cached = this.memoizedURLs.get(path);
          if (cached) return cached;
          if (sep2 === "\\") {
            path = path.replace(/\\/g, "/");
          }
          let url2 = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
          this.memoizedURLs.set(path, url2);
          return url2;
        }
      };
      module.exports = MapGenerator;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/tokenize.js
  var require_tokenize = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/tokenize.js"(exports, module) {
      "use strict";
      var SINGLE_QUOTE = "'".charCodeAt(0);
      var DOUBLE_QUOTE = '"'.charCodeAt(0);
      var BACKSLASH = "\\".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var SPACE3 = " ".charCodeAt(0);
      var FEED = "\f".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var CR = "\r".charCodeAt(0);
      var OPEN_SQUARE = "[".charCodeAt(0);
      var CLOSE_SQUARE = "]".charCodeAt(0);
      var OPEN_PARENTHESES = "(".charCodeAt(0);
      var CLOSE_PARENTHESES = ")".charCodeAt(0);
      var OPEN_CURLY = "{".charCodeAt(0);
      var CLOSE_CURLY = "}".charCodeAt(0);
      var SEMICOLON = ";".charCodeAt(0);
      var ASTERISK = "*".charCodeAt(0);
      var COLON = ":".charCodeAt(0);
      var AT = "@".charCodeAt(0);
      var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
      var RE_HEX_ESCAPE = /[\da-f]/i;
      module.exports = function tokenizer2(input, options = {}) {
        let css = input.css.valueOf();
        let ignore = options.ignoreErrors;
        let code, content, escape2, next, quote;
        let currentToken, escaped, escapePos, n2, prev;
        let length2 = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];
        function position2() {
          return pos;
        }
        function unclosed(what) {
          throw input.error("Unclosed " + what, pos);
        }
        function endOfFile() {
          return returned.length === 0 && pos >= length2;
        }
        function nextToken(opts) {
          if (returned.length) return returned.pop();
          if (pos >= length2) return;
          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code = css.charCodeAt(pos);
          switch (code) {
            case NEWLINE:
            case SPACE3:
            case TAB:
            case CR:
            case FEED: {
              next = pos;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === SPACE3 || code === NEWLINE || code === TAB || code === CR || code === FEED);
              currentToken = ["space", css.slice(pos, next)];
              pos = next - 1;
              break;
            }
            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES: {
              let controlChar = String.fromCharCode(code);
              currentToken = [controlChar, controlChar, pos];
              break;
            }
            case OPEN_PARENTHESES: {
              prev = buffer.length ? buffer.pop()[1] : "";
              n2 = css.charCodeAt(pos + 1);
              if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE3 && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(")", next + 1);
                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos;
                      break;
                    } else {
                      unclosed("bracket");
                    }
                  }
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                next = css.indexOf(")", pos + 1);
                content = css.slice(pos, next + 1);
                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ["(", "(", pos];
                } else {
                  currentToken = ["brackets", content, pos, next];
                  pos = next;
                }
              }
              break;
            }
            case SINGLE_QUOTE:
            case DOUBLE_QUOTE: {
              quote = code === SINGLE_QUOTE ? "'" : '"';
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos + 1;
                    break;
                  } else {
                    unclosed("string");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["string", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case AT: {
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }
              currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case BACKSLASH: {
              next = pos;
              escape2 = true;
              while (css.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape2 = !escape2;
              }
              code = css.charCodeAt(next + 1);
              if (escape2 && code !== SLASH && code !== SPACE3 && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                next += 1;
                if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                  while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                    next += 1;
                  }
                  if (css.charCodeAt(next + 1) === SPACE3) {
                    next += 1;
                  }
                }
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            default: {
              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                next = css.indexOf("*/", pos + 2) + 1;
                if (next === 0) {
                  if (ignore || ignoreUnclosed) {
                    next = css.length;
                  } else {
                    unclosed("comment");
                  }
                }
                currentToken = ["comment", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }
                currentToken = ["word", css.slice(pos, next + 1), pos, next];
                buffer.push(currentToken);
                pos = next;
              }
              break;
            }
          }
          pos++;
          return currentToken;
        }
        function back(token) {
          returned.push(token);
        }
        return {
          back,
          endOfFile,
          nextToken,
          position: position2
        };
      };
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/parser.js"(exports, module) {
      "use strict";
      var AtRule2 = require_at_rule();
      var Comment2 = require_comment();
      var Declaration2 = require_declaration();
      var Root2 = require_root();
      var Rule2 = require_rule();
      var tokenizer2 = require_tokenize();
      var SAFE_COMMENT_NEIGHBOR = {
        empty: true,
        space: true
      };
      function findLastWithPosition(tokens) {
        for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
          let token = tokens[i2];
          let pos = token[3] || token[2];
          if (pos) return pos;
        }
      }
      var Parser = class {
        constructor(input) {
          this.input = input;
          this.root = new Root2();
          this.current = this.root;
          this.spaces = "";
          this.semicolon = false;
          this.createTokenizer();
          this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
        }
        atrule(token) {
          let node = new AtRule2();
          node.name = token[1].slice(1);
          if (node.name === "") {
            this.unnamedAtrule(node, token);
          }
          this.init(node, token[2]);
          let type;
          let prev;
          let shift;
          let last = false;
          let open = false;
          let params = [];
          let brackets = [];
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type = token[0];
            if (type === "(" || type === "[") {
              brackets.push(type === "(" ? ")" : "]");
            } else if (type === "{" && brackets.length > 0) {
              brackets.push("}");
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }
            if (brackets.length === 0) {
              if (type === ";") {
                node.source.end = this.getPosition(token[2]);
                node.source.end.offset++;
                this.semicolon = true;
                break;
              } else if (type === "{") {
                open = true;
                break;
              } else if (type === "}") {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev = params[shift];
                  while (prev && prev[0] === "space") {
                    prev = params[--shift];
                  }
                  if (prev) {
                    node.source.end = this.getPosition(prev[3] || prev[2]);
                    node.source.end.offset++;
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }
            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }
          node.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, "params", params);
            if (last) {
              token = params[params.length - 1];
              node.source.end = this.getPosition(token[3] || token[2]);
              node.source.end.offset++;
              this.spaces = node.raws.between;
              node.raws.between = "";
            }
          } else {
            node.raws.afterName = "";
            node.params = "";
          }
          if (open) {
            node.nodes = [];
            this.current = node;
          }
        }
        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false) return;
          let founded = 0;
          let token;
          for (let j2 = colon - 1; j2 >= 0; j2--) {
            token = tokens[j2];
            if (token[0] !== "space") {
              founded += 1;
              if (founded === 2) break;
            }
          }
          throw this.input.error(
            "Missed semicolon",
            token[0] === "word" ? token[3] + 1 : token[2]
          );
        }
        colon(tokens) {
          let brackets = 0;
          let prev, token, type;
          for (let [i2, element] of tokens.entries()) {
            token = element;
            type = token[0];
            if (type === "(") {
              brackets += 1;
            }
            if (type === ")") {
              brackets -= 1;
            }
            if (brackets === 0 && type === ":") {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === "word" && prev[1] === "progid") {
                continue;
              } else {
                return i2;
              }
            }
            prev = token;
          }
          return false;
        }
        comment(token) {
          let node = new Comment2();
          this.init(node, token[2]);
          node.source.end = this.getPosition(token[3] || token[2]);
          node.source.end.offset++;
          let text2 = token[1].slice(2, -2);
          if (/^\s*$/.test(text2)) {
            node.text = "";
            node.raws.left = text2;
            node.raws.right = "";
          } else {
            let match = text2.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }
        createTokenizer() {
          this.tokenizer = tokenizer2(this.input);
        }
        decl(tokens, customProperty) {
          let node = new Declaration2();
          this.init(node, tokens[0][2]);
          let last = tokens[tokens.length - 1];
          if (last[0] === ";") {
            this.semicolon = true;
            tokens.pop();
          }
          node.source.end = this.getPosition(
            last[3] || last[2] || findLastWithPosition(tokens)
          );
          node.source.end.offset++;
          while (tokens[0][0] !== "word") {
            if (tokens.length === 1) this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }
          node.source.start = this.getPosition(tokens[0][2]);
          node.prop = "";
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ":" || type === "space" || type === "comment") {
              break;
            }
            node.prop += tokens.shift()[1];
          }
          node.raws.between = "";
          let token;
          while (tokens.length) {
            token = tokens.shift();
            if (token[0] === ":") {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === "word" && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node.raws.between += token[1];
            }
          }
          if (node.prop[0] === "_" || node.prop[0] === "*") {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }
          let firstSpaces = [];
          let next;
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment") break;
            firstSpaces.push(tokens.shift());
          }
          this.precheckMissedSemicolon(tokens);
          for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
            token = tokens[i2];
            if (token[1].toLowerCase() === "!important") {
              node.important = true;
              let string = this.stringFrom(tokens, i2);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== " !important") node.raws.important = string;
              break;
            } else if (token[1].toLowerCase() === "important") {
              let cache3 = tokens.slice(0);
              let str = "";
              for (let j2 = i2; j2 > 0; j2--) {
                let type = cache3[j2][0];
                if (str.trim().startsWith("!") && type !== "space") {
                  break;
                }
                str = cache3.pop()[1] + str;
              }
              if (str.trim().startsWith("!")) {
                node.important = true;
                node.raws.important = str;
                tokens = cache3;
              }
            }
            if (token[0] !== "space" && token[0] !== "comment") {
              break;
            }
          }
          let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
          if (hasWord) {
            node.raws.between += firstSpaces.map((i2) => i2[1]).join("");
            firstSpaces = [];
          }
          this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
          if (node.value.includes(":") && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }
        doubleColon(token) {
          throw this.input.error(
            "Double colon",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
        emptyRule(token) {
          let node = new Rule2();
          this.init(node, token[2]);
          node.selector = "";
          node.raws.between = "";
          this.current = node;
        }
        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.spaces = "";
          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current.source.end.offset++;
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }
        endFile() {
          if (this.current.parent) this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.root.source.end = this.getPosition(this.tokenizer.position());
        }
        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = "";
            }
          }
        }
        // Helpers
        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            column: pos.col,
            line: pos.line,
            offset
          };
        }
        init(node, offset) {
          this.current.push(node);
          node.source = {
            input: this.input,
            start: this.getPosition(offset)
          };
          node.raws.before = this.spaces;
          this.spaces = "";
          if (node.type !== "comment") this.semicolon = false;
        }
        other(start) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith("--");
          let tokens = [];
          let token = start;
          while (token) {
            type = token[0];
            tokens.push(token);
            if (type === "(" || type === "[") {
              if (!bracket) bracket = token;
              brackets.push(type === "(" ? ")" : "]");
            } else if (customProperty && colon && type === "{") {
              if (!bracket) bracket = token;
              brackets.push("}");
            } else if (brackets.length === 0) {
              if (type === ";") {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === "{") {
                this.rule(tokens);
                return;
              } else if (type === "}") {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ":") {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0) bracket = null;
            }
            token = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile()) end = true;
          if (brackets.length > 0) this.unclosedBracket(bracket);
          if (end && colon) {
            if (!customProperty) {
              while (tokens.length) {
                token = tokens[tokens.length - 1][0];
                if (token !== "space" && token !== "comment") break;
                this.tokenizer.back(tokens.pop());
              }
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }
        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            switch (token[0]) {
              case "space":
                this.spaces += token[1];
                break;
              case ";":
                this.freeSemicolon(token);
                break;
              case "}":
                this.end(token);
                break;
              case "comment":
                this.comment(token);
                break;
              case "at-word":
                this.atrule(token);
                break;
              case "{":
                this.emptyRule(token);
                break;
              default:
                this.other(token);
                break;
            }
          }
          this.endFile();
        }
        precheckMissedSemicolon() {
        }
        raw(node, prop, tokens, customProperty) {
          let token, type;
          let length2 = tokens.length;
          let value2 = "";
          let clean = true;
          let next, prev;
          for (let i2 = 0; i2 < length2; i2 += 1) {
            token = tokens[i2];
            type = token[0];
            if (type === "space" && i2 === length2 - 1 && !customProperty) {
              clean = false;
            } else if (type === "comment") {
              prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
              next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
              if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
                if (value2.slice(-1) === ",") {
                  clean = false;
                } else {
                  value2 += token[1];
                }
              } else {
                clean = false;
              }
            } else {
              value2 += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i2) => all + i2[1], "");
            node.raws[prop] = { raw, value: value2 };
          }
          node[prop] = value2;
        }
        rule(tokens) {
          tokens.pop();
          let node = new Rule2();
          this.init(node, tokens[0][2]);
          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, "selector", tokens);
          this.current = node;
        }
        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space" && lastTokenType !== "comment") break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        // Errors
        spacesAndCommentsFromStart(tokens) {
          let next;
          let spaces = "";
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment") break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }
        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space") break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        stringFrom(tokens, from) {
          let result = "";
          for (let i2 = from; i2 < tokens.length; i2++) {
            result += tokens[i2][1];
          }
          tokens.splice(from, tokens.length - from);
          return result;
        }
        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error("Unclosed block", pos.line, pos.column);
        }
        unclosedBracket(bracket) {
          throw this.input.error(
            "Unclosed bracket",
            { offset: bracket[2] },
            { offset: bracket[2] + 1 }
          );
        }
        unexpectedClose(token) {
          throw this.input.error(
            "Unexpected }",
            { offset: token[2] },
            { offset: token[2] + 1 }
          );
        }
        unknownWord(tokens) {
          throw this.input.error(
            "Unknown word",
            { offset: tokens[0][2] },
            { offset: tokens[0][2] + tokens[0][1].length }
          );
        }
        unnamedAtrule(node, token) {
          throw this.input.error(
            "At-rule without name",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
      };
      module.exports = Parser;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/parse.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var Input2 = require_input();
      var Parser = require_parser();
      function parse5(css, opts) {
        let input = new Input2(css, opts);
        let parser5 = new Parser(input);
        try {
          parser5.parse();
        } catch (e5) {
          if (true) {
            if (e5.name === "CssSyntaxError" && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e5.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
              } else if (/\.sass/i.test(opts.from)) {
                e5.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
              } else if (/\.less$/i.test(opts.from)) {
                e5.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
              }
            }
          }
          throw e5;
        }
        return parser5.root;
      }
      module.exports = parse5;
      parse5.default = parse5;
      Container2.registerParse(parse5);
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/warning.js
  var require_warning = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/warning.js"(exports, module) {
      "use strict";
      var Warning2 = class {
        constructor(text2, opts = {}) {
          this.type = "warning";
          this.text = text2;
          if (opts.node && opts.node.source) {
            let range = opts.node.rangeBy(opts);
            this.line = range.start.line;
            this.column = range.start.column;
            this.endLine = range.end.line;
            this.endColumn = range.end.column;
          }
          for (let opt in opts) this[opt] = opts[opt];
        }
        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              index: this.index,
              plugin: this.plugin,
              word: this.word
            }).message;
          }
          if (this.plugin) {
            return this.plugin + ": " + this.text;
          }
          return this.text;
        }
      };
      module.exports = Warning2;
      Warning2.default = Warning2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/result.js
  var require_result = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/result.js"(exports, module) {
      "use strict";
      var Warning2 = require_warning();
      var Result2 = class {
        constructor(processor, root2, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root2;
          this.opts = opts;
          this.css = void 0;
          this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(text2, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }
          let warning = new Warning2(text2, opts);
          this.messages.push(warning);
          return warning;
        }
        warnings() {
          return this.messages.filter((i2) => i2.type === "warning");
        }
        get content() {
          return this.css;
        }
      };
      module.exports = Result2;
      Result2.default = Result2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/warn-once.js
  var require_warn_once = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/warn-once.js"(exports, module) {
      "use strict";
      var printed = {};
      module.exports = function warnOnce(message) {
        if (printed[message]) return;
        printed[message] = true;
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
      };
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/lazy-result.js
  var require_lazy_result = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/lazy-result.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var Document2 = require_document();
      var MapGenerator = require_map_generator();
      var parse5 = require_parse();
      var Result2 = require_result();
      var Root2 = require_root();
      var stringify3 = require_stringify();
      var { isClean, my } = require_symbols();
      var warnOnce = require_warn_once();
      var TYPE_TO_CLASS_NAME = {
        atrule: "AtRule",
        comment: "Comment",
        decl: "Declaration",
        document: "Document",
        root: "Root",
        rule: "Rule"
      };
      var PLUGIN_PROPS = {
        AtRule: true,
        AtRuleExit: true,
        Comment: true,
        CommentExit: true,
        Declaration: true,
        DeclarationExit: true,
        Document: true,
        DocumentExit: true,
        Once: true,
        OnceExit: true,
        postcssPlugin: true,
        prepare: true,
        Root: true,
        RootExit: true,
        Rule: true,
        RuleExit: true
      };
      var NOT_VISITORS = {
        Once: true,
        postcssPlugin: true,
        prepare: true
      };
      var CHILDREN = 0;
      function isPromise(obj) {
        return typeof obj === "object" && typeof obj.then === "function";
      }
      function getEvents(node) {
        let key = false;
        let type = TYPE_TO_CLASS_NAME[node.type];
        if (node.type === "decl") {
          key = node.prop.toLowerCase();
        } else if (node.type === "atrule") {
          key = node.name.toLowerCase();
        }
        if (key && node.append) {
          return [
            type,
            type + "-" + key,
            CHILDREN,
            type + "Exit",
            type + "Exit-" + key
          ];
        } else if (key) {
          return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
        } else if (node.append) {
          return [type, CHILDREN, type + "Exit"];
        } else {
          return [type, type + "Exit"];
        }
      }
      function toStack(node) {
        let events;
        if (node.type === "document") {
          events = ["Document", CHILDREN, "DocumentExit"];
        } else if (node.type === "root") {
          events = ["Root", CHILDREN, "RootExit"];
        } else {
          events = getEvents(node);
        }
        return {
          eventIndex: 0,
          events,
          iterator: 0,
          node,
          visitorIndex: 0,
          visitors: []
        };
      }
      function cleanMarks(node) {
        node[isClean] = false;
        if (node.nodes) node.nodes.forEach((i2) => cleanMarks(i2));
        return node;
      }
      var postcss2 = {};
      var LazyResult = class _LazyResult {
        constructor(processor, css, opts) {
          this.stringified = false;
          this.processed = false;
          let root2;
          if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
            root2 = cleanMarks(css);
          } else if (css instanceof _LazyResult || css instanceof Result2) {
            root2 = cleanMarks(css.root);
            if (css.map) {
              if (typeof opts.map === "undefined") opts.map = {};
              if (!opts.map.inline) opts.map.inline = false;
              opts.map.prev = css.map;
            }
          } else {
            let parser5 = parse5;
            if (opts.syntax) parser5 = opts.syntax.parse;
            if (opts.parser) parser5 = opts.parser;
            if (parser5.parse) parser5 = parser5.parse;
            try {
              root2 = parser5(css, opts);
            } catch (error) {
              this.processed = true;
              this.error = error;
            }
            if (root2 && !root2[my]) {
              Container2.rebuild(root2);
            }
          }
          this.result = new Result2(processor, root2, opts);
          this.helpers = { ...postcss2, postcss: postcss2, result: this.result };
          this.plugins = this.processor.plugins.map((plugin2) => {
            if (typeof plugin2 === "object" && plugin2.prepare) {
              return { ...plugin2, ...plugin2.prepare(this.result) };
            } else {
              return plugin2;
            }
          });
        }
        async() {
          if (this.error) return Promise.reject(this.error);
          if (this.processed) return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(error, node) {
          let plugin2 = this.result.lastPlugin;
          try {
            if (node) node.addToError(error);
            this.error = error;
            if (error.name === "CssSyntaxError" && !error.plugin) {
              error.plugin = plugin2.postcssPlugin;
              error.setMessage();
            } else if (plugin2.postcssVersion) {
              if (true) {
                let pluginName = plugin2.postcssPlugin;
                let pluginVer = plugin2.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a2 = pluginVer.split(".");
                let b2 = runtimeVer.split(".");
                if (a2[0] !== b2[0] || parseInt(a2[1]) > parseInt(b2[1])) {
                  console.error(
                    "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                  );
                }
              }
            }
          } catch (err) {
            if (console && console.error) console.error(err);
          }
          return error;
        }
        prepareVisitors() {
          this.listeners = {};
          let add = (plugin2, type, cb) => {
            if (!this.listeners[type]) this.listeners[type] = [];
            this.listeners[type].push([plugin2, cb]);
          };
          for (let plugin2 of this.plugins) {
            if (typeof plugin2 === "object") {
              for (let event in plugin2) {
                if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                  throw new Error(
                    `Unknown event ${event} in ${plugin2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                  );
                }
                if (!NOT_VISITORS[event]) {
                  if (typeof plugin2[event] === "object") {
                    for (let filter in plugin2[event]) {
                      if (filter === "*") {
                        add(plugin2, event, plugin2[event][filter]);
                      } else {
                        add(
                          plugin2,
                          event + "-" + filter.toLowerCase(),
                          plugin2[event][filter]
                        );
                      }
                    }
                  } else if (typeof plugin2[event] === "function") {
                    add(plugin2, event, plugin2[event]);
                  }
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        async runAsync() {
          this.plugin = 0;
          for (let i2 = 0; i2 < this.plugins.length; i2++) {
            let plugin2 = this.plugins[i2];
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (error) {
                throw this.handleError(error);
              }
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              let stack = [toStack(root2)];
              while (stack.length > 0) {
                let promise = this.visitTick(stack);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (e5) {
                    let node = stack[stack.length - 1].node;
                    throw this.handleError(e5, node);
                  }
                }
              }
            }
            if (this.listeners.OnceExit) {
              for (let [plugin2, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin2;
                try {
                  if (root2.type === "document") {
                    let roots = root2.nodes.map(
                      (subRoot) => visitor(subRoot, this.helpers)
                    );
                    await Promise.all(roots);
                  } else {
                    await visitor(root2, this.helpers);
                  }
                } catch (e5) {
                  throw this.handleError(e5);
                }
              }
            }
          }
          this.processed = true;
          return this.stringify();
        }
        runOnRoot(plugin2) {
          this.result.lastPlugin = plugin2;
          try {
            if (typeof plugin2 === "object" && plugin2.Once) {
              if (this.result.root.type === "document") {
                let roots = this.result.root.nodes.map(
                  (root2) => plugin2.Once(root2, this.helpers)
                );
                if (isPromise(roots[0])) {
                  return Promise.all(roots);
                }
                return roots;
              }
              return plugin2.Once(this.result.root, this.helpers);
            } else if (typeof plugin2 === "function") {
              return plugin2(this.result.root, this.result);
            }
          } catch (error) {
            throw this.handleError(error);
          }
        }
        stringify() {
          if (this.error) throw this.error;
          if (this.stringified) return this.result;
          this.stringified = true;
          this.sync();
          let opts = this.result.opts;
          let str = stringify3;
          if (opts.syntax) str = opts.syntax.stringify;
          if (opts.stringifier) str = opts.stringifier;
          if (str.stringify) str = str.stringify;
          let map = new MapGenerator(str, this.result.root, this.result.opts);
          let data = map.generate();
          this.result.css = data[0];
          this.result.map = data[1];
          return this.result;
        }
        sync() {
          if (this.error) throw this.error;
          if (this.processed) return this.result;
          this.processed = true;
          if (this.processing) {
            throw this.getAsyncError();
          }
          for (let plugin2 of this.plugins) {
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              this.walkSync(root2);
            }
            if (this.listeners.OnceExit) {
              if (root2.type === "document") {
                for (let subRoot of root2.nodes) {
                  this.visitSync(this.listeners.OnceExit, subRoot);
                }
              } else {
                this.visitSync(this.listeners.OnceExit, root2);
              }
            }
          }
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this.opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this.css;
        }
        visitSync(visitors, node) {
          for (let [plugin2, visitor] of visitors) {
            this.result.lastPlugin = plugin2;
            let promise;
            try {
              promise = visitor(node, this.helpers);
            } catch (e5) {
              throw this.handleError(e5, node.proxyOf);
            }
            if (node.type !== "root" && node.type !== "document" && !node.parent) {
              return true;
            }
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
        }
        visitTick(stack) {
          let visit2 = stack[stack.length - 1];
          let { node, visitors } = visit2;
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            stack.pop();
            return;
          }
          if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
            let [plugin2, visitor] = visitors[visit2.visitorIndex];
            visit2.visitorIndex += 1;
            if (visit2.visitorIndex === visitors.length) {
              visit2.visitors = [];
              visit2.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin2;
            try {
              return visitor(node.toProxy(), this.helpers);
            } catch (e5) {
              throw this.handleError(e5, node);
            }
          }
          if (visit2.iterator !== 0) {
            let iterator = visit2.iterator;
            let child;
            while (child = node.nodes[node.indexes[iterator]]) {
              node.indexes[iterator] += 1;
              if (!child[isClean]) {
                child[isClean] = true;
                stack.push(toStack(child));
                return;
              }
            }
            visit2.iterator = 0;
            delete node.indexes[iterator];
          }
          let events = visit2.events;
          while (visit2.eventIndex < events.length) {
            let event = events[visit2.eventIndex];
            visit2.eventIndex += 1;
            if (event === CHILDREN) {
              if (node.nodes && node.nodes.length) {
                node[isClean] = true;
                visit2.iterator = node.getIterator();
              }
              return;
            } else if (this.listeners[event]) {
              visit2.visitors = this.listeners[event];
              return;
            }
          }
          stack.pop();
        }
        walkSync(node) {
          node[isClean] = true;
          let events = getEvents(node);
          for (let event of events) {
            if (event === CHILDREN) {
              if (node.nodes) {
                node.each((child) => {
                  if (!child[isClean]) this.walkSync(child);
                });
              }
            } else {
              let visitors = this.listeners[event];
              if (visitors) {
                if (this.visitSync(visitors, node.toProxy())) return;
              }
            }
          }
        }
        warnings() {
          return this.sync().warnings();
        }
        get content() {
          return this.stringify().content;
        }
        get css() {
          return this.stringify().css;
        }
        get map() {
          return this.stringify().map;
        }
        get messages() {
          return this.sync().messages;
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          return this.sync().root;
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
      };
      LazyResult.registerPostcss = (dependant) => {
        postcss2 = dependant;
      };
      module.exports = LazyResult;
      LazyResult.default = LazyResult;
      Root2.registerLazyResult(LazyResult);
      Document2.registerLazyResult(LazyResult);
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/no-work-result.js
  var require_no_work_result = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/no-work-result.js"(exports, module) {
      "use strict";
      var MapGenerator = require_map_generator();
      var parse5 = require_parse();
      var Result2 = require_result();
      var stringify3 = require_stringify();
      var warnOnce = require_warn_once();
      var NoWorkResult = class {
        constructor(processor, css, opts) {
          css = css.toString();
          this.stringified = false;
          this._processor = processor;
          this._css = css;
          this._opts = opts;
          this._map = void 0;
          let root2;
          let str = stringify3;
          this.result = new Result2(this._processor, root2, this._opts);
          this.result.css = css;
          let self2 = this;
          Object.defineProperty(this.result, "root", {
            get() {
              return self2.root;
            }
          });
          let map = new MapGenerator(str, root2, this._opts, css);
          if (map.isMap()) {
            let [generatedCSS, generatedMap] = map.generate();
            if (generatedCSS) {
              this.result.css = generatedCSS;
            }
            if (generatedMap) {
              this.result.map = generatedMap;
            }
          } else {
            map.clearAnnotation();
            this.result.css = map.css;
          }
        }
        async() {
          if (this.error) return Promise.reject(this.error);
          return Promise.resolve(this.result);
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        sync() {
          if (this.error) throw this.error;
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this._opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this._css;
        }
        warnings() {
          return [];
        }
        get content() {
          return this.result.css;
        }
        get css() {
          return this.result.css;
        }
        get map() {
          return this.result.map;
        }
        get messages() {
          return [];
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          if (this._root) {
            return this._root;
          }
          let root2;
          let parser5 = parse5;
          try {
            root2 = parser5(this._css, this._opts);
          } catch (error) {
            this.error = error;
          }
          if (this.error) {
            throw this.error;
          } else {
            this._root = root2;
            return root2;
          }
        }
        get [Symbol.toStringTag]() {
          return "NoWorkResult";
        }
      };
      module.exports = NoWorkResult;
      NoWorkResult.default = NoWorkResult;
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/processor.js
  var require_processor = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/processor.js"(exports, module) {
      "use strict";
      var Document2 = require_document();
      var LazyResult = require_lazy_result();
      var NoWorkResult = require_no_work_result();
      var Root2 = require_root();
      var Processor2 = class {
        constructor(plugins = []) {
          this.version = "8.4.47";
          this.plugins = this.normalize(plugins);
        }
        normalize(plugins) {
          let normalized = [];
          for (let i2 of plugins) {
            if (i2.postcss === true) {
              i2 = i2();
            } else if (i2.postcss) {
              i2 = i2.postcss;
            }
            if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
              normalized = normalized.concat(i2.plugins);
            } else if (typeof i2 === "object" && i2.postcssPlugin) {
              normalized.push(i2);
            } else if (typeof i2 === "function") {
              normalized.push(i2);
            } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
              if (true) {
                throw new Error(
                  "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
                );
              }
            } else {
              throw new Error(i2 + " is not a PostCSS plugin");
            }
          }
          return normalized;
        }
        process(css, opts = {}) {
          if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
            return new NoWorkResult(this, css, opts);
          } else {
            return new LazyResult(this, css, opts);
          }
        }
        use(plugin2) {
          this.plugins = this.plugins.concat(this.normalize([plugin2]));
          return this;
        }
      };
      module.exports = Processor2;
      Processor2.default = Processor2;
      Root2.registerProcessor(Processor2);
      Document2.registerProcessor(Processor2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/postcss.js
  var require_postcss = __commonJS({
    "node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/postcss.js"(exports, module) {
      "use strict";
      var AtRule2 = require_at_rule();
      var Comment2 = require_comment();
      var Container2 = require_container();
      var CssSyntaxError2 = require_css_syntax_error();
      var Declaration2 = require_declaration();
      var Document2 = require_document();
      var fromJSON2 = require_fromJSON();
      var Input2 = require_input();
      var LazyResult = require_lazy_result();
      var list3 = require_list();
      var Node3 = require_node();
      var parse5 = require_parse();
      var Processor2 = require_processor();
      var Result2 = require_result();
      var Root2 = require_root();
      var Rule2 = require_rule();
      var stringify3 = require_stringify();
      var Warning2 = require_warning();
      function postcss2(...plugins) {
        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }
        return new Processor2(plugins);
      }
      postcss2.plugin = function plugin2(name, initializer) {
        let warningPrinted = false;
        function creator(...args) {
          if (console && console.warn && !warningPrinted) {
            warningPrinted = true;
            console.warn(
              name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
            );
            if (process.env.LANG && process.env.LANG.startsWith("cn")) {
              console.warn(
                name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
              );
            }
          }
          let transformer = initializer(...args);
          transformer.postcssPlugin = name;
          transformer.postcssVersion = new Processor2().version;
          return transformer;
        }
        let cache3;
        Object.defineProperty(creator, "postcss", {
          get() {
            if (!cache3) cache3 = creator();
            return cache3;
          }
        });
        creator.process = function(css, processOpts, pluginOpts) {
          return postcss2([creator(pluginOpts)]).process(css, processOpts);
        };
        return creator;
      };
      postcss2.stringify = stringify3;
      postcss2.parse = parse5;
      postcss2.fromJSON = fromJSON2;
      postcss2.list = list3;
      postcss2.comment = (defaults3) => new Comment2(defaults3);
      postcss2.atRule = (defaults3) => new AtRule2(defaults3);
      postcss2.decl = (defaults3) => new Declaration2(defaults3);
      postcss2.rule = (defaults3) => new Rule2(defaults3);
      postcss2.root = (defaults3) => new Root2(defaults3);
      postcss2.document = (defaults3) => new Document2(defaults3);
      postcss2.CssSyntaxError = CssSyntaxError2;
      postcss2.Declaration = Declaration2;
      postcss2.Container = Container2;
      postcss2.Processor = Processor2;
      postcss2.Document = Document2;
      postcss2.Comment = Comment2;
      postcss2.Warning = Warning2;
      postcss2.AtRule = AtRule2;
      postcss2.Result = Result2;
      postcss2.Input = Input2;
      postcss2.Rule = Rule2;
      postcss2.Root = Root2;
      postcss2.Node = Node3;
      LazyResult.registerPostcss(postcss2);
      module.exports = postcss2;
      postcss2.default = postcss2;
    }
  });

  // node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js
  var require_isarray = __commonJS({
    "node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js"(exports, module) {
      var toString2 = {}.toString;
      module.exports = Array.isArray || function(arr) {
        return toString2.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/.pnpm/isobject@2.1.0/node_modules/isobject/index.js
  var require_isobject = __commonJS({
    "node_modules/.pnpm/isobject@2.1.0/node_modules/isobject/index.js"(exports, module) {
      "use strict";
      var isArray = require_isarray();
      module.exports = function isObject4(val) {
        return val != null && typeof val === "object" && isArray(val) === false;
      };
    }
  });

  // node_modules/.pnpm/line-column@1.0.2/node_modules/line-column/lib/line-column.js
  var require_line_column = __commonJS({
    "node_modules/.pnpm/line-column@1.0.2/node_modules/line-column/lib/line-column.js"(exports, module) {
      "use strict";
      var isArray = require_isarray();
      var isObject4 = require_isobject();
      var slice = Array.prototype.slice;
      module.exports = LineColumnFinder;
      function LineColumnFinder(str, options) {
        if (!(this instanceof LineColumnFinder)) {
          if (typeof options === "number") {
            return new LineColumnFinder(str).fromIndex(options);
          }
          return new LineColumnFinder(str, options);
        }
        this.str = str || "";
        this.lineToIndex = buildLineToIndex(this.str);
        options = options || {};
        this.origin = typeof options.origin === "undefined" ? 1 : options.origin;
      }
      LineColumnFinder.prototype.fromIndex = function(index2) {
        if (index2 < 0 || index2 >= this.str.length || isNaN(index2)) {
          return null;
        }
        var line = findLowerIndexInRangeArray(index2, this.lineToIndex);
        return {
          line: line + this.origin,
          col: index2 - this.lineToIndex[line] + this.origin
        };
      };
      LineColumnFinder.prototype.toIndex = function(line, column) {
        if (typeof column === "undefined") {
          if (isArray(line) && line.length >= 2) {
            return this.toIndex(line[0], line[1]);
          }
          if (isObject4(line) && "line" in line && ("col" in line || "column" in line)) {
            return this.toIndex(line.line, "col" in line ? line.col : line.column);
          }
          return -1;
        }
        if (isNaN(line) || isNaN(column)) {
          return -1;
        }
        line -= this.origin;
        column -= this.origin;
        if (line >= 0 && column >= 0 && line < this.lineToIndex.length) {
          var lineIndex = this.lineToIndex[line];
          var nextIndex = line === this.lineToIndex.length - 1 ? this.str.length : this.lineToIndex[line + 1];
          if (column < nextIndex - lineIndex) {
            return lineIndex + column;
          }
        }
        return -1;
      };
      function buildLineToIndex(str) {
        var lines = str.split("\n"), lineToIndex = new Array(lines.length), index2 = 0;
        for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
          lineToIndex[i2] = index2;
          index2 += lines[i2].length + /* "\n".length */
          1;
        }
        return lineToIndex;
      }
      function findLowerIndexInRangeArray(value2, arr) {
        if (value2 >= arr[arr.length - 1]) {
          return arr.length - 1;
        }
        var min = 0, max2 = arr.length - 2, mid;
        while (min < max2) {
          mid = min + (max2 - min >> 1);
          if (value2 < arr[mid]) {
            max2 = mid - 1;
          } else if (value2 >= arr[mid + 1]) {
            min = mid + 1;
          } else {
            min = mid;
            break;
          }
        }
        return min;
      }
    }
  });

  // node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js
  var require_moo = __commonJS({
    "node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js"(exports, module) {
      (function(root2, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          root2.moo = factory();
        }
      })(exports, function() {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var toString2 = Object.prototype.toString;
        var hasSticky = typeof new RegExp().sticky === "boolean";
        function isRegExp(o2) {
          return o2 && toString2.call(o2) === "[object RegExp]";
        }
        function isObject4(o2) {
          return o2 && typeof o2 === "object" && !isRegExp(o2) && !Array.isArray(o2);
        }
        function reEscape(s2) {
          return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function reGroups(s2) {
          var re = new RegExp("|" + s2);
          return re.exec("").length - 1;
        }
        function reCapture(s2) {
          return "(" + s2 + ")";
        }
        function reUnion(regexps) {
          if (!regexps.length) return "(?!)";
          var source = regexps.map(function(s2) {
            return "(?:" + s2 + ")";
          }).join("|");
          return "(?:" + source + ")";
        }
        function regexpOrLiteral(obj) {
          if (typeof obj === "string") {
            return "(?:" + reEscape(obj) + ")";
          } else if (isRegExp(obj)) {
            if (obj.ignoreCase) throw new Error("RegExp /i flag not allowed");
            if (obj.global) throw new Error("RegExp /g flag is implied");
            if (obj.sticky) throw new Error("RegExp /y flag is implied");
            if (obj.multiline) throw new Error("RegExp /m flag is implied");
            return obj.source;
          } else {
            throw new Error("Not a pattern: " + obj);
          }
        }
        function pad(s2, length2) {
          if (s2.length > length2) {
            return s2;
          }
          return Array(length2 - s2.length + 1).join(" ") + s2;
        }
        function lastNLines(string, numLines) {
          var position2 = string.length;
          var lineBreaks = 0;
          while (true) {
            var idx = string.lastIndexOf("\n", position2 - 1);
            if (idx === -1) {
              break;
            } else {
              lineBreaks++;
            }
            position2 = idx;
            if (lineBreaks === numLines) {
              break;
            }
            if (position2 === 0) {
              break;
            }
          }
          var startPosition = lineBreaks < numLines ? 0 : position2 + 1;
          return string.substring(startPosition).split("\n");
        }
        function objectToRules(object) {
          var keys = Object.getOwnPropertyNames(object);
          var result = [];
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            var thing = object[key];
            var rules = [].concat(thing);
            if (key === "include") {
              for (var j2 = 0; j2 < rules.length; j2++) {
                result.push({ include: rules[j2] });
              }
              continue;
            }
            var match = [];
            rules.forEach(function(rule2) {
              if (isObject4(rule2)) {
                if (match.length) result.push(ruleOptions(key, match));
                result.push(ruleOptions(key, rule2));
                match = [];
              } else {
                match.push(rule2);
              }
            });
            if (match.length) result.push(ruleOptions(key, match));
          }
          return result;
        }
        function arrayToRules(array) {
          var result = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            var obj = array[i2];
            if (obj.include) {
              var include = [].concat(obj.include);
              for (var j2 = 0; j2 < include.length; j2++) {
                result.push({ include: include[j2] });
              }
              continue;
            }
            if (!obj.type) {
              throw new Error("Rule has no type: " + JSON.stringify(obj));
            }
            result.push(ruleOptions(obj.type, obj));
          }
          return result;
        }
        function ruleOptions(type, obj) {
          if (!isObject4(obj)) {
            obj = { match: obj };
          }
          if (obj.include) {
            throw new Error("Matching rules cannot also include states");
          }
          var options = {
            defaultType: type,
            lineBreaks: !!obj.error || !!obj.fallback,
            pop: false,
            next: null,
            push: null,
            error: false,
            fallback: false,
            value: null,
            type: null,
            shouldThrow: false
          };
          for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
              options[key] = obj[key];
            }
          }
          if (typeof options.type === "string" && type !== options.type) {
            throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
          }
          var match = options.match;
          options.match = Array.isArray(match) ? match : match ? [match] : [];
          options.match.sort(function(a2, b2) {
            return isRegExp(a2) && isRegExp(b2) ? 0 : isRegExp(b2) ? -1 : isRegExp(a2) ? 1 : b2.length - a2.length;
          });
          return options;
        }
        function toRules(spec) {
          return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
        }
        var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
        function compileRules(rules, hasStates) {
          var errorRule = null;
          var fast = /* @__PURE__ */ Object.create(null);
          var fastAllowed = true;
          var unicodeFlag = null;
          var groups = [];
          var parts = [];
          for (var i2 = 0; i2 < rules.length; i2++) {
            if (rules[i2].fallback) {
              fastAllowed = false;
            }
          }
          for (var i2 = 0; i2 < rules.length; i2++) {
            var options = rules[i2];
            if (options.include) {
              throw new Error("Inheritance is not allowed in stateless lexers");
            }
            if (options.error || options.fallback) {
              if (errorRule) {
                if (!options.fallback === !errorRule.fallback) {
                  throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
                } else {
                  throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
                }
              }
              errorRule = options;
            }
            var match = options.match.slice();
            if (fastAllowed) {
              while (match.length && typeof match[0] === "string" && match[0].length === 1) {
                var word = match.shift();
                fast[word.charCodeAt(0)] = options;
              }
            }
            if (options.pop || options.push || options.next) {
              if (!hasStates) {
                throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
              }
              if (options.fallback) {
                throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
              }
            }
            if (match.length === 0) {
              continue;
            }
            fastAllowed = false;
            groups.push(options);
            for (var j2 = 0; j2 < match.length; j2++) {
              var obj = match[j2];
              if (!isRegExp(obj)) {
                continue;
              }
              if (unicodeFlag === null) {
                unicodeFlag = obj.unicode;
              } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
                throw new Error("If one rule is /u then all must be");
              }
            }
            var pat = reUnion(match.map(regexpOrLiteral));
            var regexp = new RegExp(pat);
            if (regexp.test("")) {
              throw new Error("RegExp matches empty string: " + regexp);
            }
            var groupCount = reGroups(pat);
            if (groupCount > 0) {
              throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
            }
            if (!options.lineBreaks && regexp.test("\n")) {
              throw new Error("Rule should declare lineBreaks: " + regexp);
            }
            parts.push(reCapture(pat));
          }
          var fallbackRule = errorRule && errorRule.fallback;
          var flags = hasSticky && !fallbackRule ? "ym" : "gm";
          var suffix = hasSticky || fallbackRule ? "" : "|";
          if (unicodeFlag === true) flags += "u";
          var combined = new RegExp(reUnion(parts) + suffix, flags);
          return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
        }
        function compile(rules) {
          var result = compileRules(toRules(rules));
          return new Lexer({ start: result }, "start");
        }
        function checkStateGroup(g2, name, map) {
          var state = g2 && (g2.push || g2.next);
          if (state && !map[state]) {
            throw new Error("Missing state '" + state + "' (in token '" + g2.defaultType + "' of state '" + name + "')");
          }
          if (g2 && g2.pop && +g2.pop !== 1) {
            throw new Error("pop must be 1 (in token '" + g2.defaultType + "' of state '" + name + "')");
          }
        }
        function compileStates(states2, start) {
          var all = states2.$all ? toRules(states2.$all) : [];
          delete states2.$all;
          var keys = Object.getOwnPropertyNames(states2);
          if (!start) start = keys[0];
          var ruleMap = /* @__PURE__ */ Object.create(null);
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            ruleMap[key] = toRules(states2[key]).concat(all);
          }
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            var rules = ruleMap[key];
            var included = /* @__PURE__ */ Object.create(null);
            for (var j2 = 0; j2 < rules.length; j2++) {
              var rule2 = rules[j2];
              if (!rule2.include) continue;
              var splice = [j2, 1];
              if (rule2.include !== key && !included[rule2.include]) {
                included[rule2.include] = true;
                var newRules = ruleMap[rule2.include];
                if (!newRules) {
                  throw new Error("Cannot include nonexistent state '" + rule2.include + "' (in state '" + key + "')");
                }
                for (var k5 = 0; k5 < newRules.length; k5++) {
                  var newRule = newRules[k5];
                  if (rules.indexOf(newRule) !== -1) continue;
                  splice.push(newRule);
                }
              }
              rules.splice.apply(rules, splice);
              j2--;
            }
          }
          var map = /* @__PURE__ */ Object.create(null);
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            map[key] = compileRules(ruleMap[key], true);
          }
          for (var i2 = 0; i2 < keys.length; i2++) {
            var name = keys[i2];
            var state = map[name];
            var groups = state.groups;
            for (var j2 = 0; j2 < groups.length; j2++) {
              checkStateGroup(groups[j2], name, map);
            }
            var fastKeys = Object.getOwnPropertyNames(state.fast);
            for (var j2 = 0; j2 < fastKeys.length; j2++) {
              checkStateGroup(state.fast[fastKeys[j2]], name, map);
            }
          }
          return new Lexer(map, start);
        }
        function keywordTransform(map) {
          var isMap = typeof Map !== "undefined";
          var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
          var types2 = Object.getOwnPropertyNames(map);
          for (var i2 = 0; i2 < types2.length; i2++) {
            var tokenType = types2[i2];
            var item = map[tokenType];
            var keywordList = Array.isArray(item) ? item : [item];
            keywordList.forEach(function(keyword) {
              if (typeof keyword !== "string") {
                throw new Error("keyword must be string (in keyword '" + tokenType + "')");
              }
              if (isMap) {
                reverseMap.set(keyword, tokenType);
              } else {
                reverseMap[keyword] = tokenType;
              }
            });
          }
          return function(k5) {
            return isMap ? reverseMap.get(k5) : reverseMap[k5];
          };
        }
        var Lexer = function(states2, state) {
          this.startState = state;
          this.states = states2;
          this.buffer = "";
          this.stack = [];
          this.reset();
        };
        Lexer.prototype.reset = function(data, info) {
          this.buffer = data || "";
          this.index = 0;
          this.line = info ? info.line : 1;
          this.col = info ? info.col : 1;
          this.queuedToken = info ? info.queuedToken : null;
          this.queuedText = info ? info.queuedText : "";
          this.queuedThrow = info ? info.queuedThrow : null;
          this.setState(info ? info.state : this.startState);
          this.stack = info && info.stack ? info.stack.slice() : [];
          return this;
        };
        Lexer.prototype.save = function() {
          return {
            line: this.line,
            col: this.col,
            state: this.state,
            stack: this.stack.slice(),
            queuedToken: this.queuedToken,
            queuedText: this.queuedText,
            queuedThrow: this.queuedThrow
          };
        };
        Lexer.prototype.setState = function(state) {
          if (!state || this.state === state) return;
          this.state = state;
          var info = this.states[state];
          this.groups = info.groups;
          this.error = info.error;
          this.re = info.regexp;
          this.fast = info.fast;
        };
        Lexer.prototype.popState = function() {
          this.setState(this.stack.pop());
        };
        Lexer.prototype.pushState = function(state) {
          this.stack.push(this.state);
          this.setState(state);
        };
        var eat = hasSticky ? function(re, buffer) {
          return re.exec(buffer);
        } : function(re, buffer) {
          var match = re.exec(buffer);
          if (match[0].length === 0) {
            return null;
          }
          return match;
        };
        Lexer.prototype._getGroup = function(match) {
          var groupCount = this.groups.length;
          for (var i2 = 0; i2 < groupCount; i2++) {
            if (match[i2 + 1] !== void 0) {
              return this.groups[i2];
            }
          }
          throw new Error("Cannot find token type for matched text");
        };
        function tokenToString() {
          return this.value;
        }
        Lexer.prototype.next = function() {
          var index2 = this.index;
          if (this.queuedGroup) {
            var token = this._token(this.queuedGroup, this.queuedText, index2);
            this.queuedGroup = null;
            this.queuedText = "";
            return token;
          }
          var buffer = this.buffer;
          if (index2 === buffer.length) {
            return;
          }
          var group = this.fast[buffer.charCodeAt(index2)];
          if (group) {
            return this._token(group, buffer.charAt(index2), index2);
          }
          var re = this.re;
          re.lastIndex = index2;
          var match = eat(re, buffer);
          var error = this.error;
          if (match == null) {
            return this._token(error, buffer.slice(index2, buffer.length), index2);
          }
          var group = this._getGroup(match);
          var text2 = match[0];
          if (error.fallback && match.index !== index2) {
            this.queuedGroup = group;
            this.queuedText = text2;
            return this._token(error, buffer.slice(index2, match.index), index2);
          }
          return this._token(group, text2, index2);
        };
        Lexer.prototype._token = function(group, text2, offset) {
          var lineBreaks = 0;
          if (group.lineBreaks) {
            var matchNL = /\n/g;
            var nl = 1;
            if (text2 === "\n") {
              lineBreaks = 1;
            } else {
              while (matchNL.exec(text2)) {
                lineBreaks++;
                nl = matchNL.lastIndex;
              }
            }
          }
          var token = {
            type: typeof group.type === "function" && group.type(text2) || group.defaultType,
            value: typeof group.value === "function" ? group.value(text2) : text2,
            text: text2,
            toString: tokenToString,
            offset,
            lineBreaks,
            line: this.line,
            col: this.col
          };
          var size = text2.length;
          this.index += size;
          this.line += lineBreaks;
          if (lineBreaks !== 0) {
            this.col = size - nl + 1;
          } else {
            this.col += size;
          }
          if (group.shouldThrow) {
            var err = new Error(this.formatError(token, "invalid syntax"));
            throw err;
          }
          if (group.pop) this.popState();
          else if (group.push) this.pushState(group.push);
          else if (group.next) this.setState(group.next);
          return token;
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          var LexerIterator = function(lexer) {
            this.lexer = lexer;
          };
          LexerIterator.prototype.next = function() {
            var token = this.lexer.next();
            return { value: token, done: !token };
          };
          LexerIterator.prototype[Symbol.iterator] = function() {
            return this;
          };
          Lexer.prototype[Symbol.iterator] = function() {
            return new LexerIterator(this);
          };
        }
        Lexer.prototype.formatError = function(token, message) {
          if (token == null) {
            var text2 = this.buffer.slice(this.index);
            var token = {
              text: text2,
              offset: this.index,
              lineBreaks: text2.indexOf("\n") === -1 ? 0 : 1,
              line: this.line,
              col: this.col
            };
          }
          var numLinesAround = 2;
          var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
          var lastDisplayedLine = token.line + numLinesAround;
          var lastLineDigits = String(lastDisplayedLine).length;
          var displayedLines = lastNLines(
            this.buffer,
            this.line - token.line + numLinesAround + 1
          ).slice(0, 5);
          var errorLines = [];
          errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
          errorLines.push("");
          for (var i2 = 0; i2 < displayedLines.length; i2++) {
            var line = displayedLines[i2];
            var lineNo = firstDisplayedLine + i2;
            errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
            if (lineNo === token.line) {
              errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
            }
          }
          return errorLines.join("\n");
        };
        Lexer.prototype.clone = function() {
          return new Lexer(this.states, this.state);
        };
        Lexer.prototype.has = function(tokenType) {
          return true;
        };
        return {
          compile,
          states: compileStates,
          error: Object.freeze({ error: true }),
          fallback: Object.freeze({ fallback: true }),
          keywords: keywordTransform
        };
      });
    }
  });

  // node_modules/.pnpm/tmp-cache@1.1.0/node_modules/tmp-cache/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/tmp-cache@1.1.0/node_modules/tmp-cache/lib/index.js"(exports, module) {
      var Cache3 = class extends Map {
        constructor(opts = {}) {
          super();
          if (typeof opts === "number") {
            opts = { max: opts };
          }
          let { max: max2, maxAge } = opts;
          this.max = max2 > 0 && max2 || Infinity;
          this.maxAge = maxAge !== void 0 ? maxAge : -1;
          this.stale = !!opts.stale;
        }
        peek(key) {
          return this.get(key, false);
        }
        set(key, content, maxAge = this.maxAge) {
          this.has(key) && this.delete(key);
          this.size + 1 > this.max && this.delete(this.keys().next().value);
          let expires = maxAge > -1 && maxAge + Date.now();
          return super.set(key, { expires, content });
        }
        get(key, mut = true) {
          let x2 = super.get(key);
          if (x2 === void 0) return x2;
          let { expires, content } = x2;
          if (expires !== false && Date.now() >= expires) {
            this.delete(key);
            return this.stale ? content : void 0;
          }
          if (mut) this.set(key, content);
          return content;
        }
      };
      module.exports = Cache3;
    }
  });

  // node_modules/.pnpm/css.escape@1.5.1/node_modules/css.escape/css.escape.js
  var require_css_escape = __commonJS({
    "node_modules/.pnpm/css.escape@1.5.1/node_modules/css.escape/css.escape.js"(exports, module) {
      (function(root2, factory) {
        if (typeof exports == "object") {
          module.exports = factory(root2);
        } else if (typeof define == "function" && define.amd) {
          define([], factory.bind(root2, root2));
        } else {
          factory(root2);
        }
      })(typeof global != "undefined" ? global : exports, function(root2) {
        if (root2.CSS && root2.CSS.escape) {
          return root2.CSS.escape;
        }
        var cssEscape = function(value2) {
          if (arguments.length == 0) {
            throw new TypeError("`CSS.escape` requires an argument.");
          }
          var string = String(value2);
          var length2 = string.length;
          var index2 = -1;
          var codeUnit;
          var result = "";
          var firstCodeUnit = string.charCodeAt(0);
          while (++index2 < length2) {
            codeUnit = string.charCodeAt(index2);
            if (codeUnit == 0) {
              result += "\uFFFD";
              continue;
            }
            if (
              // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
              // U+007F, […]
              codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
              // (U+0030 to U+0039), […]
              index2 == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
              // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
              index2 == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
            ) {
              result += "\\" + codeUnit.toString(16) + " ";
              continue;
            }
            if (
              // If the character is the first character and is a `-` (U+002D), and
              // there is no second character, […]
              index2 == 0 && length2 == 1 && codeUnit == 45
            ) {
              result += "\\" + string.charAt(index2);
              continue;
            }
            if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
              result += string.charAt(index2);
              continue;
            }
            result += "\\" + string.charAt(index2);
          }
          return result;
        };
        if (!root2.CSS) {
          root2.CSS = {};
        }
        root2.CSS.escape = cssEscape;
        return cssEscape;
      });
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js
  var require_debug = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js"(exports, module) {
      var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module.exports = debug;
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js
  var require_constants = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js"(exports, module) {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
      9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      var RELEASE_TYPES = [
        "major",
        "premajor",
        "minor",
        "preminor",
        "patch",
        "prepatch",
        "prerelease"
      ];
      module.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
      };
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js
  var require_re = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js"(exports, module) {
      var {
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_LENGTH
      } = require_constants();
      var debug = require_debug();
      exports = module.exports = {};
      var re = exports.re = [];
      var safeRe = exports.safeRe = [];
      var src = exports.src = [];
      var t2 = exports.t = {};
      var R3 = 0;
      var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      var safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
      ];
      var makeSafeRegex = (value2) => {
        for (const [token, max2] of safeRegexReplacements) {
          value2 = value2.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
        }
        return value2;
      };
      var createToken = (name, value2, isGlobal) => {
        const safe = makeSafeRegex(value2);
        const index2 = R3++;
        debug(name, index2, value2);
        t2[name] = index2;
        src[index2] = value2;
        re[index2] = new RegExp(value2, isGlobal ? "g" : void 0);
        safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
      createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
      createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
      createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
      createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
      createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t2.COERCE], true);
      createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
      exports.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js
  var require_parse_options = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js"(exports, module) {
      var looseOption = Object.freeze({ loose: true });
      var emptyOpts = Object.freeze({});
      var parseOptions = (options) => {
        if (!options) {
          return emptyOpts;
        }
        if (typeof options !== "object") {
          return looseOption;
        }
        return options;
      };
      module.exports = parseOptions;
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/identifiers.js
  var require_identifiers = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/identifiers.js"(exports, module) {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a2, b2) => {
        const anum = numeric.test(a2);
        const bnum = numeric.test(b2);
        if (anum && bnum) {
          a2 = +a2;
          b2 = +b2;
        }
        return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
      };
      var rcompareIdentifiers = (a2, b2) => compareIdentifiers(b2, a2);
      module.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js
  var require_semver = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"(exports, module) {
      var debug = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
      var { safeRe: re, t: t2 } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = class _SemVer {
        constructor(version2, options) {
          options = parseOptions(options);
          if (version2 instanceof _SemVer) {
            if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
              return version2;
            } else {
              version2 = version2.version;
            }
          } else if (typeof version2 !== "string") {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
          }
          if (version2.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            );
          }
          debug("SemVer", version2, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m2 = version2.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
          if (!m2) {
            throw new TypeError(`Invalid Version: ${version2}`);
          }
          this.raw = version2;
          this.major = +m2[1];
          this.minor = +m2[2];
          this.patch = +m2[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m2[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m2[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num3 = +id;
                if (num3 >= 0 && num3 < MAX_SAFE_INTEGER) {
                  return num3;
                }
              }
              return id;
            });
          }
          this.build = m2[5] ? m2[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof _SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new _SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i2 = 0;
          do {
            const a2 = this.prerelease[i2];
            const b2 = other.prerelease[i2];
            debug("prerelease compare", i2, a2, b2);
            if (a2 === void 0 && b2 === void 0) {
              return 0;
            } else if (b2 === void 0) {
              return 1;
            } else if (a2 === void 0) {
              return -1;
            } else if (a2 === b2) {
              continue;
            } else {
              return compareIdentifiers(a2, b2);
            }
          } while (++i2);
        }
        compareBuild(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          let i2 = 0;
          do {
            const a2 = this.build[i2];
            const b2 = other.build[i2];
            debug("build compare", i2, a2, b2);
            if (a2 === void 0 && b2 === void 0) {
              return 0;
            } else if (b2 === void 0) {
              return 1;
            } else if (a2 === void 0) {
              return -1;
            } else if (a2 === b2) {
              continue;
            } else {
              return compareIdentifiers(a2, b2);
            }
          } while (++i2);
        }
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        inc(release, identifier, identifierBase) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier, identifierBase);
              }
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre": {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error("invalid increment argument: identifier is empty");
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i2 = this.prerelease.length;
                while (--i2 >= 0) {
                  if (typeof this.prerelease[i2] === "number") {
                    this.prerelease[i2]++;
                    i2 = -2;
                  }
                }
                if (i2 === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === false) {
                    throw new Error("invalid increment argument: identifier already exists");
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
          }
          return this;
        }
      };
      module.exports = SemVer;
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js
  var require_compare = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js"(exports, module) {
      var SemVer = require_semver();
      var compare = (a2, b2, loose) => new SemVer(a2, loose).compare(new SemVer(b2, loose));
      module.exports = compare;
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js
  var require_gte = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js"(exports, module) {
      var compare = require_compare();
      var gte2 = (a2, b2, loose) => compare(a2, b2, loose) >= 0;
      module.exports = gte2;
    }
  });

  // node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js
  var require_lte = __commonJS({
    "node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js"(exports, module) {
      var compare = require_compare();
      var lte = (a2, b2, loose) => compare(a2, b2, loose) <= 0;
      module.exports = lte;
    }
  });

  // node_modules/.pnpm/sift-string@0.0.2/node_modules/sift-string/index.js
  var require_sift_string = __commonJS({
    "node_modules/.pnpm/sift-string@0.0.2/node_modules/sift-string/index.js"(exports, module) {
      module.exports = function sift2(s1, s2) {
        if (s1 == null || s1.length === 0) {
          if (s2 == null || s2.length === 0) {
            return 0;
          } else {
            return s2.length;
          }
        }
        if (s2 == null || s2.length === 0) {
          return s1.length;
        }
        var c3 = 0;
        var offset1 = 0;
        var offset2 = 0;
        var lcs = 0;
        var maxOffset = 5;
        while (c3 + offset1 < s1.length && c3 + offset2 < s2.length) {
          if (s1.charAt(c3 + offset1) == s2.charAt(c3 + offset2)) {
            lcs++;
          } else {
            offset1 = 0;
            offset2 = 0;
            for (var i2 = 0; i2 < maxOffset; i2++) {
              if (c3 + i2 < s1.length && s1.charAt(c3 + i2) == s2.charAt(c3)) {
                offset1 = i2;
                break;
              }
              if (c3 + i2 < s2.length && s1.charAt(c3) == s2.charAt(c3 + i2)) {
                offset2 = i2;
                break;
              }
            }
          }
          c3++;
        }
        return (s1.length + s2.length) / 2 - lcs;
      };
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/unesc.js
  var require_unesc = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/unesc.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = unesc;
      function gobbleHex(str) {
        var lower = str.toLowerCase();
        var hex2 = "";
        var spaceTerminated = false;
        for (var i2 = 0; i2 < 6 && lower[i2] !== void 0; i2++) {
          var code = lower.charCodeAt(i2);
          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
          spaceTerminated = code === 32;
          if (!valid) {
            break;
          }
          hex2 += lower[i2];
        }
        if (hex2.length === 0) {
          return void 0;
        }
        var codePoint = parseInt(hex2, 16);
        var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
        if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
          return ["\uFFFD", hex2.length + (spaceTerminated ? 1 : 0)];
        }
        return [String.fromCodePoint(codePoint), hex2.length + (spaceTerminated ? 1 : 0)];
      }
      var CONTAINS_ESCAPE = /\\/;
      function unesc(str) {
        var needToProcess = CONTAINS_ESCAPE.test(str);
        if (!needToProcess) {
          return str;
        }
        var ret = "";
        for (var i2 = 0; i2 < str.length; i2++) {
          if (str[i2] === "\\") {
            var gobbled = gobbleHex(str.slice(i2 + 1, i2 + 7));
            if (gobbled !== void 0) {
              ret += gobbled[0];
              i2 += gobbled[1];
              continue;
            }
            if (str[i2 + 1] === "\\") {
              ret += "\\";
              i2++;
              continue;
            }
            if (str.length === i2 + 1) {
              ret += str[i2];
            }
            continue;
          }
          ret += str[i2];
        }
        return ret;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/getProp.js
  var require_getProp = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/getProp.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = getProp;
      function getProp(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            return void 0;
          }
          obj = obj[prop];
        }
        return obj;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/ensureObject.js
  var require_ensureObject = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = ensureObject;
      function ensureObject(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            obj[prop] = {};
          }
          obj = obj[prop];
        }
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/stripComments.js
  var require_stripComments = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = stripComments;
      function stripComments(str) {
        var s2 = "";
        var commentStart = str.indexOf("/*");
        var lastEnd = 0;
        while (commentStart >= 0) {
          s2 = s2 + str.slice(lastEnd, commentStart);
          var commentEnd = str.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) {
            return s2;
          }
          lastEnd = commentEnd + 2;
          commentStart = str.indexOf("/*", lastEnd);
        }
        s2 = s2 + str.slice(lastEnd);
        return s2;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/index.js
  var require_util = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/util/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.unesc = exports.stripComments = exports.getProp = exports.ensureObject = void 0;
      var _unesc = _interopRequireDefault(require_unesc());
      exports.unesc = _unesc["default"];
      var _getProp = _interopRequireDefault(require_getProp());
      exports.getProp = _getProp["default"];
      var _ensureObject = _interopRequireDefault(require_ensureObject());
      exports.ensureObject = _ensureObject["default"];
      var _stripComments = _interopRequireDefault(require_stripComments());
      exports.stripComments = _stripComments["default"];
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/node.js
  var require_node2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/node.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _util = require_util();
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var cloneNode = function cloneNode2(obj, parent) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var cloned = new obj.constructor();
        for (var i2 in obj) {
          if (!obj.hasOwnProperty(i2)) {
            continue;
          }
          var value2 = obj[i2];
          var type = typeof value2;
          if (i2 === "parent" && type === "object") {
            if (parent) {
              cloned[i2] = parent;
            }
          } else if (value2 instanceof Array) {
            cloned[i2] = value2.map(function(j2) {
              return cloneNode2(j2, cloned);
            });
          } else {
            cloned[i2] = cloneNode2(value2, cloned);
          }
        }
        return cloned;
      };
      var Node3 = /* @__PURE__ */ function() {
        function Node4(opts) {
          if (opts === void 0) {
            opts = {};
          }
          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || "";
          this.spaces.after = this.spaces.after || "";
        }
        var _proto = Node4.prototype;
        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        };
        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index2 in arguments) {
              this.parent.insertBefore(this, arguments[index2]);
            }
            this.remove();
          }
          return this;
        };
        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };
        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };
        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }
          var cloned = cloneNode(this);
          for (var name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        };
        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value2;
          if (originalEscaped || valueEscaped !== value2) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name];
          }
        };
        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          this[name] = value2;
          this.raws[name] = valueEscaped;
        };
        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value2) {
          this[name] = value2;
          if (this.raws) {
            delete this.raws[name];
          }
        };
        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }
            if (this.source.end.line < line) {
              return false;
            }
            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }
            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }
            return true;
          }
          return void 0;
        };
        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };
        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };
        _proto.toString = function toString2() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        };
        _createClass(Node4, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === void 0) {
              rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === void 0) {
              rawSpace = this.spaces.after;
            }
            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          }
        }]);
        return Node4;
      }();
      exports["default"] = Node3;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/types.js
  var require_types = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/types.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.UNIVERSAL = exports.TAG = exports.STRING = exports.SELECTOR = exports.ROOT = exports.PSEUDO = exports.NESTING = exports.ID = exports.COMMENT = exports.COMBINATOR = exports.CLASS = exports.ATTRIBUTE = void 0;
      var TAG = "tag";
      exports.TAG = TAG;
      var STRING = "string";
      exports.STRING = STRING;
      var SELECTOR = "selector";
      exports.SELECTOR = SELECTOR;
      var ROOT = "root";
      exports.ROOT = ROOT;
      var PSEUDO = "pseudo";
      exports.PSEUDO = PSEUDO;
      var NESTING = "nesting";
      exports.NESTING = NESTING;
      var ID = "id";
      exports.ID = ID;
      var COMMENT = "comment";
      exports.COMMENT = COMMENT;
      var COMBINATOR = "combinator";
      exports.COMBINATOR = COMBINATOR;
      var CLASS = "class";
      exports.CLASS = CLASS;
      var ATTRIBUTE = "attribute";
      exports.ATTRIBUTE = ATTRIBUTE;
      var UNIVERSAL = "universal";
      exports.UNIVERSAL = UNIVERSAL;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/container.js
  var require_container2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/container.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var types2 = _interopRequireWildcard(require_types());
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
        if (it) return (it = it.call(o2)).next.bind(it);
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it) o2 = it;
          var i2 = 0;
          return function() {
            if (i2 >= o2.length) return { done: true };
            return { done: false, value: o2[i2++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2) return;
        if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set") return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Container2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Container3, _Node);
        function Container3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          if (!_this.nodes) {
            _this.nodes = [];
          }
          return _this;
        }
        var _proto = Container3.prototype;
        _proto.append = function append(selector) {
          selector.parent = this;
          this.nodes.push(selector);
          return this;
        };
        _proto.prepend = function prepend(selector) {
          selector.parent = this;
          this.nodes.unshift(selector);
          return this;
        };
        _proto.at = function at(index2) {
          return this.nodes[index2];
        };
        _proto.index = function index2(child) {
          if (typeof child === "number") {
            return child;
          }
          return this.nodes.indexOf(child);
        };
        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = void 0;
          this.nodes.splice(child, 1);
          var index2;
          for (var id in this.indexes) {
            index2 = this.indexes[id];
            if (index2 >= child) {
              this.indexes[id] = index2 - 1;
            }
          }
          return this;
        };
        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
            var node = _step.value;
            node.parent = void 0;
          }
          this.nodes = [];
          return this;
        };
        _proto.empty = function empty() {
          return this.removeAll();
        };
        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index2;
          for (var id in this.indexes) {
            index2 = this.indexes[id];
            if (oldIndex <= index2) {
              this.indexes[id] = index2 + 1;
            }
          }
          return this;
        };
        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index2;
          for (var id in this.indexes) {
            index2 = this.indexes[id];
            if (index2 <= oldIndex) {
              this.indexes[id] = index2 + 1;
            }
          }
          return this;
        };
        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = void 0;
          this.each(function(node) {
            if (node.atPosition) {
              var foundChild = node.atPosition(line, col);
              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node.isAtPosition(line, col)) {
              found = node;
              return false;
            }
          });
          return found;
        };
        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return void 0;
          }
        };
        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };
        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }
          if (!this.indexes) {
            this.indexes = {};
          }
          this.lastEach++;
          var id = this.lastEach;
          this.indexes[id] = 0;
          if (!this.length) {
            return void 0;
          }
          var index2, result;
          while (this.indexes[id] < this.length) {
            index2 = this.indexes[id];
            result = callback(this.at(index2), index2);
            if (result === false) {
              break;
            }
            this.indexes[id] += 1;
          }
          delete this.indexes[id];
          if (result === false) {
            return false;
          }
        };
        _proto.walk = function walk(callback) {
          return this.each(function(node, i2) {
            var result = callback(node, i2);
            if (result !== false && node.length) {
              result = node.walk(callback);
            }
            if (result === false) {
              return false;
            }
          });
        };
        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.ATTRIBUTE) {
              return callback.call(_this2, selector);
            }
          });
        };
        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.CLASS) {
              return callback.call(_this3, selector);
            }
          });
        };
        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.COMBINATOR) {
              return callback.call(_this4, selector);
            }
          });
        };
        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.COMMENT) {
              return callback.call(_this5, selector);
            }
          });
        };
        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.ID) {
              return callback.call(_this6, selector);
            }
          });
        };
        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.NESTING) {
              return callback.call(_this7, selector);
            }
          });
        };
        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.PSEUDO) {
              return callback.call(_this8, selector);
            }
          });
        };
        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.TAG) {
              return callback.call(_this9, selector);
            }
          });
        };
        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.UNIVERSAL) {
              return callback.call(_this10, selector);
            }
          });
        };
        _proto.split = function split(callback) {
          var _this11 = this;
          var current = [];
          return this.reduce(function(memo, node, index2) {
            var split2 = callback.call(_this11, node);
            current.push(node);
            if (split2) {
              memo.push(current);
              current = [];
            } else if (index2 === _this11.length - 1) {
              memo.push(current);
            }
            return memo;
          }, []);
        };
        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };
        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };
        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };
        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };
        _proto.filter = function filter(callback) {
          return this.nodes.filter(callback);
        };
        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };
        _proto.toString = function toString2() {
          return this.map(String).join("");
        };
        _createClass(Container3, [{
          key: "first",
          get: function get() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function get() {
            return this.nodes.length;
          }
        }]);
        return Container3;
      }(_node["default"]);
      exports["default"] = Container2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/root.js
  var require_root2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/root.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Root2 = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Root3, _Container);
        function Root3(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.ROOT;
          return _this;
        }
        var _proto = Root3.prototype;
        _proto.toString = function toString2() {
          var str = this.reduce(function(memo, selector) {
            memo.push(String(selector));
            return memo;
          }, []).join(",");
          return this.trailingComma ? str + "," : str;
        };
        _proto.error = function error(message, options) {
          if (this._error) {
            return this._error(message, options);
          } else {
            return new Error(message);
          }
        };
        _createClass(Root3, [{
          key: "errorGenerator",
          set: function set(handler) {
            this._error = handler;
          }
        }]);
        return Root3;
      }(_container["default"]);
      exports["default"] = Root2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/selector.js
  var require_selector = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Selector = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Selector2, _Container);
        function Selector2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.SELECTOR;
          return _this;
        }
        return Selector2;
      }(_container["default"]);
      exports["default"] = Selector;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js
  var require_cssesc = __commonJS({
    "node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js"(exports, module) {
      "use strict";
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var merge = function merge2(options, defaults3) {
        if (!options) {
          return defaults3;
        }
        var result = {};
        for (var key in defaults3) {
          result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults3[key];
        }
        return result;
      };
      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
      var cssesc = function cssesc2(string, options) {
        options = merge(options, cssesc2.options);
        if (options.quotes != "single" && options.quotes != "double") {
          options.quotes = "single";
        }
        var quote = options.quotes == "double" ? '"' : "'";
        var isIdentifier = options.isIdentifier;
        var firstChar = string.charAt(0);
        var output = "";
        var counter = 0;
        var length2 = string.length;
        while (counter < length2) {
          var character = string.charAt(counter++);
          var codePoint = character.charCodeAt();
          var value2 = void 0;
          if (codePoint < 32 || codePoint > 126) {
            if (codePoint >= 55296 && codePoint <= 56319 && counter < length2) {
              var extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
              } else {
                counter--;
              }
            }
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else {
            if (options.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value2 = "\\" + character;
              } else {
                value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
              value2 = "\\" + character;
            } else {
              value2 = character;
            }
          }
          output += value2;
        }
        if (isIdentifier) {
          if (/^-[-\d]/.test(output)) {
            output = "\\-" + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = "\\3" + firstChar + " " + output.slice(1);
          }
        }
        output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
          if ($1 && $1.length % 2) {
            return $0;
          }
          return ($1 || "") + $2;
        });
        if (!isIdentifier && options.wrap) {
          return quote + output + quote;
        }
        return output;
      };
      cssesc.options = {
        "escapeEverything": false,
        "isIdentifier": false,
        "quotes": "single",
        "wrap": false
      };
      cssesc.version = "3.0.0";
      module.exports = cssesc;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/className.js
  var require_className = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/className.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _util = require_util();
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var ClassName = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ClassName2, _Node);
        function ClassName2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.CLASS;
          _this._constructed = true;
          return _this;
        }
        var _proto = ClassName2.prototype;
        _proto.valueToString = function valueToString() {
          return "." + _Node.prototype.valueToString.call(this);
        };
        _createClass(ClassName2, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(v2) {
            if (this._constructed) {
              var escaped = (0, _cssesc["default"])(v2, {
                isIdentifier: true
              });
              if (escaped !== v2) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }
            this._value = v2;
          }
        }]);
        return ClassName2;
      }(_node["default"]);
      exports["default"] = ClassName;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/comment.js
  var require_comment2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Comment2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Comment3, _Node);
        function Comment3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMMENT;
          return _this;
        }
        return Comment3;
      }(_node["default"]);
      exports["default"] = Comment2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/id.js
  var require_id = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/id.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var ID = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ID2, _Node);
        function ID2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.ID;
          return _this;
        }
        var _proto = ID2.prototype;
        _proto.valueToString = function valueToString() {
          return "#" + _Node.prototype.valueToString.call(this);
        };
        return ID2;
      }(_node["default"]);
      exports["default"] = ID;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/namespace.js
  var require_namespace = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _util = require_util();
      var _node = _interopRequireDefault(require_node2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Namespace = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Namespace2, _Node);
        function Namespace2() {
          return _Node.apply(this, arguments) || this;
        }
        var _proto = Namespace2.prototype;
        _proto.qualifiedName = function qualifiedName(value2) {
          if (this.namespace) {
            return this.namespaceString + "|" + value2;
          } else {
            return value2;
          }
        };
        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };
        _createClass(Namespace2, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            if (namespace === true || namespace === "*" || namespace === "&") {
              this._namespace = namespace;
              if (this.raws) {
                delete this.raws.namespace;
              }
              return;
            }
            var escaped = (0, _cssesc["default"])(namespace, {
              isIdentifier: true
            });
            this._namespace = namespace;
            if (escaped !== namespace) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          }
        }, {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            this.namespace = namespace;
          }
        }, {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");
              if (ns === true) {
                return "";
              } else {
                return ns;
              }
            } else {
              return "";
            }
          }
        }]);
        return Namespace2;
      }(_node["default"]);
      exports["default"] = Namespace;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/tag.js
  var require_tag = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Tag = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Tag2, _Namespace);
        function Tag2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.TAG;
          return _this;
        }
        return Tag2;
      }(_namespace["default"]);
      exports["default"] = Tag;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/string.js
  var require_string = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/string.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var String2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(String3, _Node);
        function String3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.STRING;
          return _this;
        }
        return String3;
      }(_node["default"]);
      exports["default"] = String2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/pseudo.js
  var require_pseudo = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Pseudo = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Pseudo2, _Container);
        function Pseudo2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.PSEUDO;
          return _this;
        }
        var _proto = Pseudo2.prototype;
        _proto.toString = function toString2() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
        };
        return Pseudo2;
      }(_container["default"]);
      exports["default"] = Pseudo;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports, module) {
      module.exports = deprecate;
      function deprecate(fn5, msg) {
        if (config("noDeprecation")) {
          return fn5;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn5.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!global.localStorage) return false;
        } catch (_2) {
          return false;
        }
        var val = global.localStorage[name];
        if (null == val) return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/attribute.js
  var require_attribute = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      exports.unescapeValue = unescapeValue;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _unesc = _interopRequireDefault(require_unesc());
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var deprecate = require_browser();
      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value2) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value2;
        var m2 = unescaped.match(WRAPPED_IN_QUOTES);
        if (m2) {
          quoteMark = m2[1];
          unescaped = m2[2];
        }
        unescaped = (0, _unesc["default"])(unescaped);
        if (unescaped !== value2) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options) {
          if (options === void 0) {
            options = {};
          }
          var quoteMark = this._determineQuoteMark(options);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options) {
          return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
        };
        _proto.setValue = function setValue(value2, options) {
          if (options === void 0) {
            options = {};
          }
          this._value = value2;
          this._quoteMark = this._determineQuoteMark(options);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options) {
          var v2 = this.value;
          var numSingleQuotes = v2.replace(/[^']/g, "").length;
          var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc["default"])(v2, {
              isIdentifier: true
            });
            if (escaped === v2) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options);
              if (pref === Attribute2.NO_QUOTE) {
                var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc["default"])(v2, opts);
                if (quoteValue.length < escaped.length) {
                  return quote;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options) {
          var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop, value2) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(value2, {
              isIdentifier: true
            });
            if (escaped !== value2) {
              this.raws[prop] = escaped;
            } else {
              delete this.raws[prop];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name, spaceName, concat) {
          if (spaceName === void 0) {
            spaceName = name;
          }
          if (concat === void 0) {
            concat = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat(this.stringifyProperty(name), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }
          if (name === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value2 = this.stringifyProperty("value");
          if (name === "value") {
            return value2 ? count : -1;
          }
          count += value2.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString2() {
          var _this2 = this;
          var selector = [this.rawSpaceBefore, "["];
          selector.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector.push(this._stringFor("operator"));
            selector.push(this._stringFor("value"));
            selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector.push("]");
          selector.push(this.rawSpaceAfter);
          return selector.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set(value2) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */
        }, {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          },
          set: function set(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: (
            /**
             * Before 3.0, the value had to be set to an escaped value including any wrapped
             * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
             * is unescaped during parsing and any quote marks are removed.
             *
             * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
             * a deprecation warning is raised when the new value contains any characters that would
             * require escaping (including if it contains wrapped quotes).
             *
             * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
             * how the new value is quoted.
             */
            function set(v2) {
              if (this._constructed) {
                var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
                if (deprecatedUsage) {
                  warnOfDeprecatedValueAssignment();
                }
                if (unescaped === this._value && quoteMark === this._quoteMark) {
                  return;
                }
                this._value = unescaped;
                this._quoteMark = quoteMark;
                this._syncRawValue();
              } else {
                this._value = v2;
              }
            }
          )
        }, {
          key: "insensitive",
          get: function get() {
            return this._insensitive;
          },
          set: function set(insensitive) {
            if (!insensitive) {
              this._insensitive = false;
              if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
                this.raws.insensitiveFlag = void 0;
              }
            }
            this._insensitive = insensitive;
          }
        }, {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set(name) {
            this._handleEscapes("attribute", name);
            this._attribute = name;
          }
        }]);
        return Attribute2;
      }(_namespace["default"]);
      exports["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/universal.js
  var require_universal = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Universal = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Universal2, _Namespace);
        function Universal2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.UNIVERSAL;
          _this.value = "*";
          return _this;
        }
        return Universal2;
      }(_namespace["default"]);
      exports["default"] = Universal;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/combinator.js
  var require_combinator = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Combinator = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Combinator2, _Node);
        function Combinator2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMBINATOR;
          return _this;
        }
        return Combinator2;
      }(_node["default"]);
      exports["default"] = Combinator;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/nesting.js
  var require_nesting = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p4) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p5) {
          o3.__proto__ = p5;
          return o3;
        };
        return _setPrototypeOf(o2, p4);
      }
      var Nesting = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Nesting2, _Node);
        function Nesting2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.NESTING;
          _this.value = "&";
          return _this;
        }
        return Nesting2;
      }(_node["default"]);
      exports["default"] = Nesting;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/sortAscending.js
  var require_sortAscending = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/sortAscending.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = sortAscending;
      function sortAscending(list3) {
        return list3.sort(function(a2, b2) {
          return a2 - b2;
        });
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/tokenTypes.js
  var require_tokenTypes = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.word = exports.tilde = exports.tab = exports.str = exports.space = exports.slash = exports.singleQuote = exports.semicolon = exports.plus = exports.pipe = exports.openSquare = exports.openParenthesis = exports.newline = exports.greaterThan = exports.feed = exports.equals = exports.doubleQuote = exports.dollar = exports.cr = exports.comment = exports.comma = exports.combinator = exports.colon = exports.closeSquare = exports.closeParenthesis = exports.caret = exports.bang = exports.backslash = exports.at = exports.asterisk = exports.ampersand = void 0;
      var ampersand = 38;
      exports.ampersand = ampersand;
      var asterisk = 42;
      exports.asterisk = asterisk;
      var at = 64;
      exports.at = at;
      var comma = 44;
      exports.comma = comma;
      var colon = 58;
      exports.colon = colon;
      var semicolon = 59;
      exports.semicolon = semicolon;
      var openParenthesis = 40;
      exports.openParenthesis = openParenthesis;
      var closeParenthesis = 41;
      exports.closeParenthesis = closeParenthesis;
      var openSquare = 91;
      exports.openSquare = openSquare;
      var closeSquare = 93;
      exports.closeSquare = closeSquare;
      var dollar = 36;
      exports.dollar = dollar;
      var tilde = 126;
      exports.tilde = tilde;
      var caret = 94;
      exports.caret = caret;
      var plus = 43;
      exports.plus = plus;
      var equals3 = 61;
      exports.equals = equals3;
      var pipe = 124;
      exports.pipe = pipe;
      var greaterThan = 62;
      exports.greaterThan = greaterThan;
      var space = 32;
      exports.space = space;
      var singleQuote = 39;
      exports.singleQuote = singleQuote;
      var doubleQuote = 34;
      exports.doubleQuote = doubleQuote;
      var slash = 47;
      exports.slash = slash;
      var bang = 33;
      exports.bang = bang;
      var backslash = 92;
      exports.backslash = backslash;
      var cr = 13;
      exports.cr = cr;
      var feed = 12;
      exports.feed = feed;
      var newline = 10;
      exports.newline = newline;
      var tab = 9;
      exports.tab = tab;
      var str = singleQuote;
      exports.str = str;
      var comment2 = -1;
      exports.comment = comment2;
      var word = -2;
      exports.word = word;
      var combinator = -3;
      exports.combinator = combinator;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/tokenize.js
  var require_tokenize2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/tokenize.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FIELDS = void 0;
      exports["default"] = tokenize2;
      var t2 = _interopRequireWildcard(require_tokenTypes());
      var _unescapable;
      var _wordDelimiters;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      var unescapable = (_unescapable = {}, _unescapable[t2.tab] = true, _unescapable[t2.newline] = true, _unescapable[t2.cr] = true, _unescapable[t2.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t2.space] = true, _wordDelimiters[t2.tab] = true, _wordDelimiters[t2.newline] = true, _wordDelimiters[t2.cr] = true, _wordDelimiters[t2.feed] = true, _wordDelimiters[t2.ampersand] = true, _wordDelimiters[t2.asterisk] = true, _wordDelimiters[t2.bang] = true, _wordDelimiters[t2.comma] = true, _wordDelimiters[t2.colon] = true, _wordDelimiters[t2.semicolon] = true, _wordDelimiters[t2.openParenthesis] = true, _wordDelimiters[t2.closeParenthesis] = true, _wordDelimiters[t2.openSquare] = true, _wordDelimiters[t2.closeSquare] = true, _wordDelimiters[t2.singleQuote] = true, _wordDelimiters[t2.doubleQuote] = true, _wordDelimiters[t2.plus] = true, _wordDelimiters[t2.pipe] = true, _wordDelimiters[t2.tilde] = true, _wordDelimiters[t2.greaterThan] = true, _wordDelimiters[t2.equals] = true, _wordDelimiters[t2.dollar] = true, _wordDelimiters[t2.caret] = true, _wordDelimiters[t2.slash] = true, _wordDelimiters);
      var hex2 = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (i2 = 0; i2 < hexChars.length; i2++) {
        hex2[hexChars.charCodeAt(i2)] = true;
      }
      var i2;
      function consumeWord(css, start) {
        var next = start;
        var code;
        do {
          code = css.charCodeAt(next);
          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t2.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            next++;
          }
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);
        if (unescapable[code]) {
        } else if (hex2[code]) {
          var hexDigits = 0;
          do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
          } while (hex2[code] && hexDigits < 6);
          if (hexDigits < 6 && code === t2.space) {
            next++;
          }
        } else {
          next++;
        }
        return next;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      exports.FIELDS = FIELDS;
      function tokenize2(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css, length2 = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
        function unclosed(what, fix) {
          if (input.safe) {
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error("Unclosed " + what, line, start - offset, start);
          }
        }
        while (start < length2) {
          code = css.charCodeAt(start);
          if (code === t2.newline) {
            offset = start;
            line += 1;
          }
          switch (code) {
            case t2.space:
            case t2.tab:
            case t2.newline:
            case t2.cr:
            case t2.feed:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
                if (code === t2.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code === t2.space || code === t2.newline || code === t2.tab || code === t2.cr || code === t2.feed);
              tokenType = t2.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;
            case t2.plus:
            case t2.greaterThan:
            case t2.tilde:
            case t2.pipe:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t2.plus || code === t2.greaterThan || code === t2.tilde || code === t2.pipe);
              tokenType = t2.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next;
              break;
            case t2.asterisk:
            case t2.ampersand:
            case t2.bang:
            case t2.comma:
            case t2.equals:
            case t2.dollar:
            case t2.caret:
            case t2.openSquare:
            case t2.closeSquare:
            case t2.colon:
            case t2.semicolon:
            case t2.openParenthesis:
            case t2.closeParenthesis:
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            case t2.singleQuote:
            case t2.doubleQuote:
              quote = code === t2.singleQuote ? "'" : '"';
              next = start;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  unclosed("quote", quote);
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === t2.backslash) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              tokenType = t2.str;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            default:
              if (code === t2.slash && css.charCodeAt(start + 1) === t2.asterisk) {
                next = css.indexOf("*/", start + 2) + 1;
                if (next === 0) {
                  unclosed("comment", "*/");
                }
                content = css.slice(start, next + 1);
                lines = content.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }
                tokenType = t2.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t2.slash) {
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t2.word;
                endLine = line;
                endColumn = next - offset;
              }
              end = next + 1;
              break;
          }
          tokens.push([
            tokenType,
            // [0] Token type
            line,
            // [1] Starting line
            start - offset,
            // [2] Starting column
            endLine,
            // [3] Ending line
            endColumn,
            // [4] Ending column
            start,
            // [5] Start position / Source index
            end
            // [6] End position
          ]);
          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }
          start = end;
        }
        return tokens;
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/parser.js
  var require_parser2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/parser.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _root = _interopRequireDefault(require_root2());
      var _selector = _interopRequireDefault(require_selector());
      var _className = _interopRequireDefault(require_className());
      var _comment = _interopRequireDefault(require_comment2());
      var _id = _interopRequireDefault(require_id());
      var _tag = _interopRequireDefault(require_tag());
      var _string = _interopRequireDefault(require_string());
      var _pseudo = _interopRequireDefault(require_pseudo());
      var _attribute = _interopRequireWildcard(require_attribute());
      var _universal = _interopRequireDefault(require_universal());
      var _combinator = _interopRequireDefault(require_combinator());
      var _nesting = _interopRequireDefault(require_nesting());
      var _sortAscending = _interopRequireDefault(require_sortAscending());
      var _tokenize = _interopRequireWildcard(require_tokenize2());
      var tokens = _interopRequireWildcard(require_tokenTypes());
      var types2 = _interopRequireWildcard(require_types());
      var _util = require_util();
      var _WHITESPACE_TOKENS;
      var _Object$assign;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return void 0;
        }
        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node, prop) {
        var value2 = node[prop];
        if (typeof value2 !== "string") {
          return;
        }
        if (value2.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node, "raws");
          node[prop] = (0, _util.unesc)(value2);
          if (node.raws[prop] === void 0) {
            node.raws[prop] = value2;
          }
        }
        return node;
      }
      function indexesOf(array, item) {
        var i2 = -1;
        var indexes = [];
        while ((i2 = array.indexOf(item, i2 + 1)) !== -1) {
          indexes.push(i2);
        }
        return indexes;
      }
      function uniqs() {
        var list3 = Array.prototype.concat.apply([], arguments);
        return list3.filter(function(item, i2) {
          return i2 === list3.indexOf(item);
        });
      }
      var Parser = /* @__PURE__ */ function() {
        function Parser2(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          this.rule = rule2;
          this.options = Object.assign({
            lossy: false,
            safe: false
          }, options);
          this.position = 0;
          this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root["default"]({
            source: rootSource
          });
          this.root.errorGenerator = this._errorGenerator();
          var selector = new _selector["default"]({
            source: {
              start: {
                line: 1,
                column: 1
              }
            },
            sourceIndex: 0
          });
          this.root.append(selector);
          this.current = selector;
          this.loop();
        }
        var _proto = Parser2.prototype;
        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;
          return function(message, errorOptions) {
            if (typeof _this.rule === "string") {
              return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
          };
        };
        _proto.attribute = function attribute() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;
          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          }
          var len = attr.length;
          var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
          }
          var pos = 0;
          var spaceBefore = "";
          var commentBefore = "";
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;
          while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];
            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                spaceAfterMeaningfulToken = true;
                if (this.options.lossy) {
                  break;
                }
                if (lastAdded) {
                  (0, _util.ensureObject)(node, "spaces", lastAdded);
                  var prevContent = node.spaces[lastAdded].after || "";
                  node.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                  if (existingComment) {
                    node.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }
                break;
              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "attribute");
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                    node.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = "";
                  }
                  node.namespace = (node.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                  if (rawValue) {
                    node.raws.namespace += content;
                  }
                  lastAdded = "namespace";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                  node.value += "$";
                  if (oldRawValue) {
                    node.raws.value = oldRawValue + "$";
                  }
                  break;
                }
              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.combinator:
                if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                }
                if (content !== "|") {
                  spaceAfterMeaningfulToken = false;
                  break;
                }
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                } else if (!node.namespace && !node.attribute) {
                  node.namespace = true;
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.word:
                if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node.operator && !node.namespace) {
                  node.namespace = content;
                  lastAdded = "namespace";
                } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "attribute");
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                    node.raws.spaces.attribute.before = commentBefore;
                    commentBefore = "";
                  }
                  node.attribute = (node.attribute || "") + content;
                  var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                  if (_rawValue) {
                    node.raws.attribute += content;
                  }
                  lastAdded = "attribute";
                } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
                  var _unescaped = (0, _util.unesc)(content);
                  var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                  var oldValue = node.value || "";
                  node.value = oldValue + _unescaped;
                  node.quoteMark = null;
                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.value = (_oldRawValue || oldValue) + content;
                  }
                  lastAdded = "value";
                } else {
                  var insensitive = content === "i" || content === "I";
                  if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                    node.insensitive = insensitive;
                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node, "raws");
                      node.raws.insensitiveFlag = content;
                    }
                    lastAdded = "insensitive";
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node, "spaces", "insensitive");
                      node.spaces.insensitive.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                      node.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = "";
                    }
                  } else if (node.value || node.value === "") {
                    lastAdded = "value";
                    node.value += content;
                    if (node.raws.value) {
                      node.raws.value += content;
                    }
                  }
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.str:
                if (!node.attribute || !node.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                node.value = unescaped;
                node.quoteMark = quoteMark;
                lastAdded = "value";
                (0, _util.ensureObject)(node, "raws");
                node.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.equals:
                if (!node.attribute) {
                  return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
                }
                if (node.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                node.operator = node.operator ? node.operator + content : content;
                lastAdded = "operator";
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                    var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                    var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                    (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                    node.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node[lastAdded] || "";
                    var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                    (0, _util.ensureObject)(node, "raws");
                    node.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }
                break;
              default:
                return this.error('Unexpected "' + content + '" found.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
            }
            pos++;
          }
          unescapeProp(node, "attribute");
          unescapeProp(node, "namespace");
          this.newNode(new _attribute["default"](node));
          this.position++;
        };
        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }
          var startPosition = this.position;
          var nodes = [];
          var space = "";
          var lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};
              if (space) {
                spaces.before = space;
                space = "";
              }
              lastComment = new _comment["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces
              });
              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space) {
            if (lastComment) {
              lastComment.spaces.after = space;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string["default"]({
                value: "",
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space,
                  after: ""
                }
              }));
            }
          }
          return nodes;
        };
        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;
          if (requiredSpace === void 0) {
            requiredSpace = false;
          }
          var space = "";
          var rawSpace = "";
          nodes.forEach(function(n2) {
            var spaceBefore = _this2.lossySpace(n2.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n2.rawSpaceBefore, requiredSpace);
            space += spaceBefore + _this2.lossySpace(n2.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n2.value + _this2.lossySpace(n2.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });
          if (rawSpace === space) {
            rawSpace = void 0;
          }
          var result = {
            space,
            rawSpace
          };
          return result;
        };
        _proto.isNamedCombinator = function isNamedCombinator(position2) {
          if (position2 === void 0) {
            position2 = this.position;
          }
          return this.tokens[position2 + 0] && this.tokens[position2 + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position2 + 1] && this.tokens[position2 + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position2 + 2] && this.tokens[position2 + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };
        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }
            var node = new _combinator["default"]({
              value: "/" + name + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            this.position = this.position + 3;
            return node;
          } else {
            this.unexpected();
          }
        };
        _proto.combinator = function combinator() {
          var _this3 = this;
          if (this.content() === "|") {
            return this.namespace();
          }
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
              var last = this.current.last;
              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                if (rawSpace !== void 0) {
                  last.rawSpaceAfter += rawSpace;
                }
                last.spaces.after += space;
              } else {
                nodes.forEach(function(n2) {
                  return _this3.newNode(n2);
                });
              }
            }
            return;
          }
          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = void 0;
          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }
          var node;
          if (this.isNamedCombinator()) {
            node = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node = new _combinator["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
          } else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }
          if (node) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
              node.spaces.before = _space;
              node.rawSpaceBefore = _rawSpace;
            }
          } else {
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }
            var spaces = {};
            var raws = {
              spaces: {}
            };
            if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }
            node = new _combinator["default"]({
              value: " ",
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces,
              raws
            });
          }
          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }
          return this.newNode(node);
        };
        _proto.comma = function comma() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }
          this.current._inferEndPosition();
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            },
            sourceIndex: this.tokens[this.position + 1][_tokenize.FIELDS.START_POS]
          });
          this.current.parent.append(selector);
          this.current = selector;
          this.position++;
        };
        _proto.comment = function comment2() {
          var current = this.currToken;
          this.newNode(new _comment["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.error = function error(message, opts) {
          throw this.root.error(message, opts);
        };
        _proto.missingBackslash = function missingBackslash() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        };
        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpectedPipe = function unexpectedPipe() {
          return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.namespace = function namespace() {
          var before = this.prevToken && this.content(this.prevToken) || true;
          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
          this.unexpectedPipe();
        };
        _proto.nesting = function nesting() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
              this.position++;
              return;
            }
          }
          var current = this.currToken;
          this.newNode(new _nesting["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;
          if (last && last.type === types2.PSEUDO) {
            var selector = new _selector["default"]({
              source: {
                start: tokenStart(this.tokens[this.position])
              },
              sourceIndex: this.tokens[this.position][_tokenize.FIELDS.START_POS]
            });
            var cache3 = this.current;
            last.append(selector);
            this.current = selector;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }
            this.current = cache3;
          } else {
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }
            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string["default"]({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
              }));
            }
          }
          if (unbalanced) {
            return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.pseudo = function pseudo() {
          var _this4 = this;
          var pseudoStr = "";
          var startingToken = this.currToken;
          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }
          if (!this.currToken) {
            return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function(first, length2) {
              pseudoStr += first;
              _this4.newNode(new _pseudo["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
              }));
              if (length2 > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error("Misplaced parenthesis.", {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                });
              }
            });
          } else {
            return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.space = function space() {
          var content = this.content();
          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
            return node.type === "comment";
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };
        _proto.string = function string() {
          var current = this.currToken;
          this.newNode(new _string["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.universal = function universal(namespace) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          var current = this.currToken;
          this.newNode(new _universal["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace);
          this.position++;
        };
        _proto.splitWord = function splitWord(namespace, firstCallback) {
          var _this5 = this;
          var nextToken = this.nextToken;
          var word = this.content();
          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word += current;
            if (current.lastIndexOf("\\") === current.length - 1) {
              var next = this.nextToken;
              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word += this.requiredSpace(this.content(next));
                this.position++;
              }
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word, ".").filter(function(i2) {
            var escapedDot = word[i2 - 1] === "\\";
            var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word, "#").filter(function(i2) {
            return word[i2 - 1] !== "\\";
          });
          var interpolations = indexesOf(word, "#{");
          if (interpolations.length) {
            hasId = hasId.filter(function(hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }
          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function(ind, i2) {
            var index2 = indices[i2 + 1] || word.length;
            var value2 = word.slice(ind, index2);
            if (i2 === 0 && firstCallback) {
              return firstCallback.call(_this5, value2, indices.length);
            }
            var node;
            var current2 = _this5.currToken;
            var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i2];
            var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index2 - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node = new _className["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node = new _id["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value2,
                source,
                sourceIndex
              };
              unescapeProp(tagOpts, "value");
              node = new _tag["default"](tagOpts);
            }
            _this5.newNode(node, namespace);
            namespace = null;
          });
          this.position++;
        };
        _proto.word = function word(namespace) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          return this.splitWord(namespace);
        };
        _proto.loop = function loop() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }
          this.current._inferEndPosition();
          return this.root;
        };
        _proto.parse = function parse5(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;
            case tokens.comment:
              this.comment();
              break;
            case tokens.openParenthesis:
              this.parentheses();
              break;
            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }
              break;
            case tokens.openSquare:
              this.attribute();
              break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;
            case tokens.colon:
              this.pseudo();
              break;
            case tokens.comma:
              this.comma();
              break;
            case tokens.asterisk:
              this.universal();
              break;
            case tokens.ampersand:
              this.nesting();
              break;
            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;
            case tokens.str:
              this.string();
              break;
            case tokens.closeSquare:
              this.missingSquareBracket();
            case tokens.semicolon:
              this.missingBackslash();
            default:
              this.unexpected();
          }
        };
        _proto.expected = function expected(description, index2, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(", ") + " or " + last;
          }
          var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
          if (!found) {
            return this.error("Expected " + an + " " + description + ".", {
              index: index2
            });
          }
          return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
            index: index2
          });
        };
        _proto.requiredSpace = function requiredSpace(space) {
          return this.options.lossy ? " " : space;
        };
        _proto.optionalSpace = function optionalSpace(space) {
          return this.options.lossy ? "" : space;
        };
        _proto.lossySpace = function lossySpace(space, required) {
          if (this.options.lossy) {
            return required ? " " : "";
          } else {
            return space;
          }
        };
        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);
          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };
        _proto.newNode = function newNode(node, namespace) {
          if (namespace) {
            if (/^ +$/.test(namespace)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || "") + namespace;
              }
              namespace = true;
            }
            node.namespace = namespace;
            unescapeProp(node, "namespace");
          }
          if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = "";
          }
          return this.current.append(node);
        };
        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }
          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }
          var searchPosition = startPosition;
          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }
          return -1;
        };
        _createClass(Parser2, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          }
        }]);
        return Parser2;
      }();
      exports["default"] = Parser;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/processor.js
  var require_processor2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/processor.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _parser = _interopRequireDefault(require_parser2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var Processor2 = /* @__PURE__ */ function() {
        function Processor3(func, options) {
          this.func = func || function noop2() {
          };
          this.funcRes = null;
          this.options = options;
        }
        var _proto = Processor3.prototype;
        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var merged = Object.assign({}, this.options, options);
          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule2 !== "string";
          }
        };
        _proto._isLossy = function _isLossy(options) {
          if (options === void 0) {
            options = {};
          }
          var merged = Object.assign({}, this.options, options);
          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };
        _proto._root = function _root(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var parser5 = new _parser["default"](rule2, this._parseOptions(options));
          return parser5.root;
        };
        _proto._parseOptions = function _parseOptions(options) {
          return {
            lossy: this._isLossy(options)
          };
        };
        _proto._run = function _run(rule2, options) {
          var _this = this;
          if (options === void 0) {
            options = {};
          }
          return new Promise(function(resolve2, reject) {
            try {
              var root2 = _this._root(rule2, options);
              Promise.resolve(_this.func(root2)).then(function(transform) {
                var string = void 0;
                if (_this._shouldUpdateSelector(rule2, options)) {
                  string = root2.toString();
                  rule2.selector = string;
                }
                return {
                  transform,
                  root: root2,
                  string
                };
              }).then(resolve2, reject);
            } catch (e5) {
              reject(e5);
              return;
            }
          });
        };
        _proto._runSync = function _runSync(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var root2 = this._root(rule2, options);
          var transform = this.func(root2);
          if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }
          var string = void 0;
          if (options.updateSelector && typeof rule2 !== "string") {
            string = root2.toString();
            rule2.selector = string;
          }
          return {
            transform,
            root: root2,
            string
          };
        };
        _proto.ast = function ast(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.root;
          });
        };
        _proto.astSync = function astSync(rule2, options) {
          return this._runSync(rule2, options).root;
        };
        _proto.transform = function transform(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.transform;
          });
        };
        _proto.transformSync = function transformSync(rule2, options) {
          return this._runSync(rule2, options).transform;
        };
        _proto.process = function process2(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.string || result.root.toString();
          });
        };
        _proto.processSync = function processSync(rule2, options) {
          var result = this._runSync(rule2, options);
          return result.string || result.root.toString();
        };
        return Processor3;
      }();
      exports["default"] = Processor2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/constructors.js
  var require_constructors = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
      var _attribute = _interopRequireDefault(require_attribute());
      var _className = _interopRequireDefault(require_className());
      var _combinator = _interopRequireDefault(require_combinator());
      var _comment = _interopRequireDefault(require_comment2());
      var _id = _interopRequireDefault(require_id());
      var _nesting = _interopRequireDefault(require_nesting());
      var _pseudo = _interopRequireDefault(require_pseudo());
      var _root = _interopRequireDefault(require_root2());
      var _selector = _interopRequireDefault(require_selector());
      var _string = _interopRequireDefault(require_string());
      var _tag = _interopRequireDefault(require_tag());
      var _universal = _interopRequireDefault(require_universal());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var attribute = function attribute2(opts) {
        return new _attribute["default"](opts);
      };
      exports.attribute = attribute;
      var className = function className2(opts) {
        return new _className["default"](opts);
      };
      exports.className = className;
      var combinator = function combinator2(opts) {
        return new _combinator["default"](opts);
      };
      exports.combinator = combinator;
      var comment2 = function comment3(opts) {
        return new _comment["default"](opts);
      };
      exports.comment = comment2;
      var id = function id2(opts) {
        return new _id["default"](opts);
      };
      exports.id = id;
      var nesting = function nesting2(opts) {
        return new _nesting["default"](opts);
      };
      exports.nesting = nesting;
      var pseudo = function pseudo2(opts) {
        return new _pseudo["default"](opts);
      };
      exports.pseudo = pseudo;
      var root2 = function root3(opts) {
        return new _root["default"](opts);
      };
      exports.root = root2;
      var selector = function selector2(opts) {
        return new _selector["default"](opts);
      };
      exports.selector = selector;
      var string = function string2(opts) {
        return new _string["default"](opts);
      };
      exports.string = string;
      var tag = function tag2(opts) {
        return new _tag["default"](opts);
      };
      exports.tag = tag;
      var universal = function universal2(opts) {
        return new _universal["default"](opts);
      };
      exports.universal = universal;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/guards.js
  var require_guards = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
      exports.isContainer = isContainer;
      exports.isIdentifier = void 0;
      exports.isNamespace = isNamespace;
      exports.isNesting = void 0;
      exports.isNode = isNode;
      exports.isPseudo = void 0;
      exports.isPseudoClass = isPseudoClass;
      exports.isPseudoElement = isPseudoElement2;
      exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = void 0;
      var _types = require_types();
      var _IS_TYPE;
      var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
      function isNode(node) {
        return typeof node === "object" && IS_TYPE[node.type];
      }
      function isNodeType(type, node) {
        return isNode(node) && node.type === type;
      }
      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      exports.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      exports.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      exports.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      exports.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      exports.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      exports.isNesting = isNesting;
      var isPseudo2 = isNodeType.bind(null, _types.PSEUDO);
      exports.isPseudo = isPseudo2;
      var isRoot2 = isNodeType.bind(null, _types.ROOT);
      exports.isRoot = isRoot2;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      exports.isSelector = isSelector;
      var isString2 = isNodeType.bind(null, _types.STRING);
      exports.isString = isString2;
      var isTag = isNodeType.bind(null, _types.TAG);
      exports.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      exports.isUniversal = isUniversal;
      function isPseudoElement2(node) {
        return isPseudo2(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
      }
      function isPseudoClass(node) {
        return isPseudo2(node) && !isPseudoElement2(node);
      }
      function isContainer(node) {
        return !!(isNode(node) && node.walk);
      }
      function isNamespace(node) {
        return isAttribute(node) || isTag(node);
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/index.js
  var require_selectors = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/selectors/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _types = require_types();
      Object.keys(_types).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _types[key]) return;
        exports[key] = _types[key];
      });
      var _constructors = require_constructors();
      Object.keys(_constructors).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _constructors[key]) return;
        exports[key] = _constructors[key];
      });
      var _guards = require_guards();
      Object.keys(_guards).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _guards[key]) return;
        exports[key] = _guards[key];
      });
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/index.js
  var require_dist = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.1.2/node_modules/postcss-selector-parser/dist/index.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _processor = _interopRequireDefault(require_processor2());
      var selectors = _interopRequireWildcard(require_selectors());
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var parser5 = function parser6(processor) {
        return new _processor["default"](processor);
      };
      Object.assign(parser5, selectors);
      delete parser5.__esModule;
      var _default = parser5;
      exports["default"] = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-nested@6.2.0_postcss@8.4.47/node_modules/postcss-nested/index.js
  var require_postcss_nested = __commonJS({
    "node_modules/.pnpm/postcss-nested@6.2.0_postcss@8.4.47/node_modules/postcss-nested/index.js"(exports, module) {
      var { AtRule: AtRule2, Rule: Rule2 } = require_postcss();
      var parser5 = require_dist();
      function parse5(rawSelector, rule2) {
        let nodes;
        try {
          parser5((parsed) => {
            nodes = parsed;
          }).processSync(rawSelector);
        } catch (e5) {
          if (rawSelector.includes(":")) {
            throw rule2 ? rule2.error("Missed semicolon") : e5;
          } else {
            throw rule2 ? rule2.error(e5.message) : e5;
          }
        }
        return nodes.at(0);
      }
      function interpolateAmpInSelector(nodes, parent) {
        let replaced = false;
        nodes.each((node) => {
          if (node.type === "nesting") {
            let clonedParent = parent.clone({});
            if (node.value !== "&") {
              node.replaceWith(
                parse5(node.value.replace("&", clonedParent.toString()))
              );
            } else {
              node.replaceWith(clonedParent);
            }
            replaced = true;
          } else if ("nodes" in node && node.nodes) {
            if (interpolateAmpInSelector(node, parent)) {
              replaced = true;
            }
          }
        });
        return replaced;
      }
      function mergeSelectors(parent, child) {
        let merged = [];
        parent.selectors.forEach((sel) => {
          let parentNode = parse5(sel, parent);
          child.selectors.forEach((selector) => {
            if (!selector) {
              return;
            }
            let node = parse5(selector, child);
            let replaced = interpolateAmpInSelector(node, parentNode);
            if (!replaced) {
              node.prepend(parser5.combinator({ value: " " }));
              node.prepend(parentNode.clone({}));
            }
            merged.push(node.toString());
          });
        });
        return merged;
      }
      function breakOut(child, after) {
        let prev = child.prev();
        after.after(child);
        while (prev && prev.type === "comment") {
          let nextPrev = prev.prev();
          after.after(prev);
          prev = nextPrev;
        }
        return child;
      }
      function createFnAtruleChilds(bubble) {
        return function atruleChilds(rule2, atrule, bubbling, mergeSels = bubbling) {
          let children = [];
          atrule.each((child) => {
            if (child.type === "rule" && bubbling) {
              if (mergeSels) {
                child.selectors = mergeSelectors(rule2, child);
              }
            } else if (child.type === "atrule" && child.nodes) {
              if (bubble[child.name]) {
                atruleChilds(rule2, child, mergeSels);
              } else if (atrule[rootRuleMergeSel] !== false) {
                children.push(child);
              }
            } else {
              children.push(child);
            }
          });
          if (bubbling) {
            if (children.length) {
              let clone = rule2.clone({ nodes: [] });
              for (let child of children) {
                clone.append(child);
              }
              atrule.prepend(clone);
            }
          }
        };
      }
      function pickDeclarations(selector, declarations, after) {
        let parent = new Rule2({
          nodes: [],
          selector
        });
        parent.append(declarations);
        after.after(parent);
        return parent;
      }
      function atruleNames(defaults3, custom) {
        let list3 = {};
        for (let name of defaults3) {
          list3[name] = true;
        }
        if (custom) {
          for (let name of custom) {
            list3[name.replace(/^@/, "")] = true;
          }
        }
        return list3;
      }
      function parseRootRuleParams(params) {
        params = params.trim();
        let braceBlock = params.match(/^\((.*)\)$/);
        if (!braceBlock) {
          return { selector: params, type: "basic" };
        }
        let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/);
        if (bits) {
          let allowlist = bits[1] === "with";
          let rules = Object.fromEntries(
            bits[2].trim().split(/\s+/).map((name) => [name, true])
          );
          if (allowlist && rules.all) {
            return { type: "noop" };
          }
          let escapes = (rule2) => !!rules[rule2];
          if (rules.all) {
            escapes = () => true;
          } else if (allowlist) {
            escapes = (rule2) => rule2 === "all" ? false : !rules[rule2];
          }
          return {
            escapes,
            type: "withrules"
          };
        }
        return { type: "unknown" };
      }
      function getAncestorRules(leaf) {
        let lineage = [];
        let parent = leaf.parent;
        while (parent && parent instanceof AtRule2) {
          lineage.push(parent);
          parent = parent.parent;
        }
        return lineage;
      }
      function unwrapRootRule(rule2) {
        let escapes = rule2[rootRuleEscapes];
        if (!escapes) {
          rule2.after(rule2.nodes);
        } else {
          let nodes = rule2.nodes;
          let topEscaped;
          let topEscapedIdx = -1;
          let breakoutLeaf;
          let breakoutRoot;
          let clone;
          let lineage = getAncestorRules(rule2);
          lineage.forEach((parent, i2) => {
            if (escapes(parent.name)) {
              topEscaped = parent;
              topEscapedIdx = i2;
              breakoutRoot = clone;
            } else {
              let oldClone = clone;
              clone = parent.clone({ nodes: [] });
              oldClone && clone.append(oldClone);
              breakoutLeaf = breakoutLeaf || clone;
            }
          });
          if (!topEscaped) {
            rule2.after(nodes);
          } else if (!breakoutRoot) {
            topEscaped.after(nodes);
          } else {
            let leaf = breakoutLeaf;
            leaf.append(nodes);
            topEscaped.after(breakoutRoot);
          }
          if (rule2.next() && topEscaped) {
            let restRoot;
            lineage.slice(0, topEscapedIdx + 1).forEach((parent, i2, arr) => {
              let oldRoot = restRoot;
              restRoot = parent.clone({ nodes: [] });
              oldRoot && restRoot.append(oldRoot);
              let nextSibs = [];
              let _child = arr[i2 - 1] || rule2;
              let next = _child.next();
              while (next) {
                nextSibs.push(next);
                next = next.next();
              }
              restRoot.append(nextSibs);
            });
            restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot);
          }
        }
        rule2.remove();
      }
      var rootRuleMergeSel = Symbol("rootRuleMergeSel");
      var rootRuleEscapes = Symbol("rootRuleEscapes");
      function normalizeRootRule(rule2) {
        let { params } = rule2;
        let { escapes, selector, type } = parseRootRuleParams(params);
        if (type === "unknown") {
          throw rule2.error(
            `Unknown @${rule2.name} parameter ${JSON.stringify(params)}`
          );
        }
        if (type === "basic" && selector) {
          let selectorBlock = new Rule2({ nodes: rule2.nodes, selector });
          rule2.removeAll();
          rule2.append(selectorBlock);
        }
        rule2[rootRuleEscapes] = escapes;
        rule2[rootRuleMergeSel] = escapes ? !escapes("all") : type === "noop";
      }
      var hasRootRule = Symbol("hasRootRule");
      module.exports = (opts = {}) => {
        let bubble = atruleNames(
          ["media", "supports", "layer", "container", "starting-style"],
          opts.bubble
        );
        let atruleChilds = createFnAtruleChilds(bubble);
        let unwrap = atruleNames(
          [
            "document",
            "font-face",
            "keyframes",
            "-webkit-keyframes",
            "-moz-keyframes"
          ],
          opts.unwrap
        );
        let rootRuleName = (opts.rootRuleName || "at-root").replace(/^@/, "");
        let preserveEmpty = opts.preserveEmpty;
        return {
          Once(root2) {
            root2.walkAtRules(rootRuleName, (node) => {
              normalizeRootRule(node);
              root2[hasRootRule] = true;
            });
          },
          postcssPlugin: "postcss-nested",
          RootExit(root2) {
            if (root2[hasRootRule]) {
              root2.walkAtRules(rootRuleName, unwrapRootRule);
              root2[hasRootRule] = false;
            }
          },
          Rule(rule2) {
            let unwrapped = false;
            let after = rule2;
            let copyDeclarations = false;
            let declarations = [];
            rule2.each((child) => {
              if (child.type === "rule") {
                if (declarations.length) {
                  after = pickDeclarations(rule2.selector, declarations, after);
                  declarations = [];
                }
                copyDeclarations = true;
                unwrapped = true;
                child.selectors = mergeSelectors(rule2, child);
                after = breakOut(child, after);
              } else if (child.type === "atrule") {
                if (declarations.length) {
                  after = pickDeclarations(rule2.selector, declarations, after);
                  declarations = [];
                }
                if (child.name === rootRuleName) {
                  unwrapped = true;
                  atruleChilds(rule2, child, true, child[rootRuleMergeSel]);
                  after = breakOut(child, after);
                } else if (bubble[child.name]) {
                  copyDeclarations = true;
                  unwrapped = true;
                  atruleChilds(rule2, child, true);
                  after = breakOut(child, after);
                } else if (unwrap[child.name]) {
                  copyDeclarations = true;
                  unwrapped = true;
                  atruleChilds(rule2, child, false);
                  after = breakOut(child, after);
                } else if (copyDeclarations) {
                  declarations.push(child);
                }
              } else if (child.type === "decl" && copyDeclarations) {
                declarations.push(child);
              }
            });
            if (declarations.length) {
              after = pickDeclarations(rule2.selector, declarations, after);
            }
            if (unwrapped && preserveEmpty !== true) {
              rule2.raws.semicolon = true;
              if (rule2.nodes.length === 0) rule2.remove();
            }
          }
        };
      };
      module.exports.postcss = true;
    }
  });

  // node_modules/.pnpm/camelcase-css@2.0.1/node_modules/camelcase-css/index-es5.js
  var require_index_es5 = __commonJS({
    "node_modules/.pnpm/camelcase-css@2.0.1/node_modules/camelcase-css/index-es5.js"(exports, module) {
      "use strict";
      var pattern2 = /-(\w|$)/g;
      var callback = function callback2(dashChar, char) {
        return char.toUpperCase();
      };
      var camelCaseCSS = function camelCaseCSS2(property) {
        property = property.toLowerCase();
        if (property === "float") {
          return "cssFloat";
        } else if (property.charCodeAt(0) === 45 && property.charCodeAt(1) === 109 && property.charCodeAt(2) === 115 && property.charCodeAt(3) === 45) {
          return property.substr(1).replace(pattern2, callback);
        } else {
          return property.replace(pattern2, callback);
        }
      };
      module.exports = camelCaseCSS;
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/objectifier.js
  var require_objectifier = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/objectifier.js"(exports, module) {
      var camelcase = require_index_es5();
      var UNITLESS = {
        boxFlex: true,
        boxFlexGroup: true,
        columnCount: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        strokeDashoffset: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function atRule3(node) {
        if (typeof node.nodes === "undefined") {
          return true;
        } else {
          return process2(node);
        }
      }
      function process2(node) {
        let name;
        let result = {};
        node.each((child) => {
          if (child.type === "atrule") {
            name = "@" + child.name;
            if (child.params) name += " " + child.params;
            if (typeof result[name] === "undefined") {
              result[name] = atRule3(child);
            } else if (Array.isArray(result[name])) {
              result[name].push(atRule3(child));
            } else {
              result[name] = [result[name], atRule3(child)];
            }
          } else if (child.type === "rule") {
            let body = process2(child);
            if (result[child.selector]) {
              for (let i2 in body) {
                result[child.selector][i2] = body[i2];
              }
            } else {
              result[child.selector] = body;
            }
          } else if (child.type === "decl") {
            if (child.prop[0] === "-" && child.prop[1] === "-") {
              name = child.prop;
            } else if (child.parent && child.parent.selector === ":export") {
              name = child.prop;
            } else {
              name = camelcase(child.prop);
            }
            let value2 = child.value;
            if (!isNaN(child.value) && UNITLESS[name]) {
              value2 = parseFloat(child.value);
            }
            if (child.important) value2 += " !important";
            if (typeof result[name] === "undefined") {
              result[name] = value2;
            } else if (Array.isArray(result[name])) {
              result[name].push(value2);
            } else {
              result[name] = [result[name], value2];
            }
          }
        });
        return result;
      }
      module.exports = process2;
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/parser.js
  var require_parser3 = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/parser.js"(exports, module) {
      var postcss2 = require_postcss();
      var IMPORTANT2 = /\s*!important\s*$/i;
      var UNITLESS = {
        "box-flex": true,
        "box-flex-group": true,
        "column-count": true,
        "flex": true,
        "flex-grow": true,
        "flex-positive": true,
        "flex-shrink": true,
        "flex-negative": true,
        "font-weight": true,
        "line-clamp": true,
        "line-height": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "tab-size": true,
        "widows": true,
        "z-index": true,
        "zoom": true,
        "fill-opacity": true,
        "stroke-dashoffset": true,
        "stroke-opacity": true,
        "stroke-width": true
      };
      function dashify2(str) {
        return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
      }
      function decl3(parent, name, value2) {
        if (value2 === false || value2 === null) return;
        if (!name.startsWith("--")) {
          name = dashify2(name);
        }
        if (typeof value2 === "number") {
          if (value2 === 0 || UNITLESS[name]) {
            value2 = value2.toString();
          } else {
            value2 += "px";
          }
        }
        if (name === "css-float") name = "float";
        if (IMPORTANT2.test(value2)) {
          value2 = value2.replace(IMPORTANT2, "");
          parent.push(postcss2.decl({ prop: name, value: value2, important: true }));
        } else {
          parent.push(postcss2.decl({ prop: name, value: value2 }));
        }
      }
      function atRule3(parent, parts, value2) {
        let node = postcss2.atRule({ name: parts[1], params: parts[3] || "" });
        if (typeof value2 === "object") {
          node.nodes = [];
          parse5(value2, node);
        }
        parent.push(node);
      }
      function parse5(obj, parent) {
        let name, value2, node;
        for (name in obj) {
          value2 = obj[name];
          if (value2 === null || typeof value2 === "undefined") {
            continue;
          } else if (name[0] === "@") {
            let parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
            if (Array.isArray(value2)) {
              for (let i2 of value2) {
                atRule3(parent, parts, i2);
              }
            } else {
              atRule3(parent, parts, value2);
            }
          } else if (Array.isArray(value2)) {
            for (let i2 of value2) {
              decl3(parent, name, i2);
            }
          } else if (typeof value2 === "object") {
            node = postcss2.rule({ selector: name });
            parse5(value2, node);
            parent.push(node);
          } else {
            decl3(parent, name, value2);
          }
        }
      }
      module.exports = function(obj) {
        let root2 = postcss2.root();
        parse5(obj, root2);
        return root2;
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/process-result.js
  var require_process_result = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/process-result.js"(exports, module) {
      var objectify2 = require_objectifier();
      module.exports = function processResult(result) {
        if (console && console.warn) {
          result.warnings().forEach((warn2) => {
            let source = warn2.plugin || "PostCSS";
            console.warn(source + ": " + warn2.text);
          });
        }
        return objectify2(result.root);
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/async.js
  var require_async = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/async.js"(exports, module) {
      var postcss2 = require_postcss();
      var processResult = require_process_result();
      var parse5 = require_parser3();
      module.exports = function async2(plugins) {
        let processor = postcss2(plugins);
        return async (input) => {
          let result = await processor.process(input, {
            parser: parse5,
            from: void 0
          });
          return processResult(result);
        };
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/sync.js
  var require_sync = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/sync.js"(exports, module) {
      var postcss2 = require_postcss();
      var processResult = require_process_result();
      var parse5 = require_parser3();
      module.exports = function(plugins) {
        let processor = postcss2(plugins);
        return (input) => {
          let result = processor.process(input, { parser: parse5, from: void 0 });
          return processResult(result);
        };
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/index.js
  var require_postcss_js = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/index.js"(exports, module) {
      var objectify2 = require_objectifier();
      var parse5 = require_parser3();
      var async2 = require_async();
      var sync2 = require_sync();
      module.exports = {
        objectify: objectify2,
        parse: parse5,
        async: async2,
        sync: sync2
      };
    }
  });

  // node_modules/.pnpm/@alloc+quick-lru@5.2.0/node_modules/@alloc/quick-lru/index.js
  var require_quick_lru = __commonJS({
    "node_modules/.pnpm/@alloc+quick-lru@5.2.0/node_modules/@alloc/quick-lru/index.js"(exports, module) {
      "use strict";
      var QuickLRU = class {
        constructor(options = {}) {
          if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError("`maxSize` must be a number greater than 0");
          }
          if (typeof options.maxAge === "number" && options.maxAge === 0) {
            throw new TypeError("`maxAge` must be a number greater than 0");
          }
          this.maxSize = options.maxSize;
          this.maxAge = options.maxAge || Infinity;
          this.onEviction = options.onEviction;
          this.cache = /* @__PURE__ */ new Map();
          this.oldCache = /* @__PURE__ */ new Map();
          this._size = 0;
        }
        _emitEvictions(cache3) {
          if (typeof this.onEviction !== "function") {
            return;
          }
          for (const [key, item] of cache3) {
            this.onEviction(key, item.value);
          }
        }
        _deleteIfExpired(key, item) {
          if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
            if (typeof this.onEviction === "function") {
              this.onEviction(key, item.value);
            }
            return this.delete(key);
          }
          return false;
        }
        _getOrDeleteIfExpired(key, item) {
          const deleted = this._deleteIfExpired(key, item);
          if (deleted === false) {
            return item.value;
          }
        }
        _getItemValue(key, item) {
          return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
        }
        _peek(key, cache3) {
          const item = cache3.get(key);
          return this._getItemValue(key, item);
        }
        _set(key, value2) {
          this.cache.set(key, value2);
          this._size++;
          if (this._size >= this.maxSize) {
            this._size = 0;
            this._emitEvictions(this.oldCache);
            this.oldCache = this.cache;
            this.cache = /* @__PURE__ */ new Map();
          }
        }
        _moveToRecent(key, item) {
          this.oldCache.delete(key);
          this._set(key, item);
        }
        *_entriesAscending() {
          for (const item of this.oldCache) {
            const [key, value2] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value2);
              if (deleted === false) {
                yield item;
              }
            }
          }
          for (const item of this.cache) {
            const [key, value2] = item;
            const deleted = this._deleteIfExpired(key, value2);
            if (deleted === false) {
              yield item;
            }
          }
        }
        get(key) {
          if (this.cache.has(key)) {
            const item = this.cache.get(key);
            return this._getItemValue(key, item);
          }
          if (this.oldCache.has(key)) {
            const item = this.oldCache.get(key);
            if (this._deleteIfExpired(key, item) === false) {
              this._moveToRecent(key, item);
              return item.value;
            }
          }
        }
        set(key, value2, { maxAge = this.maxAge === Infinity ? void 0 : Date.now() + this.maxAge } = {}) {
          if (this.cache.has(key)) {
            this.cache.set(key, {
              value: value2,
              maxAge
            });
          } else {
            this._set(key, { value: value2, expiry: maxAge });
          }
        }
        has(key) {
          if (this.cache.has(key)) {
            return !this._deleteIfExpired(key, this.cache.get(key));
          }
          if (this.oldCache.has(key)) {
            return !this._deleteIfExpired(key, this.oldCache.get(key));
          }
          return false;
        }
        peek(key) {
          if (this.cache.has(key)) {
            return this._peek(key, this.cache);
          }
          if (this.oldCache.has(key)) {
            return this._peek(key, this.oldCache);
          }
        }
        delete(key) {
          const deleted = this.cache.delete(key);
          if (deleted) {
            this._size--;
          }
          return this.oldCache.delete(key) || deleted;
        }
        clear() {
          this.cache.clear();
          this.oldCache.clear();
          this._size = 0;
        }
        resize(newSize) {
          if (!(newSize && newSize > 0)) {
            throw new TypeError("`maxSize` must be a number greater than 0");
          }
          const items = [...this._entriesAscending()];
          const removeCount = items.length - newSize;
          if (removeCount < 0) {
            this.cache = new Map(items);
            this.oldCache = /* @__PURE__ */ new Map();
            this._size = items.length;
          } else {
            if (removeCount > 0) {
              this._emitEvictions(items.slice(0, removeCount));
            }
            this.oldCache = new Map(items.slice(removeCount));
            this.cache = /* @__PURE__ */ new Map();
            this._size = 0;
          }
          this.maxSize = newSize;
        }
        *keys() {
          for (const [key] of this) {
            yield key;
          }
        }
        *values() {
          for (const [, value2] of this) {
            yield value2;
          }
        }
        *[Symbol.iterator]() {
          for (const item of this.cache) {
            const [key, value2] = item;
            const deleted = this._deleteIfExpired(key, value2);
            if (deleted === false) {
              yield [key, value2.value];
            }
          }
          for (const item of this.oldCache) {
            const [key, value2] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value2);
              if (deleted === false) {
                yield [key, value2.value];
              }
            }
          }
        }
        *entriesDescending() {
          let items = [...this.cache];
          for (let i2 = items.length - 1; i2 >= 0; --i2) {
            const item = items[i2];
            const [key, value2] = item;
            const deleted = this._deleteIfExpired(key, value2);
            if (deleted === false) {
              yield [key, value2.value];
            }
          }
          items = [...this.oldCache];
          for (let i2 = items.length - 1; i2 >= 0; --i2) {
            const item = items[i2];
            const [key, value2] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value2);
              if (deleted === false) {
                yield [key, value2.value];
              }
            }
          }
        }
        *entriesAscending() {
          for (const [key, value2] of this._entriesAscending()) {
            yield [key, value2.value];
          }
        }
        get size() {
          if (!this._size) {
            return this.oldCache.size;
          }
          let oldCacheSize = 0;
          for (const key of this.oldCache.keys()) {
            if (!this.cache.has(key)) {
              oldCacheSize++;
            }
          }
          return Math.min(this._size + oldCacheSize, this.maxSize);
        }
      };
      module.exports = QuickLRU;
    }
  });

  // node_modules/.pnpm/didyoumean@1.2.2/node_modules/didyoumean/didYouMean-1.2.1.js
  var require_didYouMean_1_2_1 = __commonJS({
    "node_modules/.pnpm/didyoumean@1.2.2/node_modules/didyoumean/didYouMean-1.2.1.js"(exports, module) {
      (function() {
        "use strict";
        function didYouMean2(str, list3, key) {
          if (!str) return null;
          if (!didYouMean2.caseSensitive) {
            str = str.toLowerCase();
          }
          var thresholdRelative = didYouMean2.threshold === null ? null : didYouMean2.threshold * str.length, thresholdAbsolute = didYouMean2.thresholdAbsolute, winningVal;
          if (thresholdRelative !== null && thresholdAbsolute !== null) winningVal = Math.min(thresholdRelative, thresholdAbsolute);
          else if (thresholdRelative !== null) winningVal = thresholdRelative;
          else if (thresholdAbsolute !== null) winningVal = thresholdAbsolute;
          else winningVal = null;
          var winner, candidate, testCandidate, val, i2, len = list3.length;
          for (i2 = 0; i2 < len; i2++) {
            candidate = list3[i2];
            if (key) {
              candidate = candidate[key];
            }
            if (!candidate) {
              continue;
            }
            if (!didYouMean2.caseSensitive) {
              testCandidate = candidate.toLowerCase();
            } else {
              testCandidate = candidate;
            }
            val = getEditDistance(str, testCandidate, winningVal);
            if (winningVal === null || val < winningVal) {
              winningVal = val;
              if (key && didYouMean2.returnWinningObject) winner = list3[i2];
              else winner = candidate;
              if (didYouMean2.returnFirstMatch) return winner;
            }
          }
          return winner || didYouMean2.nullResultValue;
        }
        didYouMean2.threshold = 0.4;
        didYouMean2.thresholdAbsolute = 20;
        didYouMean2.caseSensitive = false;
        didYouMean2.nullResultValue = null;
        didYouMean2.returnWinningObject = null;
        didYouMean2.returnFirstMatch = false;
        if (typeof module !== "undefined" && module.exports) {
          module.exports = didYouMean2;
        } else {
          window.didYouMean = didYouMean2;
        }
        var MAX_INT = Math.pow(2, 32) - 1;
        function getEditDistance(a2, b2, max2) {
          max2 = max2 || max2 === 0 ? max2 : MAX_INT;
          var lena = a2.length;
          var lenb = b2.length;
          if (lena === 0) return Math.min(max2 + 1, lenb);
          if (lenb === 0) return Math.min(max2 + 1, lena);
          if (Math.abs(lena - lenb) > max2) return max2 + 1;
          var matrix = [], i2, j2, colMin, minJ, maxJ;
          for (i2 = 0; i2 <= lenb; i2++) {
            matrix[i2] = [i2];
          }
          for (j2 = 0; j2 <= lena; j2++) {
            matrix[0][j2] = j2;
          }
          for (i2 = 1; i2 <= lenb; i2++) {
            colMin = MAX_INT;
            minJ = 1;
            if (i2 > max2) minJ = i2 - max2;
            maxJ = lenb + 1;
            if (maxJ > max2 + i2) maxJ = max2 + i2;
            for (j2 = 1; j2 <= lena; j2++) {
              if (j2 < minJ || j2 > maxJ) {
                matrix[i2][j2] = max2 + 1;
              } else {
                if (b2.charAt(i2 - 1) === a2.charAt(j2 - 1)) {
                  matrix[i2][j2] = matrix[i2 - 1][j2 - 1];
                } else {
                  matrix[i2][j2] = Math.min(
                    matrix[i2 - 1][j2 - 1] + 1,
                    // Substitute
                    Math.min(
                      matrix[i2][j2 - 1] + 1,
                      // Insert
                      matrix[i2 - 1][j2] + 1
                    )
                  );
                }
              }
              if (matrix[i2][j2] < colMin) colMin = matrix[i2][j2];
            }
            if (colMin > max2) return max2 + 1;
          }
          return matrix[lenb][lena];
        }
      })();
    }
  });

  // node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/esm/main.js
  var DocumentUri;
  (function(DocumentUri2) {
    function is(value2) {
      return typeof value2 === "string";
    }
    DocumentUri2.is = is;
  })(DocumentUri || (DocumentUri = {}));
  var URI;
  (function(URI3) {
    function is(value2) {
      return typeof value2 === "string";
    }
    URI3.is = is;
  })(URI || (URI = {}));
  var integer;
  (function(integer2) {
    integer2.MIN_VALUE = -2147483648;
    integer2.MAX_VALUE = 2147483647;
    function is(value2) {
      return typeof value2 === "number" && integer2.MIN_VALUE <= value2 && value2 <= integer2.MAX_VALUE;
    }
    integer2.is = is;
  })(integer || (integer = {}));
  var uinteger;
  (function(uinteger2) {
    uinteger2.MIN_VALUE = 0;
    uinteger2.MAX_VALUE = 2147483647;
    function is(value2) {
      return typeof value2 === "number" && uinteger2.MIN_VALUE <= value2 && value2 <= uinteger2.MAX_VALUE;
    }
    uinteger2.is = is;
  })(uinteger || (uinteger = {}));
  var Position;
  (function(Position3) {
    function create(line, character) {
      if (line === Number.MAX_VALUE) {
        line = uinteger.MAX_VALUE;
      }
      if (character === Number.MAX_VALUE) {
        character = uinteger.MAX_VALUE;
      }
      return { line, character };
    }
    Position3.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position3.is = is;
  })(Position || (Position = {}));
  var Range;
  (function(Range3) {
    function create(one, two, three, four) {
      if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
        return { start: Position.create(one, two), end: Position.create(three, four) };
      } else if (Position.is(one) && Position.is(two)) {
        return { start: one, end: two };
      } else {
        throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
      }
    }
    Range3.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range3.is = is;
  })(Range || (Range = {}));
  var Location;
  (function(Location2) {
    function create(uri, range) {
      return { uri, range };
    }
    Location2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location2.is = is;
  })(Location || (Location = {}));
  var LocationLink;
  (function(LocationLink2) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
    }
    LocationLink2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink2.is = is;
  })(LocationLink || (LocationLink = {}));
  var Color;
  (function(Color3) {
    function create(red, green, blue, alpha) {
      return {
        red,
        green,
        blue,
        alpha
      };
    }
    Color3.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color3.is = is;
  })(Color || (Color = {}));
  var ColorInformation;
  (function(ColorInformation2) {
    function create(range, color2) {
      return {
        range,
        color: color2
      };
    }
    ColorInformation2.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation2.is = is;
  })(ColorInformation || (ColorInformation = {}));
  var ColorPresentation;
  (function(ColorPresentation2) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation2.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation2.is = is;
  })(ColorPresentation || (ColorPresentation = {}));
  var FoldingRangeKind;
  (function(FoldingRangeKind3) {
    FoldingRangeKind3.Comment = "comment";
    FoldingRangeKind3.Imports = "imports";
    FoldingRangeKind3.Region = "region";
  })(FoldingRangeKind || (FoldingRangeKind = {}));
  var FoldingRange;
  (function(FoldingRange2) {
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
      const result = {
        startLine,
        endLine
      };
      if (Is.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is.defined(kind)) {
        result.kind = kind;
      }
      if (Is.defined(collapsedText)) {
        result.collapsedText = collapsedText;
      }
      return result;
    }
    FoldingRange2.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange2.is = is;
  })(FoldingRange || (FoldingRange = {}));
  var DiagnosticRelatedInformation;
  (function(DiagnosticRelatedInformation2) {
    function create(location, message) {
      return {
        location,
        message
      };
    }
    DiagnosticRelatedInformation2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation2.is = is;
  })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
  var DiagnosticSeverity;
  (function(DiagnosticSeverity2) {
    DiagnosticSeverity2.Error = 1;
    DiagnosticSeverity2.Warning = 2;
    DiagnosticSeverity2.Information = 3;
    DiagnosticSeverity2.Hint = 4;
  })(DiagnosticSeverity || (DiagnosticSeverity = {}));
  var DiagnosticTag;
  (function(DiagnosticTag2) {
    DiagnosticTag2.Unnecessary = 1;
    DiagnosticTag2.Deprecated = 2;
  })(DiagnosticTag || (DiagnosticTag = {}));
  var CodeDescription;
  (function(CodeDescription2) {
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription2.is = is;
  })(CodeDescription || (CodeDescription = {}));
  var Diagnostic;
  (function(Diagnostic2) {
    function create(range, message, severity, code, source, relatedInformation) {
      let result = { range, message };
      if (Is.defined(severity)) {
        result.severity = severity;
      }
      if (Is.defined(code)) {
        result.code = code;
      }
      if (Is.defined(source)) {
        result.source = source;
      }
      if (Is.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic2.create = create;
    function is(value2) {
      var _a4;
      let candidate = value2;
      return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a4 = candidate.codeDescription) === null || _a4 === void 0 ? void 0 : _a4.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic2.is = is;
  })(Diagnostic || (Diagnostic = {}));
  var Command;
  (function(Command3) {
    function create(title, command, ...args) {
      let result = { title, command };
      if (Is.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command3.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command3.is = is;
  })(Command || (Command = {}));
  var TextEdit;
  (function(TextEdit2) {
    function replace2(range, newText) {
      return { range, newText };
    }
    TextEdit2.replace = replace2;
    function insert(position2, newText) {
      return { range: { start: position2, end: position2 }, newText };
    }
    TextEdit2.insert = insert;
    function del(range) {
      return { range, newText: "" };
    }
    TextEdit2.del = del;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
    }
    TextEdit2.is = is;
  })(TextEdit || (TextEdit = {}));
  var ChangeAnnotation;
  (function(ChangeAnnotation2) {
    function create(label, needsConfirmation, description) {
      const result = { label };
      if (needsConfirmation !== void 0) {
        result.needsConfirmation = needsConfirmation;
      }
      if (description !== void 0) {
        result.description = description;
      }
      return result;
    }
    ChangeAnnotation2.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    ChangeAnnotation2.is = is;
  })(ChangeAnnotation || (ChangeAnnotation = {}));
  var ChangeAnnotationIdentifier;
  (function(ChangeAnnotationIdentifier2) {
    function is(value2) {
      const candidate = value2;
      return Is.string(candidate);
    }
    ChangeAnnotationIdentifier2.is = is;
  })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
  var AnnotatedTextEdit;
  (function(AnnotatedTextEdit2) {
    function replace2(range, newText, annotation) {
      return { range, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.replace = replace2;
    function insert(position2, newText, annotation) {
      return { range: { start: position2, end: position2 }, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.insert = insert;
    function del(range, annotation) {
      return { range, newText: "", annotationId: annotation };
    }
    AnnotatedTextEdit2.del = del;
    function is(value2) {
      const candidate = value2;
      return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit2.is = is;
  })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
  var TextDocumentEdit;
  (function(TextDocumentEdit2) {
    function create(textDocument, edits) {
      return { textDocument, edits };
    }
    TextDocumentEdit2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit2.is = is;
  })(TextDocumentEdit || (TextDocumentEdit = {}));
  var CreateFile;
  (function(CreateFile2) {
    function create(uri, options, annotation) {
      let result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    CreateFile2.create = create;
    function is(value2) {
      let candidate = value2;
      return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile2.is = is;
  })(CreateFile || (CreateFile = {}));
  var RenameFile;
  (function(RenameFile2) {
    function create(oldUri, newUri, options, annotation) {
      let result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    RenameFile2.create = create;
    function is(value2) {
      let candidate = value2;
      return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile2.is = is;
  })(RenameFile || (RenameFile = {}));
  var DeleteFile;
  (function(DeleteFile2) {
    function create(uri, options, annotation) {
      let result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    DeleteFile2.create = create;
    function is(value2) {
      let candidate = value2;
      return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile2.is = is;
  })(DeleteFile || (DeleteFile = {}));
  var WorkspaceEdit;
  (function(WorkspaceEdit2) {
    function is(value2) {
      let candidate = value2;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
        if (Is.string(change.kind)) {
          return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
        } else {
          return TextDocumentEdit.is(change);
        }
      }));
    }
    WorkspaceEdit2.is = is;
  })(WorkspaceEdit || (WorkspaceEdit = {}));
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return { uri };
    }
    TextDocumentIdentifier2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version2) {
      return { uri, version: version2 };
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier2.is = is;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var OptionalVersionedTextDocumentIdentifier;
  (function(OptionalVersionedTextDocumentIdentifier2) {
    function create(uri, version2) {
      return { uri, version: version2 };
    }
    OptionalVersionedTextDocumentIdentifier2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier2.is = is;
  })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId, version2, text2) {
      return { uri, languageId, version: version2, text: text2 };
    }
    TextDocumentItem2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem2.is = is;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind;
  (function(MarkupKind2) {
    MarkupKind2.PlainText = "plaintext";
    MarkupKind2.Markdown = "markdown";
    function is(value2) {
      const candidate = value2;
      return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
    }
    MarkupKind2.is = is;
  })(MarkupKind || (MarkupKind = {}));
  var MarkupContent;
  (function(MarkupContent2) {
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(value2) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent2.is = is;
  })(MarkupContent || (MarkupContent = {}));
  var CompletionItemKind;
  (function(CompletionItemKind3) {
    CompletionItemKind3.Text = 1;
    CompletionItemKind3.Method = 2;
    CompletionItemKind3.Function = 3;
    CompletionItemKind3.Constructor = 4;
    CompletionItemKind3.Field = 5;
    CompletionItemKind3.Variable = 6;
    CompletionItemKind3.Class = 7;
    CompletionItemKind3.Interface = 8;
    CompletionItemKind3.Module = 9;
    CompletionItemKind3.Property = 10;
    CompletionItemKind3.Unit = 11;
    CompletionItemKind3.Value = 12;
    CompletionItemKind3.Enum = 13;
    CompletionItemKind3.Keyword = 14;
    CompletionItemKind3.Snippet = 15;
    CompletionItemKind3.Color = 16;
    CompletionItemKind3.File = 17;
    CompletionItemKind3.Reference = 18;
    CompletionItemKind3.Folder = 19;
    CompletionItemKind3.EnumMember = 20;
    CompletionItemKind3.Constant = 21;
    CompletionItemKind3.Struct = 22;
    CompletionItemKind3.Event = 23;
    CompletionItemKind3.Operator = 24;
    CompletionItemKind3.TypeParameter = 25;
  })(CompletionItemKind || (CompletionItemKind = {}));
  var InsertTextFormat;
  (function(InsertTextFormat2) {
    InsertTextFormat2.PlainText = 1;
    InsertTextFormat2.Snippet = 2;
  })(InsertTextFormat || (InsertTextFormat = {}));
  var CompletionItemTag;
  (function(CompletionItemTag3) {
    CompletionItemTag3.Deprecated = 1;
  })(CompletionItemTag || (CompletionItemTag = {}));
  var InsertReplaceEdit;
  (function(InsertReplaceEdit2) {
    function create(newText, insert, replace2) {
      return { newText, insert, replace: replace2 };
    }
    InsertReplaceEdit2.create = create;
    function is(value2) {
      const candidate = value2;
      return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit2.is = is;
  })(InsertReplaceEdit || (InsertReplaceEdit = {}));
  var InsertTextMode;
  (function(InsertTextMode2) {
    InsertTextMode2.asIs = 1;
    InsertTextMode2.adjustIndentation = 2;
  })(InsertTextMode || (InsertTextMode = {}));
  var CompletionItemLabelDetails;
  (function(CompletionItemLabelDetails2) {
    function is(value2) {
      const candidate = value2;
      return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    CompletionItemLabelDetails2.is = is;
  })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
  var CompletionItem;
  (function(CompletionItem2) {
    function create(label) {
      return { label };
    }
    CompletionItem2.create = create;
  })(CompletionItem || (CompletionItem = {}));
  var CompletionList;
  (function(CompletionList2) {
    function create(items, isIncomplete) {
      return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList2.create = create;
  })(CompletionList || (CompletionList = {}));
  var MarkedString;
  (function(MarkedString2) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString2.fromPlainText = fromPlainText;
    function is(value2) {
      const candidate = value2;
      return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString2.is = is;
  })(MarkedString || (MarkedString = {}));
  var Hover;
  (function(Hover2) {
    function is(value2) {
      let candidate = value2;
      return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value2.range === void 0 || Range.is(value2.range));
    }
    Hover2.is = is;
  })(Hover || (Hover = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? { label, documentation } : { label };
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation, ...parameters) {
      let result = { label };
      if (Is.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4.Text = 1;
    DocumentHighlightKind4.Read = 2;
    DocumentHighlightKind4.Write = 3;
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var DocumentHighlight;
  (function(DocumentHighlight2) {
    function create(range, kind) {
      let result = { range };
      if (Is.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight2.create = create;
  })(DocumentHighlight || (DocumentHighlight = {}));
  var SymbolKind;
  (function(SymbolKind3) {
    SymbolKind3.File = 1;
    SymbolKind3.Module = 2;
    SymbolKind3.Namespace = 3;
    SymbolKind3.Package = 4;
    SymbolKind3.Class = 5;
    SymbolKind3.Method = 6;
    SymbolKind3.Property = 7;
    SymbolKind3.Field = 8;
    SymbolKind3.Constructor = 9;
    SymbolKind3.Enum = 10;
    SymbolKind3.Interface = 11;
    SymbolKind3.Function = 12;
    SymbolKind3.Variable = 13;
    SymbolKind3.Constant = 14;
    SymbolKind3.String = 15;
    SymbolKind3.Number = 16;
    SymbolKind3.Boolean = 17;
    SymbolKind3.Array = 18;
    SymbolKind3.Object = 19;
    SymbolKind3.Key = 20;
    SymbolKind3.Null = 21;
    SymbolKind3.EnumMember = 22;
    SymbolKind3.Struct = 23;
    SymbolKind3.Event = 24;
    SymbolKind3.Operator = 25;
    SymbolKind3.TypeParameter = 26;
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag3) {
    SymbolTag3.Deprecated = 1;
  })(SymbolTag || (SymbolTag = {}));
  var SymbolInformation;
  (function(SymbolInformation2) {
    function create(name, kind, range, uri, containerName) {
      let result = {
        name,
        kind,
        location: { uri, range }
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation2.create = create;
  })(SymbolInformation || (SymbolInformation = {}));
  var WorkspaceSymbol;
  (function(WorkspaceSymbol2) {
    function create(name, kind, uri, range) {
      return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
    }
    WorkspaceSymbol2.create = create;
  })(WorkspaceSymbol || (WorkspaceSymbol = {}));
  var DocumentSymbol;
  (function(DocumentSymbol2) {
    function create(name, detail, kind, range, selectionRange, children) {
      let result = {
        name,
        detail,
        kind,
        range,
        selectionRange
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol2.create = create;
    function is(value2) {
      let candidate = value2;
      return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
    }
    DocumentSymbol2.is = is;
  })(DocumentSymbol || (DocumentSymbol = {}));
  var CodeActionKind;
  (function(CodeActionKind2) {
    CodeActionKind2.Empty = "";
    CodeActionKind2.QuickFix = "quickfix";
    CodeActionKind2.Refactor = "refactor";
    CodeActionKind2.RefactorExtract = "refactor.extract";
    CodeActionKind2.RefactorInline = "refactor.inline";
    CodeActionKind2.RefactorRewrite = "refactor.rewrite";
    CodeActionKind2.Source = "source";
    CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind2.SourceFixAll = "source.fixAll";
  })(CodeActionKind || (CodeActionKind = {}));
  var CodeActionTriggerKind;
  (function(CodeActionTriggerKind2) {
    CodeActionTriggerKind2.Invoked = 1;
    CodeActionTriggerKind2.Automatic = 2;
  })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
  var CodeActionContext;
  (function(CodeActionContext2) {
    function create(diagnostics, only, triggerKind) {
      let result = { diagnostics };
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      if (triggerKind !== void 0 && triggerKind !== null) {
        result.triggerKind = triggerKind;
      }
      return result;
    }
    CodeActionContext2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext2.is = is;
  })(CodeActionContext || (CodeActionContext = {}));
  var CodeAction;
  (function(CodeAction2) {
    function create(title, kindOrCommandOrEdit, kind) {
      let result = { title };
      let checkKind = true;
      if (typeof kindOrCommandOrEdit === "string") {
        checkKind = false;
        result.kind = kindOrCommandOrEdit;
      } else if (Command.is(kindOrCommandOrEdit)) {
        result.command = kindOrCommandOrEdit;
      } else {
        result.edit = kindOrCommandOrEdit;
      }
      if (checkKind && kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction2.create = create;
    function is(value2) {
      let candidate = value2;
      return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction2.is = is;
  })(CodeAction || (CodeAction = {}));
  var CodeLens;
  (function(CodeLens2) {
    function create(range, data) {
      let result = { range };
      if (Is.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens2.is = is;
  })(CodeLens || (CodeLens = {}));
  var FormattingOptions;
  (function(FormattingOptions2) {
    function create(tabSize, insertSpaces) {
      return { tabSize, insertSpaces };
    }
    FormattingOptions2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions2.is = is;
  })(FormattingOptions || (FormattingOptions = {}));
  var DocumentLink;
  (function(DocumentLink2) {
    function create(range, target, data) {
      return { range, target, data };
    }
    DocumentLink2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink2.is = is;
  })(DocumentLink || (DocumentLink = {}));
  var SelectionRange;
  (function(SelectionRange2) {
    function create(range, parent) {
      return { range, parent };
    }
    SelectionRange2.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
    }
    SelectionRange2.is = is;
  })(SelectionRange || (SelectionRange = {}));
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["enumMember"] = "enumMember";
    SemanticTokenTypes2["event"] = "event";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["method"] = "method";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["modifier"] = "modifier";
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
    SemanticTokenTypes2["decorator"] = "decorator";
  })(SemanticTokenTypes || (SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["readonly"] = "readonly";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["modification"] = "modification";
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
  })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is;
  })(SemanticTokens || (SemanticTokens = {}));
  var InlineValueText;
  (function(InlineValueText2) {
    function create(range, text2) {
      return { range, text: text2 };
    }
    InlineValueText2.create = create;
    function is(value2) {
      const candidate = value2;
      return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText2.is = is;
  })(InlineValueText || (InlineValueText = {}));
  var InlineValueVariableLookup;
  (function(InlineValueVariableLookup2) {
    function create(range, variableName, caseSensitiveLookup) {
      return { range, variableName, caseSensitiveLookup };
    }
    InlineValueVariableLookup2.create = create;
    function is(value2) {
      const candidate = value2;
      return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
    }
    InlineValueVariableLookup2.is = is;
  })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
  var InlineValueEvaluatableExpression;
  (function(InlineValueEvaluatableExpression2) {
    function create(range, expression) {
      return { range, expression };
    }
    InlineValueEvaluatableExpression2.create = create;
    function is(value2) {
      const candidate = value2;
      return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
    }
    InlineValueEvaluatableExpression2.is = is;
  })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
  var InlineValueContext;
  (function(InlineValueContext2) {
    function create(frameId, stoppedLocation) {
      return { frameId, stoppedLocation };
    }
    InlineValueContext2.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.defined(candidate) && Range.is(value2.stoppedLocation);
    }
    InlineValueContext2.is = is;
  })(InlineValueContext || (InlineValueContext = {}));
  var InlayHintKind;
  (function(InlayHintKind4) {
    InlayHintKind4.Type = 1;
    InlayHintKind4.Parameter = 2;
    function is(value2) {
      return value2 === 1 || value2 === 2;
    }
    InlayHintKind4.is = is;
  })(InlayHintKind || (InlayHintKind = {}));
  var InlayHintLabelPart;
  (function(InlayHintLabelPart2) {
    function create(value2) {
      return { value: value2 };
    }
    InlayHintLabelPart2.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
    }
    InlayHintLabelPart2.is = is;
  })(InlayHintLabelPart || (InlayHintLabelPart = {}));
  var InlayHint;
  (function(InlayHint2) {
    function create(position2, label, kind) {
      const result = { position: position2, label };
      if (kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    InlayHint2.create = create;
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
    }
    InlayHint2.is = is;
  })(InlayHint || (InlayHint = {}));
  var StringValue;
  (function(StringValue2) {
    function createSnippet(value2) {
      return { kind: "snippet", value: value2 };
    }
    StringValue2.createSnippet = createSnippet;
  })(StringValue || (StringValue = {}));
  var InlineCompletionItem;
  (function(InlineCompletionItem2) {
    function create(insertText, filterText, range, command) {
      return { insertText, filterText, range, command };
    }
    InlineCompletionItem2.create = create;
  })(InlineCompletionItem || (InlineCompletionItem = {}));
  var InlineCompletionList;
  (function(InlineCompletionList2) {
    function create(items) {
      return { items };
    }
    InlineCompletionList2.create = create;
  })(InlineCompletionList || (InlineCompletionList = {}));
  var InlineCompletionTriggerKind;
  (function(InlineCompletionTriggerKind4) {
    InlineCompletionTriggerKind4.Invoked = 0;
    InlineCompletionTriggerKind4.Automatic = 1;
  })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
  var SelectedCompletionInfo;
  (function(SelectedCompletionInfo2) {
    function create(range, text2) {
      return { range, text: text2 };
    }
    SelectedCompletionInfo2.create = create;
  })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
  var InlineCompletionContext;
  (function(InlineCompletionContext2) {
    function create(triggerKind, selectedCompletionInfo) {
      return { triggerKind, selectedCompletionInfo };
    }
    InlineCompletionContext2.create = create;
  })(InlineCompletionContext || (InlineCompletionContext = {}));
  var WorkspaceFolder;
  (function(WorkspaceFolder2) {
    function is(value2) {
      const candidate = value2;
      return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder2.is = is;
  })(WorkspaceFolder || (WorkspaceFolder = {}));
  var TextDocument;
  (function(TextDocument3) {
    function create(uri, languageId, version2, content) {
      return new FullTextDocument(uri, languageId, version2, content);
    }
    TextDocument3.create = create;
    function is(value2) {
      let candidate = value2;
      return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument3.is = is;
    function applyEdits(document3, edits) {
      let text2 = document3.getText();
      let sortedEdits = mergeSort2(edits, (a2, b2) => {
        let diff = a2.range.start.line - b2.range.start.line;
        if (diff === 0) {
          return a2.range.start.character - b2.range.start.character;
        }
        return diff;
      });
      let lastModifiedOffset = text2.length;
      for (let i2 = sortedEdits.length - 1; i2 >= 0; i2--) {
        let e5 = sortedEdits[i2];
        let startOffset = document3.offsetAt(e5.range.start);
        let endOffset = document3.offsetAt(e5.range.end);
        if (endOffset <= lastModifiedOffset) {
          text2 = text2.substring(0, startOffset) + e5.newText + text2.substring(endOffset, text2.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text2;
    }
    TextDocument3.applyEdits = applyEdits;
    function mergeSort2(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      const p4 = data.length / 2 | 0;
      const left = data.slice(0, p4);
      const right = data.slice(p4);
      mergeSort2(left, compare);
      mergeSort2(right, compare);
      let leftIdx = 0;
      let rightIdx = 0;
      let i2 = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        let ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
          data[i2++] = left[leftIdx++];
        } else {
          data[i2++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i2++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i2++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument || (TextDocument = {}));
  var FullTextDocument = class {
    constructor(uri, languageId, version2, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version2;
      this._content = content;
      this._lineOffsets = void 0;
    }
    get uri() {
      return this._uri;
    }
    get languageId() {
      return this._languageId;
    }
    get version() {
      return this._version;
    }
    getText(range) {
      if (range) {
        let start = this.offsetAt(range.start);
        let end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    }
    update(event, version2) {
      this._content = event.text;
      this._version = version2;
      this._lineOffsets = void 0;
    }
    getLineOffsets() {
      if (this._lineOffsets === void 0) {
        let lineOffsets = [];
        let text2 = this._content;
        let isLineStart = true;
        for (let i2 = 0; i2 < text2.length; i2++) {
          if (isLineStart) {
            lineOffsets.push(i2);
            isLineStart = false;
          }
          let ch = text2.charAt(i2);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i2 + 1 < text2.length && text2.charAt(i2 + 1) === "\n") {
            i2++;
          }
        }
        if (isLineStart && text2.length > 0) {
          lineOffsets.push(text2.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    }
    positionAt(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      let lineOffsets = this.getLineOffsets();
      let low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position.create(0, offset);
      }
      while (low < high) {
        let mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      let line = low - 1;
      return Position.create(line, offset - lineOffsets[line]);
    }
    offsetAt(position2) {
      let lineOffsets = this.getLineOffsets();
      if (position2.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position2.line < 0) {
        return 0;
      }
      let lineOffset = lineOffsets[position2.line];
      let nextLineOffset = position2.line + 1 < lineOffsets.length ? lineOffsets[position2.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position2.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
      return this.getLineOffsets().length;
    }
  };
  var Is;
  (function(Is2) {
    const toString2 = Object.prototype.toString;
    function defined(value2) {
      return typeof value2 !== "undefined";
    }
    Is2.defined = defined;
    function undefined2(value2) {
      return typeof value2 === "undefined";
    }
    Is2.undefined = undefined2;
    function boolean(value2) {
      return value2 === true || value2 === false;
    }
    Is2.boolean = boolean;
    function string(value2) {
      return toString2.call(value2) === "[object String]";
    }
    Is2.string = string;
    function number2(value2) {
      return toString2.call(value2) === "[object Number]";
    }
    Is2.number = number2;
    function numberRange(value2, min, max2) {
      return toString2.call(value2) === "[object Number]" && min <= value2 && value2 <= max2;
    }
    Is2.numberRange = numberRange;
    function integer2(value2) {
      return toString2.call(value2) === "[object Number]" && -2147483648 <= value2 && value2 <= 2147483647;
    }
    Is2.integer = integer2;
    function uinteger2(value2) {
      return toString2.call(value2) === "[object Number]" && 0 <= value2 && value2 <= 2147483647;
    }
    Is2.uinteger = uinteger2;
    function func(value2) {
      return toString2.call(value2) === "[object Function]";
    }
    Is2.func = func;
    function objectLiteral(value2) {
      return value2 !== null && typeof value2 === "object";
    }
    Is2.objectLiteral = objectLiteral;
    function typedArray(value2, check) {
      return Array.isArray(value2) && value2.every(check);
    }
    Is2.typedArray = typedArray;
  })(Is || (Is = {}));

  // node_modules/.pnpm/monaco-tailwindcss@0.6.1_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_dlv = __toESM(require_dlv_umd(), 1);
  var import_dlv2 = __toESM(require_dlv_umd(), 1);
  var import_dlv3 = __toESM(require_dlv_umd(), 1);

  // node_modules/.pnpm/@csstools+css-tokenizer@2.4.1/node_modules/@csstools/css-tokenizer/dist/index.mjs
  var ParseError = class extends Error {
    sourceStart;
    sourceEnd;
    parserState;
    constructor(e5, n2, o2, t2) {
      super(e5), this.name = "ParseError", this.sourceStart = n2, this.sourceEnd = o2, this.parserState = t2;
    }
  };
  var ParseErrorWithToken = class extends ParseError {
    token;
    constructor(e5, n2, o2, t2, r3) {
      super(e5, n2, o2, t2), this.token = r3;
    }
  };
  var e = { UnexpectedNewLineInString: "Unexpected newline while consuming a string token.", UnexpectedEOFInString: "Unexpected EOF while consuming a string token.", UnexpectedEOFInComment: "Unexpected EOF while consuming a comment.", UnexpectedEOFInURL: "Unexpected EOF while consuming a url token.", UnexpectedEOFInEscapedCodePoint: "Unexpected EOF while consuming an escaped code point.", UnexpectedCharacterInURL: "Unexpected character while consuming a url token.", InvalidEscapeSequenceInURL: "Invalid escape sequence while consuming a url token.", InvalidEscapeSequenceAfterBackslash: 'Invalid escape sequence after "\\"' };
  var Reader = class {
    cursor = 0;
    source = "";
    codePointSource = [];
    representationIndices = [-1];
    length = 0;
    representationStart = 0;
    representationEnd = -1;
    constructor(e5) {
      this.source = e5;
      {
        let n2 = -1, o2 = "";
        for (o2 of e5) n2 += o2.length, this.codePointSource.push(o2.codePointAt(0)), this.representationIndices.push(n2);
      }
      this.length = this.codePointSource.length;
    }
    advanceCodePoint(e5 = 1) {
      this.cursor = this.cursor + e5, this.representationEnd = this.representationIndices[this.cursor];
    }
    readCodePoint(e5 = 1) {
      const n2 = this.codePointSource[this.cursor];
      return void 0 !== n2 && (this.cursor = this.cursor + e5, this.representationEnd = this.representationIndices[this.cursor], n2);
    }
    unreadCodePoint(e5 = 1) {
      this.cursor = this.cursor - e5, this.representationEnd = this.representationIndices[this.cursor];
    }
    resetRepresentation() {
      this.representationStart = this.representationIndices[this.cursor] + 1, this.representationEnd = -1;
    }
  };
  var n = "undefined" != typeof globalThis && "structuredClone" in globalThis;
  function stringify(...e5) {
    let n2 = "";
    for (let o2 = 0; o2 < e5.length; o2++) n2 += e5[o2][1];
    return n2;
  }
  var o = 39;
  var t = 42;
  var r = 8;
  var i = 13;
  var s = 9;
  var c = 58;
  var a = 44;
  var u = 64;
  var d = 127;
  var p = 33;
  var P = 12;
  var S = 46;
  var C = 62;
  var l = 45;
  var f = 31;
  var m = 69;
  var h = 101;
  var k = 123;
  var E = 40;
  var T = 91;
  var v = 60;
  var g = 10;
  var I = 11;
  var U = 95;
  var O = 1114111;
  var D = 0;
  var R = 35;
  var w = 37;
  var L = 43;
  var A = 34;
  var x = 65533;
  var W = 92;
  var y = 125;
  var F = 41;
  var q = 93;
  var N = 59;
  var b = 14;
  var B = 47;
  var H = 32;
  var V = 117;
  var K = 85;
  var z = 114;
  var M = 82;
  var $ = 108;
  var J = 76;
  var _ = 63;
  var j = 48;
  var Q = 70;
  function checkIfFourCodePointsWouldStartCDO(e5) {
    return e5.codePointSource[e5.cursor] === v && e5.codePointSource[e5.cursor + 1] === p && e5.codePointSource[e5.cursor + 2] === l && e5.codePointSource[e5.cursor + 3] === l;
  }
  function isDigitCodePoint(e5) {
    return e5 >= 48 && e5 <= 57;
  }
  function isUppercaseLetterCodePoint(e5) {
    return e5 >= 65 && e5 <= 90;
  }
  function isLowercaseLetterCodePoint(e5) {
    return e5 >= 97 && e5 <= 122;
  }
  function isHexDigitCodePoint(e5) {
    return isDigitCodePoint(e5) || e5 >= 97 && e5 <= 102 || e5 >= 65 && e5 <= 70;
  }
  function isLetterCodePoint(e5) {
    return isLowercaseLetterCodePoint(e5) || isUppercaseLetterCodePoint(e5);
  }
  function isIdentStartCodePoint(e5) {
    return isLetterCodePoint(e5) || isNonASCII_IdentCodePoint(e5) || e5 === U;
  }
  function isIdentCodePoint(e5) {
    return isIdentStartCodePoint(e5) || isDigitCodePoint(e5) || e5 === l;
  }
  function isNonASCII_IdentCodePoint(e5) {
    return 183 === e5 || 8204 === e5 || 8205 === e5 || 8255 === e5 || 8256 === e5 || 8204 === e5 || (192 <= e5 && e5 <= 214 || 216 <= e5 && e5 <= 246 || 248 <= e5 && e5 <= 893 || 895 <= e5 && e5 <= 8191 || 8304 <= e5 && e5 <= 8591 || 11264 <= e5 && e5 <= 12271 || 12289 <= e5 && e5 <= 55295 || 63744 <= e5 && e5 <= 64975 || 65008 <= e5 && e5 <= 65533 || e5 >= 65536);
  }
  function isNewLine(e5) {
    return e5 === g || e5 === i || e5 === P;
  }
  function isWhitespace(e5) {
    return e5 === H || e5 === g || e5 === s || e5 === i || e5 === P;
  }
  function checkIfTwoCodePointsAreAValidEscape(e5) {
    return e5.codePointSource[e5.cursor] === W && !isNewLine(e5.codePointSource[e5.cursor + 1]);
  }
  function checkIfThreeCodePointsWouldStartAnIdentSequence(e5, n2) {
    return n2.codePointSource[n2.cursor] === l ? n2.codePointSource[n2.cursor + 1] === l || (!!isIdentStartCodePoint(n2.codePointSource[n2.cursor + 1]) || n2.codePointSource[n2.cursor + 1] === W && !isNewLine(n2.codePointSource[n2.cursor + 2])) : !!isIdentStartCodePoint(n2.codePointSource[n2.cursor]) || checkIfTwoCodePointsAreAValidEscape(n2);
  }
  function checkIfThreeCodePointsWouldStartANumber(e5) {
    return e5.codePointSource[e5.cursor] === L || e5.codePointSource[e5.cursor] === l ? !!isDigitCodePoint(e5.codePointSource[e5.cursor + 1]) || e5.codePointSource[e5.cursor + 1] === S && isDigitCodePoint(e5.codePointSource[e5.cursor + 2]) : e5.codePointSource[e5.cursor] === S ? isDigitCodePoint(e5.codePointSource[e5.cursor + 1]) : isDigitCodePoint(e5.codePointSource[e5.cursor]);
  }
  function checkIfTwoCodePointsStartAComment(e5) {
    return e5.codePointSource[e5.cursor] === B && e5.codePointSource[e5.cursor + 1] === t;
  }
  function checkIfThreeCodePointsWouldStartCDC(e5) {
    return e5.codePointSource[e5.cursor] === l && e5.codePointSource[e5.cursor + 1] === l && e5.codePointSource[e5.cursor + 2] === C;
  }
  var G;
  var X;
  var Y;
  function mirrorVariantType(e5) {
    switch (e5) {
      case G.OpenParen:
        return G.CloseParen;
      case G.CloseParen:
        return G.OpenParen;
      case G.OpenCurly:
        return G.CloseCurly;
      case G.CloseCurly:
        return G.OpenCurly;
      case G.OpenSquare:
        return G.CloseSquare;
      case G.CloseSquare:
        return G.OpenSquare;
      default:
        return null;
    }
  }
  function mirrorVariant(e5) {
    switch (e5[0]) {
      case G.OpenParen:
        return [G.CloseParen, ")", -1, -1, void 0];
      case G.CloseParen:
        return [G.OpenParen, "(", -1, -1, void 0];
      case G.OpenCurly:
        return [G.CloseCurly, "}", -1, -1, void 0];
      case G.CloseCurly:
        return [G.OpenCurly, "{", -1, -1, void 0];
      case G.OpenSquare:
        return [G.CloseSquare, "]", -1, -1, void 0];
      case G.CloseSquare:
        return [G.OpenSquare, "[", -1, -1, void 0];
      default:
        return null;
    }
  }
  function consumeComment(n2, o2) {
    for (o2.advanceCodePoint(2); ; ) {
      const r3 = o2.readCodePoint();
      if (false === r3) {
        const t2 = [G.Comment, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, void 0];
        return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInComment, o2.representationStart, o2.representationEnd, ["4.3.2. Consume comments", "Unexpected EOF"], t2)), t2;
      }
      if (r3 === t && (void 0 !== o2.codePointSource[o2.cursor] && o2.codePointSource[o2.cursor] === B)) {
        o2.advanceCodePoint();
        break;
      }
    }
    return [G.Comment, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, void 0];
  }
  function consumeEscapedCodePoint(n2, o2) {
    const t2 = o2.readCodePoint();
    if (false === t2) return n2.onParseError(new ParseError(e.UnexpectedEOFInEscapedCodePoint, o2.representationStart, o2.representationEnd, ["4.3.7. Consume an escaped code point", "Unexpected EOF"])), x;
    if (isHexDigitCodePoint(t2)) {
      const e5 = [t2];
      for (; void 0 !== o2.codePointSource[o2.cursor] && isHexDigitCodePoint(o2.codePointSource[o2.cursor]) && e5.length < 6; ) e5.push(o2.codePointSource[o2.cursor]), o2.advanceCodePoint();
      isWhitespace(o2.codePointSource[o2.cursor]) && o2.advanceCodePoint();
      const n3 = parseInt(String.fromCodePoint(...e5), 16);
      return 0 === n3 ? x : (r3 = n3) >= 55296 && r3 <= 57343 || n3 > O ? x : n3;
    }
    var r3;
    return t2;
  }
  function consumeIdentSequence(e5, n2) {
    const o2 = [];
    for (; ; ) if (isIdentCodePoint(n2.codePointSource[n2.cursor])) o2.push(n2.codePointSource[n2.cursor]), n2.advanceCodePoint();
    else {
      if (!checkIfTwoCodePointsAreAValidEscape(n2)) return o2;
      n2.advanceCodePoint(), o2.push(consumeEscapedCodePoint(e5, n2));
    }
  }
  function consumeHashToken(e5, n2) {
    if (n2.advanceCodePoint(), void 0 !== n2.codePointSource[n2.cursor] && (isIdentCodePoint(n2.codePointSource[n2.cursor]) || checkIfTwoCodePointsAreAValidEscape(n2))) {
      let o2 = Y.Unrestricted;
      checkIfThreeCodePointsWouldStartAnIdentSequence(0, n2) && (o2 = Y.ID);
      const t2 = consumeIdentSequence(e5, n2);
      return [G.Hash, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...t2), type: o2 }];
    }
    return [G.Delim, "#", n2.representationStart, n2.representationEnd, { value: "#" }];
  }
  function consumeNumber(e5, n2) {
    let o2 = X.Integer;
    for (n2.codePointSource[n2.cursor] !== L && n2.codePointSource[n2.cursor] !== l || n2.advanceCodePoint(); isDigitCodePoint(n2.codePointSource[n2.cursor]); ) n2.advanceCodePoint();
    if (n2.codePointSource[n2.cursor] === S && isDigitCodePoint(n2.codePointSource[n2.cursor + 1])) for (n2.advanceCodePoint(2), o2 = X.Number; isDigitCodePoint(n2.codePointSource[n2.cursor]); ) n2.advanceCodePoint();
    if (n2.codePointSource[n2.cursor] === h || n2.codePointSource[n2.cursor] === m) {
      if (isDigitCodePoint(n2.codePointSource[n2.cursor + 1])) n2.advanceCodePoint(2);
      else {
        if (n2.codePointSource[n2.cursor + 1] !== l && n2.codePointSource[n2.cursor + 1] !== L || !isDigitCodePoint(n2.codePointSource[n2.cursor + 2])) return o2;
        n2.advanceCodePoint(3);
      }
      for (o2 = X.Number; isDigitCodePoint(n2.codePointSource[n2.cursor]); ) n2.advanceCodePoint();
    }
    return o2;
  }
  function consumeNumericToken(e5, n2) {
    let o2;
    {
      const e6 = n2.codePointSource[n2.cursor];
      e6 === l ? o2 = "-" : e6 === L && (o2 = "+");
    }
    const t2 = consumeNumber(0, n2), r3 = parseFloat(n2.source.slice(n2.representationStart, n2.representationEnd + 1));
    if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, n2)) {
      const i2 = consumeIdentSequence(e5, n2);
      return [G.Dimension, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: r3, signCharacter: o2, type: t2, unit: String.fromCodePoint(...i2) }];
    }
    return n2.codePointSource[n2.cursor] === w ? (n2.advanceCodePoint(), [G.Percentage, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: r3, signCharacter: o2 }]) : [G.Number, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: r3, signCharacter: o2, type: t2 }];
  }
  function consumeWhiteSpace(e5) {
    for (; isWhitespace(e5.codePointSource[e5.cursor]); ) e5.advanceCodePoint();
    return [G.Whitespace, e5.source.slice(e5.representationStart, e5.representationEnd + 1), e5.representationStart, e5.representationEnd, void 0];
  }
  function consumeStringToken(n2, o2) {
    let t2 = "";
    const r3 = o2.readCodePoint();
    for (; ; ) {
      const s2 = o2.readCodePoint();
      if (false === s2) {
        const r4 = [G.String, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, { value: t2 }];
        return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInString, o2.representationStart, o2.representationEnd, ["4.3.5. Consume a string token", "Unexpected EOF"], r4)), r4;
      }
      if (isNewLine(s2)) {
        o2.unreadCodePoint();
        const t3 = [G.BadString, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, void 0];
        return n2.onParseError(new ParseErrorWithToken(e.UnexpectedNewLineInString, o2.representationStart, o2.codePointSource[o2.cursor] === i && o2.codePointSource[o2.cursor + 1] === g ? o2.representationEnd + 2 : o2.representationEnd + 1, ["4.3.5. Consume a string token", "Unexpected newline"], t3)), t3;
      }
      if (s2 === r3) return [G.String, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, { value: t2 }];
      if (s2 !== W) t2 += String.fromCodePoint(s2);
      else {
        if (void 0 === o2.codePointSource[o2.cursor]) continue;
        if (isNewLine(o2.codePointSource[o2.cursor])) {
          o2.codePointSource[o2.cursor] === i && o2.codePointSource[o2.cursor + 1] === g && o2.advanceCodePoint(), o2.advanceCodePoint();
          continue;
        }
        t2 += String.fromCodePoint(consumeEscapedCodePoint(n2, o2));
      }
    }
  }
  function checkIfCodePointsMatchURLIdent(e5) {
    return !(3 !== e5.length || e5[0] !== V && e5[0] !== K || e5[1] !== z && e5[1] !== M || e5[2] !== $ && e5[2] !== J);
  }
  function consumeBadURL(e5, n2) {
    for (; ; ) {
      if (void 0 === n2.codePointSource[n2.cursor]) return;
      if (n2.codePointSource[n2.cursor] === F) return void n2.advanceCodePoint();
      checkIfTwoCodePointsAreAValidEscape(n2) ? (n2.advanceCodePoint(), consumeEscapedCodePoint(e5, n2)) : n2.advanceCodePoint();
    }
  }
  function consumeUrlToken(n2, t2) {
    for (; isWhitespace(t2.codePointSource[t2.cursor]); ) t2.advanceCodePoint();
    let i2 = "";
    for (; ; ) {
      if (void 0 === t2.codePointSource[t2.cursor]) {
        const o2 = [G.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: i2 }];
        return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", "Unexpected EOF"], o2)), o2;
      }
      if (t2.codePointSource[t2.cursor] === F) return t2.advanceCodePoint(), [G.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: i2 }];
      if (isWhitespace(t2.codePointSource[t2.cursor])) {
        for (t2.advanceCodePoint(); isWhitespace(t2.codePointSource[t2.cursor]); ) t2.advanceCodePoint();
        if (void 0 === t2.codePointSource[t2.cursor]) {
          const o2 = [G.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: i2 }];
          return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", "Consume as much whitespace as possible", "Unexpected EOF"], o2)), o2;
        }
        return t2.codePointSource[t2.cursor] === F ? (t2.advanceCodePoint(), [G.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: i2 }]) : (consumeBadURL(n2, t2), [G.BadURL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, void 0]);
      }
      if (t2.codePointSource[t2.cursor] === A || t2.codePointSource[t2.cursor] === o || t2.codePointSource[t2.cursor] === E || ((s2 = t2.codePointSource[t2.cursor]) === I || s2 === d || D <= s2 && s2 <= r || b <= s2 && s2 <= f)) {
        consumeBadURL(n2, t2);
        const o2 = [G.BadURL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, void 0];
        return n2.onParseError(new ParseErrorWithToken(e.UnexpectedCharacterInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", `Unexpected U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point`], o2)), o2;
      }
      if (t2.codePointSource[t2.cursor] === W) {
        if (checkIfTwoCodePointsAreAValidEscape(t2)) {
          t2.advanceCodePoint(), i2 += String.fromCodePoint(consumeEscapedCodePoint(n2, t2));
          continue;
        }
        consumeBadURL(n2, t2);
        const o2 = [G.BadURL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, void 0];
        return n2.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"], o2)), o2;
      }
      i2 += String.fromCodePoint(t2.codePointSource[t2.cursor]), t2.advanceCodePoint();
    }
    var s2;
  }
  function consumeIdentLikeToken(e5, n2) {
    const t2 = consumeIdentSequence(e5, n2);
    if (n2.codePointSource[n2.cursor] !== E) return [G.Ident, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...t2) }];
    if (checkIfCodePointsMatchURLIdent(t2)) {
      n2.advanceCodePoint();
      let r3 = 0;
      for (; ; ) {
        const e6 = isWhitespace(n2.codePointSource[n2.cursor]), i2 = isWhitespace(n2.codePointSource[n2.cursor + 1]);
        if (e6 && i2) {
          r3 += 1, n2.advanceCodePoint(1);
          continue;
        }
        const s2 = e6 ? n2.codePointSource[n2.cursor + 1] : n2.codePointSource[n2.cursor];
        if (s2 === A || s2 === o) return r3 > 0 && n2.unreadCodePoint(r3), [G.Function, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...t2) }];
        break;
      }
      return consumeUrlToken(e5, n2);
    }
    return n2.advanceCodePoint(), [G.Function, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...t2) }];
  }
  function checkIfThreeCodePointsWouldStartAUnicodeRange(e5) {
    return !(e5.codePointSource[e5.cursor] !== V && e5.codePointSource[e5.cursor] !== K || e5.codePointSource[e5.cursor + 1] !== L || e5.codePointSource[e5.cursor + 2] !== _ && !isHexDigitCodePoint(e5.codePointSource[e5.cursor + 2]));
  }
  function consumeUnicodeRangeToken(e5, n2) {
    n2.advanceCodePoint(2);
    const o2 = [], t2 = [];
    for (; void 0 !== n2.codePointSource[n2.cursor] && o2.length < 6 && isHexDigitCodePoint(n2.codePointSource[n2.cursor]); ) o2.push(n2.codePointSource[n2.cursor]), n2.advanceCodePoint();
    for (; void 0 !== n2.codePointSource[n2.cursor] && o2.length < 6 && n2.codePointSource[n2.cursor] === _; ) 0 === t2.length && t2.push(...o2), o2.push(j), t2.push(Q), n2.advanceCodePoint();
    if (!t2.length && n2.codePointSource[n2.cursor] === l && isHexDigitCodePoint(n2.codePointSource[n2.cursor + 1])) for (n2.advanceCodePoint(); void 0 !== n2.codePointSource[n2.cursor] && t2.length < 6 && isHexDigitCodePoint(n2.codePointSource[n2.cursor]); ) t2.push(n2.codePointSource[n2.cursor]), n2.advanceCodePoint();
    if (!t2.length) {
      const e6 = parseInt(String.fromCodePoint(...o2), 16);
      return [G.UnicodeRange, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { startOfRange: e6, endOfRange: e6 }];
    }
    const r3 = parseInt(String.fromCodePoint(...o2), 16), i2 = parseInt(String.fromCodePoint(...t2), 16);
    return [G.UnicodeRange, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { startOfRange: r3, endOfRange: i2 }];
  }
  function tokenizer(n2, t2) {
    const r3 = n2.css.valueOf(), d2 = n2.unicodeRangesAllowed ?? false, p4 = new Reader(r3), C4 = { onParseError: t2?.onParseError ?? noop };
    return { nextToken: function nextToken() {
      p4.resetRepresentation();
      const n3 = p4.codePointSource[p4.cursor];
      if (void 0 === n3) return [G.EOF, "", -1, -1, void 0];
      if (n3 === B && checkIfTwoCodePointsStartAComment(p4)) return consumeComment(C4, p4);
      if (d2 && (n3 === V || n3 === K) && checkIfThreeCodePointsWouldStartAUnicodeRange(p4)) return consumeUnicodeRangeToken(0, p4);
      if (isIdentStartCodePoint(n3)) return consumeIdentLikeToken(C4, p4);
      if (isDigitCodePoint(n3)) return consumeNumericToken(C4, p4);
      switch (n3) {
        case a:
          return p4.advanceCodePoint(), [G.Comma, ",", p4.representationStart, p4.representationEnd, void 0];
        case c:
          return p4.advanceCodePoint(), [G.Colon, ":", p4.representationStart, p4.representationEnd, void 0];
        case N:
          return p4.advanceCodePoint(), [G.Semicolon, ";", p4.representationStart, p4.representationEnd, void 0];
        case E:
          return p4.advanceCodePoint(), [G.OpenParen, "(", p4.representationStart, p4.representationEnd, void 0];
        case F:
          return p4.advanceCodePoint(), [G.CloseParen, ")", p4.representationStart, p4.representationEnd, void 0];
        case T:
          return p4.advanceCodePoint(), [G.OpenSquare, "[", p4.representationStart, p4.representationEnd, void 0];
        case q:
          return p4.advanceCodePoint(), [G.CloseSquare, "]", p4.representationStart, p4.representationEnd, void 0];
        case k:
          return p4.advanceCodePoint(), [G.OpenCurly, "{", p4.representationStart, p4.representationEnd, void 0];
        case y:
          return p4.advanceCodePoint(), [G.CloseCurly, "}", p4.representationStart, p4.representationEnd, void 0];
        case o:
        case A:
          return consumeStringToken(C4, p4);
        case R:
          return consumeHashToken(C4, p4);
        case L:
        case S:
          return checkIfThreeCodePointsWouldStartANumber(p4) ? consumeNumericToken(C4, p4) : (p4.advanceCodePoint(), [G.Delim, p4.source[p4.representationStart], p4.representationStart, p4.representationEnd, { value: p4.source[p4.representationStart] }]);
        case g:
        case i:
        case P:
        case s:
        case H:
          return consumeWhiteSpace(p4);
        case l:
          return checkIfThreeCodePointsWouldStartANumber(p4) ? consumeNumericToken(C4, p4) : checkIfThreeCodePointsWouldStartCDC(p4) ? (p4.advanceCodePoint(3), [G.CDC, "-->", p4.representationStart, p4.representationEnd, void 0]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, p4) ? consumeIdentLikeToken(C4, p4) : (p4.advanceCodePoint(), [G.Delim, "-", p4.representationStart, p4.representationEnd, { value: "-" }]);
        case v:
          return checkIfFourCodePointsWouldStartCDO(p4) ? (p4.advanceCodePoint(4), [G.CDO, "<!--", p4.representationStart, p4.representationEnd, void 0]) : (p4.advanceCodePoint(), [G.Delim, "<", p4.representationStart, p4.representationEnd, { value: "<" }]);
        case u:
          if (p4.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, p4)) {
            const e5 = consumeIdentSequence(C4, p4);
            return [G.AtKeyword, p4.source.slice(p4.representationStart, p4.representationEnd + 1), p4.representationStart, p4.representationEnd, { value: String.fromCodePoint(...e5) }];
          }
          return [G.Delim, "@", p4.representationStart, p4.representationEnd, { value: "@" }];
        case W: {
          if (checkIfTwoCodePointsAreAValidEscape(p4)) return consumeIdentLikeToken(C4, p4);
          p4.advanceCodePoint();
          const n4 = [G.Delim, "\\", p4.representationStart, p4.representationEnd, { value: "\\" }];
          return C4.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceAfterBackslash, p4.representationStart, p4.representationEnd, ["4.3.1. Consume a token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"], n4)), n4;
        }
      }
      return p4.advanceCodePoint(), [G.Delim, p4.source[p4.representationStart], p4.representationStart, p4.representationEnd, { value: p4.source[p4.representationStart] }];
    }, endOfFile: function endOfFile() {
      return void 0 === p4.codePointSource[p4.cursor];
    } };
  }
  function noop() {
  }
  !function(e5) {
    e5.Comment = "comment", e5.AtKeyword = "at-keyword-token", e5.BadString = "bad-string-token", e5.BadURL = "bad-url-token", e5.CDC = "CDC-token", e5.CDO = "CDO-token", e5.Colon = "colon-token", e5.Comma = "comma-token", e5.Delim = "delim-token", e5.Dimension = "dimension-token", e5.EOF = "EOF-token", e5.Function = "function-token", e5.Hash = "hash-token", e5.Ident = "ident-token", e5.Number = "number-token", e5.Percentage = "percentage-token", e5.Semicolon = "semicolon-token", e5.String = "string-token", e5.URL = "url-token", e5.Whitespace = "whitespace-token", e5.OpenParen = "(-token", e5.CloseParen = ")-token", e5.OpenSquare = "[-token", e5.CloseSquare = "]-token", e5.OpenCurly = "{-token", e5.CloseCurly = "}-token", e5.UnicodeRange = "unicode-range-token";
  }(G || (G = {})), function(e5) {
    e5.Integer = "integer", e5.Number = "number";
  }(X || (X = {})), function(e5) {
    e5.Unrestricted = "unrestricted", e5.ID = "id";
  }(Y || (Y = {}));
  var Z = Object.values(G);
  function isToken(e5) {
    return !!Array.isArray(e5) && (!(e5.length < 4) && (!!Z.includes(e5[0]) && ("string" == typeof e5[1] && ("number" == typeof e5[2] && "number" == typeof e5[3]))));
  }
  function isTokenWhiteSpaceOrComment(e5) {
    switch (e5[0]) {
      case G.Whitespace:
      case G.Comment:
        return true;
      default:
        return false;
    }
  }
  function isTokenColon(e5) {
    return !!e5 && e5[0] === G.Colon;
  }
  function isTokenComma(e5) {
    return !!e5 && e5[0] === G.Comma;
  }
  function isTokenComment(e5) {
    return !!e5 && e5[0] === G.Comment;
  }
  function isTokenDelim(e5) {
    return !!e5 && e5[0] === G.Delim;
  }
  function isTokenDimension(e5) {
    return !!e5 && e5[0] === G.Dimension;
  }
  function isTokenEOF(e5) {
    return !!e5 && e5[0] === G.EOF;
  }
  function isTokenFunction(e5) {
    return !!e5 && e5[0] === G.Function;
  }
  function isTokenIdent(e5) {
    return !!e5 && e5[0] === G.Ident;
  }
  function isTokenNumber(e5) {
    return !!e5 && e5[0] === G.Number;
  }
  function isTokenWhitespace(e5) {
    return !!e5 && e5[0] === G.Whitespace;
  }
  function isTokenOpenParen(e5) {
    return !!e5 && e5[0] === G.OpenParen;
  }
  function isTokenCloseParen(e5) {
    return !!e5 && e5[0] === G.CloseParen;
  }
  function isTokenOpenSquare(e5) {
    return !!e5 && e5[0] === G.OpenSquare;
  }
  function isTokenOpenCurly(e5) {
    return !!e5 && e5[0] === G.OpenCurly;
  }

  // node_modules/.pnpm/@csstools+css-parser-algorithms@2.7.1_@csstools+css-tokenizer@2.4.1/node_modules/@csstools/css-parser-algorithms/dist/index.mjs
  var f2;
  function walkerIndexGenerator(e5) {
    let n2 = e5.slice();
    return (e6, t2, o2) => {
      let s2 = -1;
      for (let i2 = n2.indexOf(t2); i2 < n2.length && (s2 = e6.indexOf(n2[i2]), -1 === s2 || s2 < o2); i2++) ;
      return -1 === s2 || s2 === o2 && t2 === e6[o2] && (s2++, s2 >= e6.length) ? -1 : (n2 = e6.slice(), s2);
    };
  }
  function consumeComponentValue(e5, n2) {
    const t2 = n2[0];
    if (isTokenOpenParen(t2) || isTokenOpenCurly(t2) || isTokenOpenSquare(t2)) {
      const t3 = consumeSimpleBlock(e5, n2);
      return { advance: t3.advance, node: t3.node };
    }
    if (isTokenFunction(t2)) {
      const t3 = consumeFunction(e5, n2);
      return { advance: t3.advance, node: t3.node };
    }
    if (isTokenWhitespace(t2)) {
      const t3 = consumeWhitespace(e5, n2);
      return { advance: t3.advance, node: t3.node };
    }
    if (isTokenComment(t2)) {
      const t3 = consumeComment2(e5, n2);
      return { advance: t3.advance, node: t3.node };
    }
    return { advance: 1, node: new TokenNode(t2) };
  }
  !function(e5) {
    e5.Function = "function", e5.SimpleBlock = "simple-block", e5.Whitespace = "whitespace", e5.Comment = "comment", e5.Token = "token";
  }(f2 || (f2 = {}));
  var ContainerNodeBaseClass = class {
    value = [];
    indexOf(e5) {
      return this.value.indexOf(e5);
    }
    at(e5) {
      if ("number" == typeof e5) return e5 < 0 && (e5 = this.value.length + e5), this.value[e5];
    }
    forEach(e5, n2) {
      if (0 === this.value.length) return;
      const t2 = walkerIndexGenerator(this.value);
      let o2 = 0;
      for (; o2 < this.value.length; ) {
        const s2 = this.value[o2];
        let i2;
        if (n2 && (i2 = { ...n2 }), false === e5({ node: s2, parent: this, state: i2 }, o2)) return false;
        if (o2 = t2(this.value, s2, o2), -1 === o2) break;
      }
    }
    walk(e5, n2) {
      0 !== this.value.length && this.forEach((n3, t2) => false !== e5(n3, t2) && ((!("walk" in n3.node) || !this.value.includes(n3.node) || false !== n3.node.walk(e5, n3.state)) && void 0), n2);
    }
  };
  var FunctionNode = class _FunctionNode extends ContainerNodeBaseClass {
    type = f2.Function;
    name;
    endToken;
    constructor(e5, n2, t2) {
      super(), this.name = e5, this.endToken = n2, this.value = t2;
    }
    getName() {
      return this.name[4].value;
    }
    normalize() {
      isTokenEOF(this.endToken) && (this.endToken = [G.CloseParen, ")", -1, -1, void 0]);
    }
    tokens() {
      return isTokenEOF(this.endToken) ? [this.name, ...this.value.flatMap((e5) => e5.tokens())] : [this.name, ...this.value.flatMap((e5) => e5.tokens()), this.endToken];
    }
    toString() {
      const e5 = this.value.map((e6) => isToken(e6) ? stringify(e6) : e6.toString()).join("");
      return stringify(this.name) + e5 + stringify(this.endToken);
    }
    toJSON() {
      return { type: this.type, name: this.getName(), tokens: this.tokens(), value: this.value.map((e5) => e5.toJSON()) };
    }
    isFunctionNode() {
      return _FunctionNode.isFunctionNode(this);
    }
    static isFunctionNode(e5) {
      return !!e5 && (e5 instanceof _FunctionNode && e5.type === f2.Function);
    }
  };
  function consumeFunction(n2, t2) {
    const o2 = [];
    let s2 = 1;
    for (; ; ) {
      const i2 = t2[s2];
      if (!i2 || isTokenEOF(i2)) return n2.onParseError(new ParseError("Unexpected EOF while consuming a function.", t2[0][2], t2[t2.length - 1][3], ["5.4.9. Consume a function", "Unexpected EOF"])), { advance: t2.length, node: new FunctionNode(t2[0], i2, o2) };
      if (isTokenCloseParen(i2)) return { advance: s2 + 1, node: new FunctionNode(t2[0], i2, o2) };
      if (isTokenWhiteSpaceOrComment(i2)) {
        const e5 = consumeAllCommentsAndWhitespace(n2, t2.slice(s2));
        s2 += e5.advance, o2.push(...e5.nodes);
        continue;
      }
      const r3 = consumeComponentValue(n2, t2.slice(s2));
      s2 += r3.advance, o2.push(r3.node);
    }
  }
  var SimpleBlockNode = class _SimpleBlockNode extends ContainerNodeBaseClass {
    type = f2.SimpleBlock;
    startToken;
    endToken;
    constructor(e5, n2, t2) {
      super(), this.startToken = e5, this.endToken = n2, this.value = t2;
    }
    normalize() {
      if (isTokenEOF(this.endToken)) {
        const e5 = mirrorVariant(this.startToken);
        e5 && (this.endToken = e5);
      }
    }
    tokens() {
      return isTokenEOF(this.endToken) ? [this.startToken, ...this.value.flatMap((e5) => e5.tokens())] : [this.startToken, ...this.value.flatMap((e5) => e5.tokens()), this.endToken];
    }
    toString() {
      const e5 = this.value.map((e6) => isToken(e6) ? stringify(e6) : e6.toString()).join("");
      return stringify(this.startToken) + e5 + stringify(this.endToken);
    }
    toJSON() {
      return { type: this.type, startToken: this.startToken, tokens: this.tokens(), value: this.value.map((e5) => e5.toJSON()) };
    }
    isSimpleBlockNode() {
      return _SimpleBlockNode.isSimpleBlockNode(this);
    }
    static isSimpleBlockNode(e5) {
      return !!e5 && (e5 instanceof _SimpleBlockNode && e5.type === f2.SimpleBlock);
    }
  };
  function consumeSimpleBlock(n2, t2) {
    const o2 = mirrorVariantType(t2[0][0]);
    if (!o2) throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
    const s2 = [];
    let i2 = 1;
    for (; ; ) {
      const r3 = t2[i2];
      if (!r3 || isTokenEOF(r3)) return n2.onParseError(new ParseError("Unexpected EOF while consuming a simple block.", t2[0][2], t2[t2.length - 1][3], ["5.4.8. Consume a simple block", "Unexpected EOF"])), { advance: t2.length, node: new SimpleBlockNode(t2[0], r3, s2) };
      if (r3[0] === o2) return { advance: i2 + 1, node: new SimpleBlockNode(t2[0], r3, s2) };
      if (isTokenWhiteSpaceOrComment(r3)) {
        const e5 = consumeAllCommentsAndWhitespace(n2, t2.slice(i2));
        i2 += e5.advance, s2.push(...e5.nodes);
        continue;
      }
      const a2 = consumeComponentValue(n2, t2.slice(i2));
      i2 += a2.advance, s2.push(a2.node);
    }
  }
  var WhitespaceNode = class _WhitespaceNode {
    type = f2.Whitespace;
    value;
    constructor(e5) {
      this.value = e5;
    }
    tokens() {
      return this.value;
    }
    toString() {
      return stringify(...this.value);
    }
    toJSON() {
      return { type: this.type, tokens: this.tokens() };
    }
    isWhitespaceNode() {
      return _WhitespaceNode.isWhitespaceNode(this);
    }
    static isWhitespaceNode(e5) {
      return !!e5 && (e5 instanceof _WhitespaceNode && e5.type === f2.Whitespace);
    }
  };
  function consumeWhitespace(e5, n2) {
    let t2 = 0;
    for (; ; ) {
      const e6 = n2[t2];
      if (!isTokenWhitespace(e6)) return { advance: t2, node: new WhitespaceNode(n2.slice(0, t2)) };
      t2++;
    }
  }
  var CommentNode = class _CommentNode {
    type = f2.Comment;
    value;
    constructor(e5) {
      this.value = e5;
    }
    tokens() {
      return [this.value];
    }
    toString() {
      return stringify(this.value);
    }
    toJSON() {
      return { type: this.type, tokens: this.tokens() };
    }
    isCommentNode() {
      return _CommentNode.isCommentNode(this);
    }
    static isCommentNode(e5) {
      return !!e5 && (e5 instanceof _CommentNode && e5.type === f2.Comment);
    }
  };
  function consumeComment2(e5, n2) {
    return { advance: 1, node: new CommentNode(n2[0]) };
  }
  function consumeAllCommentsAndWhitespace(e5, n2) {
    const t2 = [];
    let o2 = 0;
    for (; ; ) if (isTokenWhitespace(n2[o2])) {
      const e6 = consumeWhitespace(0, n2.slice(o2));
      o2 += e6.advance, t2.push(e6.node);
    } else {
      if (!isTokenComment(n2[o2])) return { advance: o2, nodes: t2 };
      t2.push(new CommentNode(n2[o2])), o2++;
    }
  }
  var TokenNode = class _TokenNode {
    type = f2.Token;
    value;
    constructor(e5) {
      this.value = e5;
    }
    tokens() {
      return [this.value];
    }
    toString() {
      return this.value[1];
    }
    toJSON() {
      return { type: this.type, tokens: this.tokens() };
    }
    isTokenNod() {
      return _TokenNode.isTokenNode(this);
    }
    static isTokenNode(e5) {
      return !!e5 && (e5 instanceof _TokenNode && e5.type === f2.Token);
    }
  };
  function parseCommaSeparatedListOfComponentValues(t2, o2) {
    const s2 = { onParseError: o2?.onParseError ?? (() => {
    }) }, i2 = [...t2];
    if (0 === t2.length) return [];
    isTokenEOF(i2[i2.length - 1]) && i2.push([G.EOF, "", i2[i2.length - 1][2], i2[i2.length - 1][3], void 0]);
    const r3 = [];
    let a2 = [], c3 = 0;
    for (; ; ) {
      if (!i2[c3] || isTokenEOF(i2[c3])) return a2.length && r3.push(a2), r3;
      if (isTokenComma(i2[c3])) {
        r3.push(a2), a2 = [], c3++;
        continue;
      }
      const n2 = consumeComponentValue(s2, t2.slice(c3));
      a2.push(n2.node), c3 += n2.advance;
    }
  }
  function isSimpleBlockNode(e5) {
    return SimpleBlockNode.isSimpleBlockNode(e5);
  }
  function isFunctionNode(e5) {
    return FunctionNode.isFunctionNode(e5);
  }
  function isWhitespaceNode(e5) {
    return WhitespaceNode.isWhitespaceNode(e5);
  }
  function isCommentNode(e5) {
    return CommentNode.isCommentNode(e5);
  }
  function isWhiteSpaceOrCommentNode(e5) {
    return isWhitespaceNode(e5) || isCommentNode(e5);
  }
  function isTokenNode(e5) {
    return TokenNode.isTokenNode(e5);
  }

  // node_modules/.pnpm/@csstools+media-query-list-parser@2.1.13_@csstools+css-parser-algorithms@2.7.1_@csstools+css-_mog6yulxq2u6n424uhd5svp2wq/node_modules/@csstools/media-query-list-parser/dist/index.mjs
  var O2;
  !function(e5) {
    e5.CustomMedia = "custom-media", e5.GeneralEnclosed = "general-enclosed", e5.MediaAnd = "media-and", e5.MediaCondition = "media-condition", e5.MediaConditionListWithAnd = "media-condition-list-and", e5.MediaConditionListWithOr = "media-condition-list-or", e5.MediaFeature = "media-feature", e5.MediaFeatureBoolean = "mf-boolean", e5.MediaFeatureName = "mf-name", e5.MediaFeaturePlain = "mf-plain", e5.MediaFeatureRangeNameValue = "mf-range-name-value", e5.MediaFeatureRangeValueName = "mf-range-value-name", e5.MediaFeatureRangeValueNameValue = "mf-range-value-name-value", e5.MediaFeatureValue = "mf-value", e5.MediaInParens = "media-in-parens", e5.MediaNot = "media-not", e5.MediaOr = "media-or", e5.MediaQueryWithType = "media-query-with-type", e5.MediaQueryWithoutType = "media-query-without-type", e5.MediaQueryInvalid = "media-query-invalid";
  }(O2 || (O2 = {}));
  var MediaCondition = class _MediaCondition {
    type = O2.MediaCondition;
    media;
    constructor(e5) {
      this.media = e5;
    }
    tokens() {
      return this.media.tokens();
    }
    toString() {
      return this.media.toString();
    }
    indexOf(e5) {
      return e5 === this.media ? "media" : -1;
    }
    at(e5) {
      if ("media" === e5) return this.media;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.media, parent: this, state: i2 }, "media") && this.media.walk(e5, i2);
    }
    toJSON() {
      return { type: this.type, media: this.media.toJSON() };
    }
    isMediaCondition() {
      return _MediaCondition.isMediaCondition(this);
    }
    static isMediaCondition(e5) {
      return !!e5 && (e5 instanceof _MediaCondition && e5.type === O2.MediaCondition);
    }
  };
  var MediaInParens = class _MediaInParens {
    type = O2.MediaInParens;
    media;
    before;
    after;
    constructor(e5, t2 = [], i2 = []) {
      this.media = e5, this.before = t2, this.after = i2;
    }
    tokens() {
      return [...this.before, ...this.media.tokens(), ...this.after];
    }
    toString() {
      return stringify(...this.before) + this.media.toString() + stringify(...this.after);
    }
    indexOf(e5) {
      return e5 === this.media ? "media" : -1;
    }
    at(e5) {
      if ("media" === e5) return this.media;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.media, parent: this, state: i2 }, "media") && ("walk" in this.media ? this.media.walk(e5, i2) : void 0);
    }
    toJSON() {
      return { type: this.type, media: this.media.toJSON(), before: this.before, after: this.after };
    }
    isMediaInParens() {
      return _MediaInParens.isMediaInParens(this);
    }
    static isMediaInParens(e5) {
      return !!e5 && (e5 instanceof _MediaInParens && e5.type === O2.MediaInParens);
    }
  };
  var MediaQueryWithType = class _MediaQueryWithType {
    type = O2.MediaQueryWithType;
    modifier;
    mediaType;
    and = void 0;
    media = void 0;
    constructor(e5, t2, i2, a2) {
      this.modifier = e5, this.mediaType = t2, i2 && a2 && (this.and = i2, this.media = a2);
    }
    getModifier() {
      if (!this.modifier.length) return "";
      for (let e5 = 0; e5 < this.modifier.length; e5++) {
        const t2 = this.modifier[e5];
        if (isTokenIdent(t2)) return t2[4].value;
      }
      return "";
    }
    negateQuery() {
      const e5 = new _MediaQueryWithType([...this.modifier], [...this.mediaType], this.and, this.media);
      if (0 === e5.modifier.length) return e5.modifier = [[G.Ident, "not", -1, -1, { value: "not" }], [G.Whitespace, " ", -1, -1, void 0]], e5;
      for (let t2 = 0; t2 < e5.modifier.length; t2++) {
        const i2 = e5.modifier[t2];
        if (isTokenIdent(i2) && "not" === i2[4].value.toLowerCase()) {
          e5.modifier.splice(t2, 1);
          break;
        }
        if (isTokenIdent(i2) && "only" === i2[4].value.toLowerCase()) {
          i2[1] = "not", i2[4].value = "not";
          break;
        }
      }
      return e5;
    }
    getMediaType() {
      if (!this.mediaType.length) return "";
      for (let e5 = 0; e5 < this.mediaType.length; e5++) {
        const t2 = this.mediaType[e5];
        if (isTokenIdent(t2)) return t2[4].value;
      }
      return "";
    }
    tokens() {
      return this.and && this.media ? [...this.modifier, ...this.mediaType, ...this.and, ...this.media.tokens()] : [...this.modifier, ...this.mediaType];
    }
    toString() {
      return this.and && this.media ? stringify(...this.modifier) + stringify(...this.mediaType) + stringify(...this.and) + this.media.toString() : stringify(...this.modifier) + stringify(...this.mediaType);
    }
    indexOf(e5) {
      return e5 === this.media ? "media" : -1;
    }
    at(e5) {
      if ("media" === e5) return this.media;
    }
    walk(e5, t2) {
      let i2;
      if (t2 && (i2 = { ...t2 }), this.media) return false !== e5({ node: this.media, parent: this, state: i2 }, "media") && this.media.walk(e5, i2);
    }
    toJSON() {
      return { type: this.type, string: this.toString(), modifier: this.modifier, mediaType: this.mediaType, and: this.and, media: this.media };
    }
    isMediaQueryWithType() {
      return _MediaQueryWithType.isMediaQueryWithType(this);
    }
    static isMediaQueryWithType(e5) {
      return !!e5 && (e5 instanceof _MediaQueryWithType && e5.type === O2.MediaQueryWithType);
    }
  };
  var MediaQueryWithoutType = class _MediaQueryWithoutType {
    type = O2.MediaQueryWithoutType;
    media;
    constructor(e5) {
      this.media = e5;
    }
    negateQuery() {
      let e5 = this.media;
      if (e5.media.type === O2.MediaNot) return new _MediaQueryWithoutType(new MediaCondition(e5.media.media));
      e5.media.type === O2.MediaConditionListWithOr && (e5 = new MediaCondition(new MediaInParens(e5, [[G.Whitespace, " ", 0, 0, void 0], [G.OpenParen, "(", 0, 0, void 0]], [[G.CloseParen, ")", 0, 0, void 0]])));
      return new MediaQueryWithType([[G.Ident, "not", 0, 0, { value: "not" }], [G.Whitespace, " ", 0, 0, void 0]], [[G.Ident, "all", 0, 0, { value: "all" }], [G.Whitespace, " ", 0, 0, void 0]], [[G.Ident, "and", 0, 0, { value: "and" }]], e5);
    }
    tokens() {
      return this.media.tokens();
    }
    toString() {
      return this.media.toString();
    }
    indexOf(e5) {
      return e5 === this.media ? "media" : -1;
    }
    at(e5) {
      if ("media" === e5) return this.media;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.media, parent: this, state: i2 }, "media") && this.media.walk(e5, i2);
    }
    toJSON() {
      return { type: this.type, string: this.toString(), media: this.media };
    }
    isMediaQueryWithoutType() {
      return _MediaQueryWithoutType.isMediaQueryWithoutType(this);
    }
    static isMediaQueryWithoutType(e5) {
      return !!e5 && (e5 instanceof _MediaQueryWithoutType && e5.type === O2.MediaQueryWithoutType);
    }
  };
  var MediaQueryInvalid = class _MediaQueryInvalid {
    type = O2.MediaQueryInvalid;
    media;
    constructor(e5) {
      this.media = e5;
    }
    negateQuery() {
      return new _MediaQueryInvalid(this.media);
    }
    tokens() {
      return this.media.flatMap((e5) => e5.tokens());
    }
    toString() {
      return this.media.map((e5) => e5.toString()).join("");
    }
    walk(t2, i2) {
      if (0 === this.media.length) return;
      const a2 = walkerIndexGenerator(this.media);
      let n2 = 0;
      for (; n2 < this.media.length; ) {
        const e5 = this.media[n2];
        let r3;
        if (i2 && (r3 = { ...i2 }), false === t2({ node: e5, parent: this, state: r3 }, n2)) return false;
        if ("walk" in e5 && this.media.includes(e5) && false === e5.walk(t2, r3)) return false;
        if (n2 = a2(this.media, e5, n2), -1 === n2) break;
      }
    }
    toJSON() {
      return { type: this.type, string: this.toString(), media: this.media };
    }
    isMediaQueryInvalid() {
      return _MediaQueryInvalid.isMediaQueryInvalid(this);
    }
    static isMediaQueryInvalid(e5) {
      return !!e5 && (e5 instanceof _MediaQueryInvalid && e5.type === O2.MediaQueryInvalid);
    }
  };
  var GeneralEnclosed = class _GeneralEnclosed {
    type = O2.GeneralEnclosed;
    value;
    constructor(e5) {
      this.value = e5;
    }
    tokens() {
      return this.value.tokens();
    }
    toString() {
      return this.value.toString();
    }
    indexOf(e5) {
      return e5 === this.value ? "value" : -1;
    }
    at(e5) {
      if ("value" === e5) return this.value;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.value, parent: this, state: i2 }, "value") && ("walk" in this.value ? this.value.walk(e5, i2) : void 0);
    }
    toJSON() {
      return { type: this.type, tokens: this.tokens() };
    }
    isGeneralEnclosed() {
      return _GeneralEnclosed.isGeneralEnclosed(this);
    }
    static isGeneralEnclosed(e5) {
      return !!e5 && (e5 instanceof _GeneralEnclosed && e5.type === O2.GeneralEnclosed);
    }
  };
  var MediaAnd = class _MediaAnd {
    type = O2.MediaAnd;
    modifier;
    media;
    constructor(e5, t2) {
      this.modifier = e5, this.media = t2;
    }
    tokens() {
      return [...this.modifier, ...this.media.tokens()];
    }
    toString() {
      return stringify(...this.modifier) + this.media.toString();
    }
    indexOf(e5) {
      return e5 === this.media ? "media" : -1;
    }
    at(e5) {
      return "media" === e5 ? this.media : null;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.media, parent: this, state: i2 }, "media") && this.media.walk(e5, i2);
    }
    toJSON() {
      return { type: this.type, modifier: this.modifier, media: this.media.toJSON() };
    }
    isMediaAnd() {
      return _MediaAnd.isMediaAnd(this);
    }
    static isMediaAnd(e5) {
      return !!e5 && (e5 instanceof _MediaAnd && e5.type === O2.MediaAnd);
    }
  };
  var MediaConditionListWithAnd = class _MediaConditionListWithAnd {
    type = O2.MediaConditionListWithAnd;
    leading;
    list;
    before;
    after;
    constructor(e5, t2, i2 = [], a2 = []) {
      this.leading = e5, this.list = t2, this.before = i2, this.after = a2;
    }
    tokens() {
      return [...this.before, ...this.leading.tokens(), ...this.list.flatMap((e5) => e5.tokens()), ...this.after];
    }
    toString() {
      return stringify(...this.before) + this.leading.toString() + this.list.map((e5) => e5.toString()).join("") + stringify(...this.after);
    }
    indexOf(e5) {
      return e5 === this.leading ? "leading" : e5.type === O2.MediaAnd ? this.list.indexOf(e5) : -1;
    }
    at(e5) {
      return "leading" === e5 ? this.leading : "number" == typeof e5 ? (e5 < 0 && (e5 = this.list.length + e5), this.list[e5]) : void 0;
    }
    walk(t2, i2) {
      let a2;
      if (i2 && (a2 = { ...i2 }), false === t2({ node: this.leading, parent: this, state: a2 }, "leading")) return false;
      if ("walk" in this.leading && false === this.leading.walk(t2, a2)) return false;
      if (0 === this.list.length) return;
      const n2 = walkerIndexGenerator(this.list);
      let r3 = 0;
      for (; r3 < this.list.length; ) {
        const e5 = this.list[r3];
        if (i2 && (a2 = { ...i2 }), false === t2({ node: e5, parent: this, state: a2 }, r3)) return false;
        if ("walk" in e5 && this.list.includes(e5) && false === e5.walk(t2, a2)) return false;
        if (r3 = n2(this.list, e5, r3), -1 === r3) break;
      }
    }
    toJSON() {
      return { type: this.type, leading: this.leading.toJSON(), list: this.list.map((e5) => e5.toJSON()), before: this.before, after: this.after };
    }
    isMediaConditionListWithAnd() {
      return _MediaConditionListWithAnd.isMediaConditionListWithAnd(this);
    }
    static isMediaConditionListWithAnd(e5) {
      return !!e5 && (e5 instanceof _MediaConditionListWithAnd && e5.type === O2.MediaConditionListWithAnd);
    }
  };
  var MediaConditionListWithOr = class _MediaConditionListWithOr {
    type = O2.MediaConditionListWithOr;
    leading;
    list;
    before;
    after;
    constructor(e5, t2, i2 = [], a2 = []) {
      this.leading = e5, this.list = t2, this.before = i2, this.after = a2;
    }
    tokens() {
      return [...this.before, ...this.leading.tokens(), ...this.list.flatMap((e5) => e5.tokens()), ...this.after];
    }
    toString() {
      return stringify(...this.before) + this.leading.toString() + this.list.map((e5) => e5.toString()).join("") + stringify(...this.after);
    }
    indexOf(e5) {
      return e5 === this.leading ? "leading" : e5.type === O2.MediaOr ? this.list.indexOf(e5) : -1;
    }
    at(e5) {
      return "leading" === e5 ? this.leading : "number" == typeof e5 ? (e5 < 0 && (e5 = this.list.length + e5), this.list[e5]) : void 0;
    }
    walk(t2, i2) {
      let a2;
      if (i2 && (a2 = { ...i2 }), false === t2({ node: this.leading, parent: this, state: a2 }, "leading")) return false;
      if ("walk" in this.leading && false === this.leading.walk(t2, a2)) return false;
      if (0 === this.list.length) return;
      const n2 = walkerIndexGenerator(this.list);
      let r3 = 0;
      for (; r3 < this.list.length; ) {
        const e5 = this.list[r3];
        if (i2 && (a2 = { ...i2 }), false === t2({ node: e5, parent: this, state: a2 }, r3)) return false;
        if ("walk" in e5 && this.list.includes(e5) && false === e5.walk(t2, a2)) return false;
        if (r3 = n2(this.list, e5, r3), -1 === r3) break;
      }
    }
    toJSON() {
      return { type: this.type, leading: this.leading.toJSON(), list: this.list.map((e5) => e5.toJSON()), before: this.before, after: this.after };
    }
    isMediaConditionListWithOr() {
      return _MediaConditionListWithOr.isMediaConditionListWithOr(this);
    }
    static isMediaConditionListWithOr(e5) {
      return !!e5 && (e5 instanceof _MediaConditionListWithOr && e5.type === O2.MediaConditionListWithOr);
    }
  };
  function isNumber(e5) {
    return !!(isTokenNode(e5) && isTokenNumber(e5.value) || isFunctionNode(e5) && T2.has(e5.getName().toLowerCase()));
  }
  var T2 = /* @__PURE__ */ new Set(["abs", "acos", "asin", "atan", "atan2", "calc", "clamp", "cos", "exp", "hypot", "log", "max", "min", "mod", "pow", "rem", "round", "sign", "sin", "sqrt", "tan"]);
  function isDimension(e5) {
    return isTokenNode(e5) && isTokenDimension(e5.value);
  }
  function isIdent(e5) {
    return isTokenNode(e5) && isTokenIdent(e5.value);
  }
  function isEnvironmentVariable(e5) {
    return isFunctionNode(e5) && "env" === e5.getName().toLowerCase();
  }
  var MediaFeatureName = class _MediaFeatureName {
    type = O2.MediaFeatureName;
    name;
    before;
    after;
    constructor(e5, t2 = [], i2 = []) {
      this.name = e5, this.before = t2, this.after = i2;
    }
    getName() {
      return this.name.value[4].value;
    }
    getNameToken() {
      return this.name.value;
    }
    tokens() {
      return [...this.before, ...this.name.tokens(), ...this.after];
    }
    toString() {
      return stringify(...this.before) + this.name.toString() + stringify(...this.after);
    }
    indexOf(e5) {
      return e5 === this.name ? "name" : -1;
    }
    at(e5) {
      if ("name" === e5) return this.name;
    }
    toJSON() {
      return { type: this.type, name: this.getName(), tokens: this.tokens() };
    }
    isMediaFeatureName() {
      return _MediaFeatureName.isMediaFeatureName(this);
    }
    static isMediaFeatureName(e5) {
      return !!e5 && (e5 instanceof _MediaFeatureName && e5.type === O2.MediaFeatureName);
    }
  };
  function parseMediaFeatureName(e5) {
    let t2 = -1;
    for (let i2 = 0; i2 < e5.length; i2++) {
      const n2 = e5[i2];
      if (n2.type !== f2.Whitespace && n2.type !== f2.Comment) {
        if (!isIdent(n2)) return false;
        if (-1 !== t2) return false;
        t2 = i2;
      }
    }
    return -1 !== t2 && new MediaFeatureName(e5[t2], e5.slice(0, t2).flatMap((e6) => e6.tokens()), e5.slice(t2 + 1).flatMap((e6) => e6.tokens()));
  }
  var MediaFeatureBoolean = class _MediaFeatureBoolean {
    type = O2.MediaFeatureBoolean;
    name;
    constructor(e5) {
      this.name = e5;
    }
    getName() {
      return this.name.getName();
    }
    getNameToken() {
      return this.name.getNameToken();
    }
    tokens() {
      return this.name.tokens();
    }
    toString() {
      return this.name.toString();
    }
    indexOf(e5) {
      return e5 === this.name ? "name" : -1;
    }
    at(e5) {
      if ("name" === e5) return this.name;
    }
    toJSON() {
      return { type: this.type, name: this.name.toJSON(), tokens: this.tokens() };
    }
    isMediaFeatureBoolean() {
      return _MediaFeatureBoolean.isMediaFeatureBoolean(this);
    }
    static isMediaFeatureBoolean(e5) {
      return !!e5 && (e5 instanceof _MediaFeatureBoolean && e5.type === O2.MediaFeatureBoolean);
    }
  };
  function parseMediaFeatureBoolean(e5) {
    const t2 = parseMediaFeatureName(e5);
    return false === t2 ? t2 : new MediaFeatureBoolean(t2);
  }
  var MediaFeatureValue = class _MediaFeatureValue {
    type = O2.MediaFeatureValue;
    value;
    before;
    after;
    constructor(e5, t2 = [], i2 = []) {
      Array.isArray(e5) && 1 === e5.length ? this.value = e5[0] : this.value = e5, this.before = t2, this.after = i2;
    }
    tokens() {
      return Array.isArray(this.value) ? [...this.before, ...this.value.flatMap((e5) => e5.tokens()), ...this.after] : [...this.before, ...this.value.tokens(), ...this.after];
    }
    toString() {
      return Array.isArray(this.value) ? stringify(...this.before) + this.value.map((e5) => e5.toString()).join("") + stringify(...this.after) : stringify(...this.before) + this.value.toString() + stringify(...this.after);
    }
    indexOf(e5) {
      return e5 === this.value ? "value" : -1;
    }
    at(e5) {
      return "value" === e5 ? this.value : Array.isArray(this.value) && "number" == typeof e5 ? (e5 < 0 && (e5 = this.value.length + e5), this.value[e5]) : void 0;
    }
    walk(t2, i2) {
      if (Array.isArray(this.value)) {
        if (0 === this.value.length) return;
        const a2 = walkerIndexGenerator(this.value);
        let n2 = 0;
        for (; n2 < this.value.length; ) {
          const e5 = this.value[n2];
          let r3;
          if (i2 && (r3 = { ...i2 }), false === t2({ node: e5, parent: this, state: r3 }, n2)) return false;
          if ("walk" in e5 && this.value.includes(e5) && false === e5.walk(t2, r3)) return false;
          if (n2 = a2(this.value, e5, n2), -1 === n2) break;
        }
      } else {
        let e5;
        if (i2 && (e5 = { ...i2 }), false === t2({ node: this.value, parent: this, state: e5 }, "value")) return false;
        if ("walk" in this.value) return this.value.walk(t2, e5);
      }
    }
    toJSON() {
      return Array.isArray(this.value) ? { type: this.type, value: this.value.map((e5) => e5.toJSON()), tokens: this.tokens() } : { type: this.type, value: this.value.toJSON(), tokens: this.tokens() };
    }
    isMediaFeatureValue() {
      return _MediaFeatureValue.isMediaFeatureValue(this);
    }
    static isMediaFeatureValue(e5) {
      return !!e5 && (e5 instanceof _MediaFeatureValue && e5.type === O2.MediaFeatureValue);
    }
  };
  function parseMediaFeatureValue(e5, t2 = false) {
    let i2 = -1, n2 = -1;
    for (let r3 = 0; r3 < e5.length; r3++) {
      const s2 = e5[r3];
      if (s2.type !== f2.Whitespace && s2.type !== f2.Comment) {
        if (-1 !== i2) return false;
        if (isNumber(s2)) {
          const t3 = matchesRatioExactly(e5.slice(r3));
          if (-1 !== t3) {
            i2 = t3[0] + r3, n2 = t3[1] + r3, r3 += t3[1] - t3[0];
            continue;
          }
          i2 = r3, n2 = r3;
        } else if (isEnvironmentVariable(s2)) i2 = r3, n2 = r3;
        else if (isDimension(s2)) i2 = r3, n2 = r3;
        else {
          if (t2 || !isIdent(s2)) return false;
          i2 = r3, n2 = r3;
        }
      }
    }
    return -1 !== i2 && new MediaFeatureValue(e5.slice(i2, n2 + 1), e5.slice(0, i2).flatMap((e6) => e6.tokens()), e5.slice(n2 + 1).flatMap((e6) => e6.tokens()));
  }
  function matchesRatioExactly(e5) {
    let t2 = -1, i2 = -1;
    const a2 = matchesRatio(e5);
    if (-1 === a2) return -1;
    t2 = a2[0], i2 = a2[1];
    for (let t3 = i2 + 1; t3 < e5.length; t3++) {
      const i3 = e5[t3];
      if (!isWhiteSpaceOrCommentNode(i3)) return -1;
    }
    return [t2, i2];
  }
  function matchesRatio(e5) {
    let i2 = -1, a2 = -1;
    for (let r3 = 0; r3 < e5.length; r3++) {
      const s2 = e5[r3];
      if (!isWhiteSpaceOrCommentNode(s2)) {
        if (isTokenNode(s2)) {
          const e6 = s2.value;
          if (isTokenDelim(e6) && "/" === e6[4].value) {
            if (-1 === i2) return -1;
            if (-1 !== a2) return -1;
            a2 = r3;
            continue;
          }
        }
        if (!isNumber(s2)) return -1;
        if (-1 !== a2) return [i2, r3];
        if (-1 !== i2) return -1;
        i2 = r3;
      }
    }
    return -1;
  }
  var MediaFeaturePlain = class _MediaFeaturePlain {
    type = O2.MediaFeaturePlain;
    name;
    colon;
    value;
    constructor(e5, t2, i2) {
      this.name = e5, this.colon = t2, this.value = i2;
    }
    getName() {
      return this.name.getName();
    }
    getNameToken() {
      return this.name.getNameToken();
    }
    tokens() {
      return [...this.name.tokens(), this.colon, ...this.value.tokens()];
    }
    toString() {
      return this.name.toString() + stringify(this.colon) + this.value.toString();
    }
    indexOf(e5) {
      return e5 === this.name ? "name" : e5 === this.value ? "value" : -1;
    }
    at(e5) {
      return "name" === e5 ? this.name : "value" === e5 ? this.value : void 0;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.value, parent: this, state: i2 }, "value") && this.value.walk(e5, i2);
    }
    toJSON() {
      return { type: this.type, name: this.name.toJSON(), value: this.value.toJSON(), tokens: this.tokens() };
    }
    isMediaFeaturePlain() {
      return _MediaFeaturePlain.isMediaFeaturePlain(this);
    }
    static isMediaFeaturePlain(e5) {
      return !!e5 && (e5 instanceof _MediaFeaturePlain && e5.type === O2.MediaFeaturePlain);
    }
  };
  function parseMediaFeaturePlain(e5) {
    let t2 = [], i2 = [], n2 = null;
    for (let r4 = 0; r4 < e5.length; r4++) {
      const s3 = e5[r4];
      if (s3.type === f2.Token) {
        const a2 = s3.value;
        if (isTokenColon(a2)) {
          t2 = e5.slice(0, r4), i2 = e5.slice(r4 + 1), n2 = a2;
          break;
        }
      }
    }
    if (!t2.length || !i2.length || !n2) return false;
    const r3 = parseMediaFeatureName(t2);
    if (false === r3) return false;
    const s2 = parseMediaFeatureValue(i2);
    return false !== s2 && new MediaFeaturePlain(r3, n2, s2);
  }
  var C2;
  var S2;
  var Q2;
  var W2;
  function matchesComparison(e5) {
    let t2 = -1;
    for (let i2 = 0; i2 < e5.length; i2++) {
      const n2 = e5[i2];
      if (n2.type === f2.Token) {
        const e6 = n2.value;
        if (isTokenDelim(e6)) {
          if (e6[4].value === Q2.EQ) return -1 !== t2 ? [t2, i2] : [i2, i2];
          if (e6[4].value === C2.LT) {
            t2 = i2;
            continue;
          }
          if (e6[4].value === S2.GT) {
            t2 = i2;
            continue;
          }
        }
      }
      break;
    }
    return -1 !== t2 && [t2, t2];
  }
  function comparisonFromTokens(e5) {
    if (1 !== e5.length && 2 !== e5.length) return false;
    if (!isTokenDelim(e5[0])) return false;
    if (1 === e5.length) switch (e5[0][4].value) {
      case Q2.EQ:
        return Q2.EQ;
      case C2.LT:
        return C2.LT;
      case S2.GT:
        return S2.GT;
      default:
        return false;
    }
    if (!isTokenDelim(e5[1])) return false;
    if (e5[1][4].value !== Q2.EQ) return false;
    switch (e5[0][4].value) {
      case C2.LT:
        return C2.LT_OR_EQ;
      case S2.GT:
        return S2.GT_OR_EQ;
      default:
        return false;
    }
  }
  !function(e5) {
    e5.LT = "<", e5.LT_OR_EQ = "<=";
  }(C2 || (C2 = {})), function(e5) {
    e5.GT = ">", e5.GT_OR_EQ = ">=";
  }(S2 || (S2 = {})), function(e5) {
    e5.EQ = "=";
  }(Q2 || (Q2 = {}));
  var MediaFeatureRangeNameValue = class _MediaFeatureRangeNameValue {
    type = O2.MediaFeatureRangeNameValue;
    name;
    operator;
    value;
    constructor(e5, t2, i2) {
      this.name = e5, this.operator = t2, this.value = i2;
    }
    operatorKind() {
      return comparisonFromTokens(this.operator);
    }
    getName() {
      return this.name.getName();
    }
    getNameToken() {
      return this.name.getNameToken();
    }
    tokens() {
      return [...this.name.tokens(), ...this.operator, ...this.value.tokens()];
    }
    toString() {
      return this.name.toString() + stringify(...this.operator) + this.value.toString();
    }
    indexOf(e5) {
      return e5 === this.name ? "name" : e5 === this.value ? "value" : -1;
    }
    at(e5) {
      return "name" === e5 ? this.name : "value" === e5 ? this.value : void 0;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.value, parent: this, state: i2 }, "value") && ("walk" in this.value ? this.value.walk(e5, i2) : void 0);
    }
    toJSON() {
      return { type: this.type, name: this.name.toJSON(), value: this.value.toJSON(), tokens: this.tokens() };
    }
    isMediaFeatureRangeNameValue() {
      return _MediaFeatureRangeNameValue.isMediaFeatureRangeNameValue(this);
    }
    static isMediaFeatureRangeNameValue(e5) {
      return !!e5 && (e5 instanceof _MediaFeatureRangeNameValue && e5.type === O2.MediaFeatureRangeNameValue);
    }
  };
  var MediaFeatureRangeValueName = class _MediaFeatureRangeValueName {
    type = O2.MediaFeatureRangeValueName;
    name;
    operator;
    value;
    constructor(e5, t2, i2) {
      this.name = e5, this.operator = t2, this.value = i2;
    }
    operatorKind() {
      return comparisonFromTokens(this.operator);
    }
    getName() {
      return this.name.getName();
    }
    getNameToken() {
      return this.name.getNameToken();
    }
    tokens() {
      return [...this.value.tokens(), ...this.operator, ...this.name.tokens()];
    }
    toString() {
      return this.value.toString() + stringify(...this.operator) + this.name.toString();
    }
    indexOf(e5) {
      return e5 === this.name ? "name" : e5 === this.value ? "value" : -1;
    }
    at(e5) {
      return "name" === e5 ? this.name : "value" === e5 ? this.value : void 0;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.value, parent: this, state: i2 }, "value") && ("walk" in this.value ? this.value.walk(e5, i2) : void 0);
    }
    toJSON() {
      return { type: this.type, name: this.name.toJSON(), value: this.value.toJSON(), tokens: this.tokens() };
    }
    isMediaFeatureRangeValueName() {
      return _MediaFeatureRangeValueName.isMediaFeatureRangeValueName(this);
    }
    static isMediaFeatureRangeValueName(e5) {
      return !!e5 && (e5 instanceof _MediaFeatureRangeValueName && e5.type === O2.MediaFeatureRangeValueName);
    }
  };
  var MediaFeatureRangeValueNameValue = class _MediaFeatureRangeValueNameValue {
    type = O2.MediaFeatureRangeValueNameValue;
    name;
    valueOne;
    valueOneOperator;
    valueTwo;
    valueTwoOperator;
    constructor(e5, t2, i2, a2, n2) {
      this.name = e5, this.valueOne = t2, this.valueOneOperator = i2, this.valueTwo = a2, this.valueTwoOperator = n2;
    }
    valueOneOperatorKind() {
      return comparisonFromTokens(this.valueOneOperator);
    }
    valueTwoOperatorKind() {
      return comparisonFromTokens(this.valueTwoOperator);
    }
    getName() {
      return this.name.getName();
    }
    getNameToken() {
      return this.name.getNameToken();
    }
    tokens() {
      return [...this.valueOne.tokens(), ...this.valueOneOperator, ...this.name.tokens(), ...this.valueTwoOperator, ...this.valueTwo.tokens()];
    }
    toString() {
      return this.valueOne.toString() + stringify(...this.valueOneOperator) + this.name.toString() + stringify(...this.valueTwoOperator) + this.valueTwo.toString();
    }
    indexOf(e5) {
      return e5 === this.name ? "name" : e5 === this.valueOne ? "valueOne" : e5 === this.valueTwo ? "valueTwo" : -1;
    }
    at(e5) {
      return "name" === e5 ? this.name : "valueOne" === e5 ? this.valueOne : "valueTwo" === e5 ? this.valueTwo : void 0;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.valueOne, parent: this, state: i2 }, "valueOne") && ((!("walk" in this.valueOne) || false !== this.valueOne.walk(e5, i2)) && (t2 && (i2 = { ...t2 }), false !== e5({ node: this.valueTwo, parent: this, state: i2 }, "valueTwo") && ((!("walk" in this.valueTwo) || false !== this.valueTwo.walk(e5, i2)) && void 0)));
    }
    toJSON() {
      return { type: this.type, name: this.name.toJSON(), valueOne: this.valueOne.toJSON(), valueTwo: this.valueTwo.toJSON(), tokens: this.tokens() };
    }
    isMediaFeatureRangeValueNameValue() {
      return _MediaFeatureRangeValueNameValue.isMediaFeatureRangeValueNameValue(this);
    }
    static isMediaFeatureRangeValueNameValue(e5) {
      return !!e5 && (e5 instanceof _MediaFeatureRangeValueNameValue && e5.type === O2.MediaFeatureRangeValueNameValue);
    }
  };
  function parseMediaFeatureRange(e5) {
    let t2 = false, i2 = false;
    for (let n3 = 0; n3 < e5.length; n3++) {
      const r4 = e5[n3];
      if (r4.type === f2.Token) {
        const a2 = r4.value;
        if (isTokenDelim(a2)) {
          const a3 = matchesComparison(e5.slice(n3));
          if (false !== a3) {
            if (false !== t2) {
              i2 = [a3[0] + n3, a3[1] + n3];
              break;
            }
            t2 = [a3[0] + n3, a3[1] + n3], n3 += a3[1];
          }
        }
      }
    }
    if (false === t2) return false;
    const n2 = [e5[t2[0]].value];
    if (t2[0] !== t2[1] && n2.push(e5[t2[1]].value), false === i2) {
      const i3 = e5.slice(0, t2[0]), a2 = e5.slice(t2[1] + 1), r4 = parseMediaFeatureName(i3);
      if (r4) {
        const e6 = parseMediaFeatureValue(a2, true);
        return !!e6 && new MediaFeatureRangeNameValue(r4, n2, e6);
      }
      const s3 = parseMediaFeatureName(a2);
      if (s3) {
        const e6 = parseMediaFeatureValue(i3, true);
        return !!e6 && new MediaFeatureRangeValueName(s3, n2, e6);
      }
      return false;
    }
    const r3 = [e5[i2[0]].value];
    i2[0] !== i2[1] && r3.push(e5[i2[1]].value);
    const s2 = e5.slice(0, t2[0]), o2 = e5.slice(t2[1] + 1, i2[0]), u2 = e5.slice(i2[1] + 1), d2 = parseMediaFeatureValue(s2, true), l2 = parseMediaFeatureName(o2), h2 = parseMediaFeatureValue(u2, true);
    if (!d2 || !l2 || !h2) return false;
    {
      const e6 = comparisonFromTokens(n2);
      if (false === e6 || e6 === Q2.EQ) return false;
      const t3 = comparisonFromTokens(r3);
      if (false === t3 || t3 === Q2.EQ) return false;
      if (!(e6 !== C2.LT && e6 !== C2.LT_OR_EQ || t3 !== S2.GT && t3 !== S2.GT_OR_EQ)) return false;
      if (!(e6 !== S2.GT && e6 !== S2.GT_OR_EQ || t3 !== C2.LT && t3 !== C2.LT_OR_EQ)) return false;
    }
    return new MediaFeatureRangeValueNameValue(l2, d2, n2, h2, r3);
  }
  var MediaFeature = class _MediaFeature {
    type = O2.MediaFeature;
    feature;
    before;
    after;
    constructor(e5, t2 = [], i2 = []) {
      this.feature = e5, this.before = t2, this.after = i2;
    }
    getName() {
      return this.feature.getName();
    }
    getNameToken() {
      return this.feature.getNameToken();
    }
    tokens() {
      return [...this.before, ...this.feature.tokens(), ...this.after];
    }
    toString() {
      return stringify(...this.before) + this.feature.toString() + stringify(...this.after);
    }
    indexOf(e5) {
      return e5 === this.feature ? "feature" : -1;
    }
    at(e5) {
      if ("feature" === e5) return this.feature;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.feature, parent: this, state: i2 }, "feature") && ("walk" in this.feature ? this.feature.walk(e5, i2) : void 0);
    }
    toJSON() {
      return { type: this.type, feature: this.feature.toJSON(), before: this.before, after: this.after };
    }
    isMediaFeature() {
      return _MediaFeature.isMediaFeature(this);
    }
    static isMediaFeature(e5) {
      return !!e5 && (e5 instanceof _MediaFeature && e5.type === O2.MediaFeature);
    }
  };
  function parseMediaFeature(e5, t2 = [], i2 = []) {
    if (!isTokenOpenParen(e5.startToken)) return false;
    const a2 = parseMediaFeatureBoolean(e5.value);
    if (false !== a2) return new MediaFeature(a2, t2, i2);
    const n2 = parseMediaFeaturePlain(e5.value);
    if (false !== n2) return new MediaFeature(n2, t2, i2);
    const r3 = parseMediaFeatureRange(e5.value);
    return false !== r3 && new MediaFeature(r3, t2, i2);
  }
  var MediaNot = class _MediaNot {
    type = O2.MediaNot;
    modifier;
    media;
    constructor(e5, t2) {
      this.modifier = e5, this.media = t2;
    }
    tokens() {
      return [...this.modifier, ...this.media.tokens()];
    }
    toString() {
      return stringify(...this.modifier) + this.media.toString();
    }
    indexOf(e5) {
      return e5 === this.media ? "media" : -1;
    }
    at(e5) {
      if ("media" === e5) return this.media;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.media, parent: this, state: i2 }, "media") && this.media.walk(e5, i2);
    }
    toJSON() {
      return { type: this.type, modifier: this.modifier, media: this.media.toJSON() };
    }
    isMediaNot() {
      return _MediaNot.isMediaNot(this);
    }
    static isMediaNot(e5) {
      return !!e5 && (e5 instanceof _MediaNot && e5.type === O2.MediaNot);
    }
  };
  var MediaOr = class _MediaOr {
    type = O2.MediaOr;
    modifier;
    media;
    constructor(e5, t2) {
      this.modifier = e5, this.media = t2;
    }
    tokens() {
      return [...this.modifier, ...this.media.tokens()];
    }
    toString() {
      return stringify(...this.modifier) + this.media.toString();
    }
    indexOf(e5) {
      return e5 === this.media ? "media" : -1;
    }
    at(e5) {
      if ("media" === e5) return this.media;
    }
    walk(e5, t2) {
      let i2;
      return t2 && (i2 = { ...t2 }), false !== e5({ node: this.media, parent: this, state: i2 }, "media") && this.media.walk(e5, i2);
    }
    toJSON() {
      return { type: this.type, modifier: this.modifier, media: this.media.toJSON() };
    }
    isMediaOr() {
      return _MediaOr.isMediaOr(this);
    }
    static isMediaOr(e5) {
      return !!e5 && (e5 instanceof _MediaOr && e5.type === O2.MediaOr);
    }
  };
  function modifierFromToken(e5) {
    if (!isTokenIdent(e5)) return false;
    switch (e5[4].value.toLowerCase()) {
      case W2.Not:
        return W2.Not;
      case W2.Only:
        return W2.Only;
      default:
        return false;
    }
  }
  function parseMediaQuery(e5) {
    {
      const t2 = parseMediaCondition(e5);
      if (false !== t2) return new MediaQueryWithoutType(t2);
    }
    {
      let i2 = -1, a2 = -1, n2 = -1;
      for (let r4 = 0; r4 < e5.length; r4++) {
        const s3 = e5[r4];
        if (!isWhitespaceNode(s3) && !isCommentNode(s3)) {
          if (isTokenNode(s3)) {
            const t2 = s3.value;
            if (-1 === i2 && isTokenIdent(t2) && modifierFromToken(t2)) {
              i2 = r4;
              continue;
            }
            if (-1 === a2 && isTokenIdent(t2) && !modifierFromToken(t2)) {
              a2 = r4;
              continue;
            }
            if (-1 === n2 && isTokenIdent(t2) && R2.test(t2[4].value)) {
              n2 = r4;
              if (false === parseMediaConditionWithoutOr(e5.slice(r4 + 1))) return false;
              break;
            }
            return false;
          }
          return false;
        }
      }
      let r3 = [], s2 = [];
      -1 !== i2 ? (r3 = e5.slice(0, i2 + 1).flatMap((e6) => e6.tokens()), -1 !== a2 && (s2 = e5.slice(i2 + 1, a2 + 1).flatMap((e6) => e6.tokens()))) : -1 !== a2 && (s2 = e5.slice(0, a2 + 1).flatMap((e6) => e6.tokens()));
      const d2 = parseMediaConditionWithoutOr(e5.slice(Math.max(i2, a2, n2) + 1));
      return false === d2 ? new MediaQueryWithType(r3, [...s2, ...e5.slice(a2 + 1).flatMap((e6) => e6.tokens())]) : new MediaQueryWithType(r3, s2, e5.slice(a2 + 1, n2 + 1).flatMap((e6) => e6.tokens()), d2);
    }
  }
  function parseMediaConditionListWithOr(e5) {
    let t2 = false;
    const i2 = [];
    let n2 = -1, r3 = -1;
    for (let s2 = 0; s2 < e5.length; s2++) {
      if (t2) {
        const t3 = parseMediaOr(e5.slice(s2));
        if (false !== t3) {
          s2 += t3.advance, i2.push(t3.node), r3 = s2;
          continue;
        }
      }
      const o2 = e5[s2];
      if (o2.type !== f2.Whitespace && o2.type !== f2.Comment) {
        if (t2) return false;
        if (false !== t2 || !isSimpleBlockNode(o2)) return false;
        if (o2.normalize(), t2 = parseMediaInParensFromSimpleBlock(o2), false === t2) return false;
        n2 = s2;
      }
    }
    return !(!t2 || !i2.length) && new MediaConditionListWithOr(t2, i2, e5.slice(0, n2).flatMap((e6) => e6.tokens()), e5.slice(r3 + 1).flatMap((e6) => e6.tokens()));
  }
  function parseMediaConditionListWithAnd(e5) {
    let t2 = false;
    const i2 = [];
    let n2 = -1, r3 = -1;
    for (let s2 = 0; s2 < e5.length; s2++) {
      if (t2) {
        const t3 = parseMediaAnd(e5.slice(s2));
        if (false !== t3) {
          s2 += t3.advance, i2.push(t3.node), r3 = s2;
          continue;
        }
      }
      const o2 = e5[s2];
      if (o2.type !== f2.Whitespace && o2.type !== f2.Comment) {
        if (t2) return false;
        if (false !== t2 || !isSimpleBlockNode(o2)) return false;
        if (o2.normalize(), t2 = parseMediaInParensFromSimpleBlock(o2), false === t2) return false;
        n2 = s2;
      }
    }
    return !(!t2 || !i2.length) && new MediaConditionListWithAnd(t2, i2, e5.slice(0, n2).flatMap((e6) => e6.tokens()), e5.slice(r3 + 1).flatMap((e6) => e6.tokens()));
  }
  function parseMediaCondition(e5) {
    const t2 = parseMediaNot(e5);
    if (false !== t2) return new MediaCondition(t2);
    const i2 = parseMediaConditionListWithAnd(e5);
    if (false !== i2) return new MediaCondition(i2);
    const a2 = parseMediaConditionListWithOr(e5);
    if (false !== a2) return new MediaCondition(a2);
    const n2 = parseMediaInParens(e5);
    return false !== n2 && new MediaCondition(n2);
  }
  function parseMediaConditionWithoutOr(e5) {
    const t2 = parseMediaNot(e5);
    if (false !== t2) return new MediaCondition(t2);
    const i2 = parseMediaConditionListWithAnd(e5);
    if (false !== i2) return new MediaCondition(i2);
    const a2 = parseMediaInParens(e5);
    return false !== a2 && new MediaCondition(a2);
  }
  function parseMediaInParens(e5) {
    let t2 = -1;
    for (let i3 = 0; i3 < e5.length; i3++) {
      const n3 = e5[i3];
      if (n3.type !== f2.Whitespace && n3.type !== f2.Comment) {
        if (!isSimpleBlockNode(n3)) return false;
        if (-1 !== t2) return false;
        t2 = i3;
      }
    }
    if (-1 === t2) return false;
    const i2 = e5[t2];
    if (!isTokenOpenParen(i2.startToken)) return false;
    i2.normalize();
    const n2 = [...e5.slice(0, t2).flatMap((e6) => e6.tokens()), i2.startToken], r3 = [i2.endToken, ...e5.slice(t2 + 1).flatMap((e6) => e6.tokens())], s2 = parseMediaFeature(i2, n2, r3);
    if (false !== s2) return new MediaInParens(s2);
    const o2 = parseMediaCondition(i2.value);
    return false !== o2 ? new MediaInParens(o2, n2, r3) : new MediaInParens(new GeneralEnclosed(i2), e5.slice(0, t2).flatMap((e6) => e6.tokens()), e5.slice(t2 + 1).flatMap((e6) => e6.tokens()));
  }
  function parseMediaInParensFromSimpleBlock(e5) {
    if (!isTokenOpenParen(e5.startToken)) return false;
    const t2 = parseMediaFeature(e5, [e5.startToken], [e5.endToken]);
    if (false !== t2) return new MediaInParens(t2);
    const i2 = parseMediaCondition(e5.value);
    return false !== i2 ? new MediaInParens(i2, [e5.startToken], [e5.endToken]) : new MediaInParens(new GeneralEnclosed(e5));
  }
  !function(e5) {
    e5.Not = "not", e5.Only = "only";
  }(W2 || (W2 = {}));
  var V2 = /^not$/i;
  function parseMediaNot(e5) {
    let t2 = false, i2 = null;
    for (let n2 = 0; n2 < e5.length; n2++) {
      const r3 = e5[n2];
      if (r3.type !== f2.Whitespace && r3.type !== f2.Comment) {
        if (isIdent(r3)) {
          const e6 = r3.value;
          if (V2.test(e6[4].value)) {
            if (t2) return false;
            t2 = true;
            continue;
          }
          return false;
        }
        if (!t2 || !isSimpleBlockNode(r3)) return false;
        {
          r3.normalize();
          const t3 = parseMediaInParensFromSimpleBlock(r3);
          if (false === t3) return false;
          i2 = new MediaNot(e5.slice(0, n2).flatMap((e6) => e6.tokens()), t3);
        }
      }
    }
    return i2 || false;
  }
  var L2 = /^or$/i;
  function parseMediaOr(e5) {
    let t2 = false;
    for (let i2 = 0; i2 < e5.length; i2++) {
      const n2 = e5[i2];
      if (n2.type !== f2.Whitespace && n2.type !== f2.Comment) {
        if (isIdent(n2)) {
          const e6 = n2.value;
          if (L2.test(e6[4].value)) {
            if (t2) return false;
            t2 = true;
            continue;
          }
          return false;
        }
        if (t2 && isSimpleBlockNode(n2)) {
          n2.normalize();
          const t3 = parseMediaInParensFromSimpleBlock(n2);
          return false !== t3 && { advance: i2, node: new MediaOr(e5.slice(0, i2).flatMap((e6) => e6.tokens()), t3) };
        }
        return false;
      }
    }
    return false;
  }
  var R2 = /^and$/i;
  function parseMediaAnd(e5) {
    let t2 = false;
    for (let i2 = 0; i2 < e5.length; i2++) {
      const n2 = e5[i2];
      if (n2.type !== f2.Whitespace && n2.type !== f2.Comment) {
        if (isIdent(n2)) {
          const e6 = n2.value;
          if (R2.test(e6[4].value)) {
            if (t2) return false;
            t2 = true;
            continue;
          }
          return false;
        }
        if (t2 && isSimpleBlockNode(n2)) {
          n2.normalize();
          const t3 = parseMediaInParensFromSimpleBlock(n2);
          return false !== t3 && { advance: i2, node: new MediaAnd(e5.slice(0, i2).flatMap((e6) => e6.tokens()), t3) };
        }
        return false;
      }
    }
    return false;
  }
  function parseFromTokens(e5, t2) {
    const i2 = parseCommaSeparatedListOfComponentValues(e5, { onParseError: t2?.onParseError });
    return i2.map((e6, a2) => {
      const n2 = parseMediaQuery(e6);
      return false === n2 && true === t2?.preserveInvalidMediaQueries ? new MediaQueryInvalid(i2[a2]) : n2;
    }).filter((e6) => !!e6);
  }
  function parse(e5, t2) {
    const i2 = tokenizer({ css: e5 }, { onParseError: t2?.onParseError }), a2 = [];
    for (; !i2.endOfFile(); ) a2.push(i2.nextToken());
    return a2.push(i2.nextToken()), parseFromTokens(a2, t2);
  }
  var P2;
  !function(e5) {
    e5.All = "all", e5.Print = "print", e5.Screen = "screen", e5.Tty = "tty", e5.Tv = "tv", e5.Projection = "projection", e5.Handheld = "handheld", e5.Braille = "braille", e5.Embossed = "embossed", e5.Aural = "aural", e5.Speech = "speech";
  }(P2 || (P2 = {}));

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rgb/parseNumber.js
  var parseNumber = (color2, len) => {
    if (typeof color2 !== "number") return;
    if (len === 3) {
      return {
        mode: "rgb",
        r: (color2 >> 8 & 15 | color2 >> 4 & 240) / 255,
        g: (color2 >> 4 & 15 | color2 & 240) / 255,
        b: (color2 & 15 | color2 << 4 & 240) / 255
      };
    }
    if (len === 4) {
      return {
        mode: "rgb",
        r: (color2 >> 12 & 15 | color2 >> 8 & 240) / 255,
        g: (color2 >> 8 & 15 | color2 >> 4 & 240) / 255,
        b: (color2 >> 4 & 15 | color2 & 240) / 255,
        alpha: (color2 & 15 | color2 << 4 & 240) / 255
      };
    }
    if (len === 6) {
      return {
        mode: "rgb",
        r: (color2 >> 16 & 255) / 255,
        g: (color2 >> 8 & 255) / 255,
        b: (color2 & 255) / 255
      };
    }
    if (len === 8) {
      return {
        mode: "rgb",
        r: (color2 >> 24 & 255) / 255,
        g: (color2 >> 16 & 255) / 255,
        b: (color2 >> 8 & 255) / 255,
        alpha: (color2 & 255) / 255
      };
    }
  };
  var parseNumber_default = parseNumber;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/colors/named.js
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    // Added in CSS Colors Level 4:
    // https://drafts.csswg.org/css-color/#changes-from-3
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  var named_default = named;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rgb/parseNamed.js
  var parseNamed = (color2) => {
    return parseNumber_default(named_default[color2.toLowerCase()], 6);
  };
  var parseNamed_default = parseNamed;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rgb/parseHex.js
  var hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
  var parseHex = (color2) => {
    let match;
    return (match = color2.match(hex)) ? parseNumber_default(parseInt(match[1], 16), match[1].length) : void 0;
  };
  var parseHex_default = parseHex;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/util/regex.js
  var num = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
  var num_none = `(?:${num}|none)`;
  var per = `${num}%`;
  var per_none = `(?:${num}%|none)`;
  var num_per = `(?:${num}%|${num})`;
  var num_per_none = `(?:${num}%|${num}|none)`;
  var hue = `(?:${num}(deg|grad|rad|turn)|${num})`;
  var hue_none = `(?:${num}(deg|grad|rad|turn)|${num}|none)`;
  var c2 = `\\s*,\\s*`;
  var rx_num_per_none = new RegExp("^" + num_per_none + "$");

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rgb/parseRgbLegacy.js
  var rgb_num_old = new RegExp(
    `^rgba?\\(\\s*${num}${c2}${num}${c2}${num}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
  );
  var rgb_per_old = new RegExp(
    `^rgba?\\(\\s*${per}${c2}${per}${c2}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
  );
  var parseRgbLegacy = (color2) => {
    let res = { mode: "rgb" };
    let match;
    if (match = color2.match(rgb_num_old)) {
      if (match[1] !== void 0) {
        res.r = match[1] / 255;
      }
      if (match[2] !== void 0) {
        res.g = match[2] / 255;
      }
      if (match[3] !== void 0) {
        res.b = match[3] / 255;
      }
    } else if (match = color2.match(rgb_per_old)) {
      if (match[1] !== void 0) {
        res.r = match[1] / 100;
      }
      if (match[2] !== void 0) {
        res.g = match[2] / 100;
      }
      if (match[3] !== void 0) {
        res.b = match[3] / 100;
      }
    } else {
      return void 0;
    }
    if (match[4] !== void 0) {
      res.alpha = Math.max(0, Math.min(1, match[4] / 100));
    } else if (match[5] !== void 0) {
      res.alpha = Math.max(0, Math.min(1, +match[5]));
    }
    return res;
  };
  var parseRgbLegacy_default = parseRgbLegacy;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/_prepare.js
  var prepare = (color2, mode) => color2 === void 0 ? void 0 : typeof color2 !== "object" ? parse_default(color2) : color2.mode !== void 0 ? color2 : mode ? { ...color2, mode } : void 0;
  var prepare_default = prepare;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/converter.js
  var converter = (target_mode = "rgb") => (color2) => (color2 = prepare_default(color2, target_mode)) !== void 0 ? (
    // if the color's mode corresponds to our target mode
    color2.mode === target_mode ? (
      // then just return the color
      color2
    ) : (
      // otherwise check to see if we have a dedicated
      // converter for the target mode
      converters[color2.mode][target_mode] ? (
        // and return its result...
        converters[color2.mode][target_mode](color2)
      ) : (
        // ...otherwise pass through RGB as an intermediary step.
        // if the target mode is RGB...
        target_mode === "rgb" ? (
          // just return the RGB
          converters[color2.mode].rgb(color2)
        ) : (
          // otherwise convert color.mode -> RGB -> target_mode
          converters.rgb[target_mode](converters[color2.mode].rgb(color2))
        )
      )
    )
  ) : void 0;
  var converter_default = converter;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/modes.js
  var converters = {};
  var modes = {};
  var parsers = [];
  var colorProfiles = {};
  var identity = (v2) => v2;
  var useMode = (definition29) => {
    converters[definition29.mode] = {
      ...converters[definition29.mode],
      ...definition29.toMode
    };
    Object.keys(definition29.fromMode || {}).forEach((k5) => {
      if (!converters[k5]) {
        converters[k5] = {};
      }
      converters[k5][definition29.mode] = definition29.fromMode[k5];
    });
    if (!definition29.ranges) {
      definition29.ranges = {};
    }
    if (!definition29.difference) {
      definition29.difference = {};
    }
    definition29.channels.forEach((channel) => {
      if (definition29.ranges[channel] === void 0) {
        definition29.ranges[channel] = [0, 1];
      }
      if (!definition29.interpolate[channel]) {
        throw new Error(`Missing interpolator for: ${channel}`);
      }
      if (typeof definition29.interpolate[channel] === "function") {
        definition29.interpolate[channel] = {
          use: definition29.interpolate[channel]
        };
      }
      if (!definition29.interpolate[channel].fixup) {
        definition29.interpolate[channel].fixup = identity;
      }
    });
    modes[definition29.mode] = definition29;
    (definition29.parse || []).forEach((parser5) => {
      useParser(parser5, definition29.mode);
    });
    return converter_default(definition29.mode);
  };
  var getMode = (mode) => modes[mode];
  var useParser = (parser5, mode) => {
    if (typeof parser5 === "string") {
      if (!mode) {
        throw new Error(`'mode' required when 'parser' is a string`);
      }
      colorProfiles[parser5] = mode;
    } else if (typeof parser5 === "function") {
      if (parsers.indexOf(parser5) < 0) {
        parsers.push(parser5);
      }
    }
  };

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/parse.js
  var IdentStartCodePoint = /[^\x00-\x7F]|[a-zA-Z_]/;
  var IdentCodePoint = /[^\x00-\x7F]|[-\w]/;
  var Tok = {
    Function: "function",
    Ident: "ident",
    Number: "number",
    Percentage: "percentage",
    ParenClose: ")",
    None: "none",
    Hue: "hue",
    Alpha: "alpha"
  };
  var _i = 0;
  function is_num(chars) {
    let ch = chars[_i];
    let ch1 = chars[_i + 1];
    if (ch === "-" || ch === "+") {
      return /\d/.test(ch1) || ch1 === "." && /\d/.test(chars[_i + 2]);
    }
    if (ch === ".") {
      return /\d/.test(ch1);
    }
    return /\d/.test(ch);
  }
  function is_ident(chars) {
    if (_i >= chars.length) {
      return false;
    }
    let ch = chars[_i];
    if (IdentStartCodePoint.test(ch)) {
      return true;
    }
    if (ch === "-") {
      if (chars.length - _i < 2) {
        return false;
      }
      let ch1 = chars[_i + 1];
      if (ch1 === "-" || IdentStartCodePoint.test(ch1)) {
        return true;
      }
      return false;
    }
    return false;
  }
  var huenits = {
    deg: 1,
    rad: 180 / Math.PI,
    grad: 9 / 10,
    turn: 360
  };
  function num2(chars) {
    let value2 = "";
    if (chars[_i] === "-" || chars[_i] === "+") {
      value2 += chars[_i++];
    }
    value2 += digits(chars);
    if (chars[_i] === "." && /\d/.test(chars[_i + 1])) {
      value2 += chars[_i++] + digits(chars);
    }
    if (chars[_i] === "e" || chars[_i] === "E") {
      if ((chars[_i + 1] === "-" || chars[_i + 1] === "+") && /\d/.test(chars[_i + 2])) {
        value2 += chars[_i++] + chars[_i++] + digits(chars);
      } else if (/\d/.test(chars[_i + 1])) {
        value2 += chars[_i++] + digits(chars);
      }
    }
    if (is_ident(chars)) {
      let id = ident(chars);
      if (id === "deg" || id === "rad" || id === "turn" || id === "grad") {
        return { type: Tok.Hue, value: value2 * huenits[id] };
      }
      return void 0;
    }
    if (chars[_i] === "%") {
      _i++;
      return { type: Tok.Percentage, value: +value2 };
    }
    return { type: Tok.Number, value: +value2 };
  }
  function digits(chars) {
    let v2 = "";
    while (/\d/.test(chars[_i])) {
      v2 += chars[_i++];
    }
    return v2;
  }
  function ident(chars) {
    let v2 = "";
    while (_i < chars.length && IdentCodePoint.test(chars[_i])) {
      v2 += chars[_i++];
    }
    return v2;
  }
  function identlike(chars) {
    let v2 = ident(chars);
    if (chars[_i] === "(") {
      _i++;
      return { type: Tok.Function, value: v2 };
    }
    if (v2 === "none") {
      return { type: Tok.None, value: void 0 };
    }
    return { type: Tok.Ident, value: v2 };
  }
  function tokenize(str = "") {
    let chars = str.trim();
    let tokens = [];
    let ch;
    _i = 0;
    while (_i < chars.length) {
      ch = chars[_i++];
      if (ch === "\n" || ch === "	" || ch === " ") {
        while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) {
          _i++;
        }
        continue;
      }
      if (ch === ",") {
        return void 0;
      }
      if (ch === ")") {
        tokens.push({ type: Tok.ParenClose });
        continue;
      }
      if (ch === "+") {
        _i--;
        if (is_num(chars)) {
          tokens.push(num2(chars));
          continue;
        }
        return void 0;
      }
      if (ch === "-") {
        _i--;
        if (is_num(chars)) {
          tokens.push(num2(chars));
          continue;
        }
        if (is_ident(chars)) {
          tokens.push({ type: Tok.Ident, value: ident(chars) });
          continue;
        }
        return void 0;
      }
      if (ch === ".") {
        _i--;
        if (is_num(chars)) {
          tokens.push(num2(chars));
          continue;
        }
        return void 0;
      }
      if (ch === "/") {
        while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) {
          _i++;
        }
        let alpha;
        if (is_num(chars)) {
          alpha = num2(chars);
          if (alpha.type !== Tok.Hue) {
            tokens.push({ type: Tok.Alpha, value: alpha });
            continue;
          }
        }
        if (is_ident(chars)) {
          if (ident(chars) === "none") {
            tokens.push({
              type: Tok.Alpha,
              value: { type: Tok.None, value: void 0 }
            });
            continue;
          }
        }
        return void 0;
      }
      if (/\d/.test(ch)) {
        _i--;
        tokens.push(num2(chars));
        continue;
      }
      if (IdentStartCodePoint.test(ch)) {
        _i--;
        tokens.push(identlike(chars));
        continue;
      }
      return void 0;
    }
    return tokens;
  }
  function parseColorSyntax(tokens) {
    tokens._i = 0;
    let token = tokens[tokens._i++];
    if (!token || token.type !== Tok.Function || token.value !== "color") {
      return void 0;
    }
    token = tokens[tokens._i++];
    if (token.type !== Tok.Ident) {
      return void 0;
    }
    const mode = colorProfiles[token.value];
    if (!mode) {
      return void 0;
    }
    const res = { mode };
    const coords = consumeCoords(tokens, false);
    if (!coords) {
      return void 0;
    }
    const channels = getMode(mode).channels;
    for (let ii = 0, c3, ch; ii < channels.length; ii++) {
      c3 = coords[ii];
      ch = channels[ii];
      if (c3.type !== Tok.None) {
        res[ch] = c3.type === Tok.Number ? c3.value : c3.value / 100;
        if (ch === "alpha") {
          res[ch] = Math.max(0, Math.min(1, res[ch]));
        }
      }
    }
    return res;
  }
  function consumeCoords(tokens, includeHue) {
    const coords = [];
    let token;
    while (tokens._i < tokens.length) {
      token = tokens[tokens._i++];
      if (token.type === Tok.None || token.type === Tok.Number || token.type === Tok.Alpha || token.type === Tok.Percentage || includeHue && token.type === Tok.Hue) {
        coords.push(token);
        continue;
      }
      if (token.type === Tok.ParenClose) {
        if (tokens._i < tokens.length) {
          return void 0;
        }
        continue;
      }
      return void 0;
    }
    if (coords.length < 3 || coords.length > 4) {
      return void 0;
    }
    if (coords.length === 4) {
      if (coords[3].type !== Tok.Alpha) {
        return void 0;
      }
      coords[3] = coords[3].value;
    }
    if (coords.length === 3) {
      coords.push({ type: Tok.None, value: void 0 });
    }
    return coords.every((c3) => c3.type !== Tok.Alpha) ? coords : void 0;
  }
  function parseModernSyntax(tokens, includeHue) {
    tokens._i = 0;
    let token = tokens[tokens._i++];
    if (!token || token.type !== Tok.Function) {
      return void 0;
    }
    let coords = consumeCoords(tokens, includeHue);
    if (!coords) {
      return void 0;
    }
    coords.unshift(token.value);
    return coords;
  }
  var parse2 = (color2) => {
    if (typeof color2 !== "string") {
      return void 0;
    }
    const tokens = tokenize(color2);
    const parsed = tokens ? parseModernSyntax(tokens, true) : void 0;
    let result = void 0;
    let i2 = 0;
    let len = parsers.length;
    while (i2 < len) {
      if ((result = parsers[i2++](color2, parsed)) !== void 0) {
        return result;
      }
    }
    return tokens ? parseColorSyntax(tokens) : void 0;
  };
  var parse_default = parse2;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rgb/parseRgb.js
  function parseRgb(color2, parsed) {
    if (!parsed || parsed[0] !== "rgb" && parsed[0] !== "rgba") {
      return void 0;
    }
    const res = { mode: "rgb" };
    const [, r3, g2, b2, alpha] = parsed;
    if (r3.type === Tok.Hue || g2.type === Tok.Hue || b2.type === Tok.Hue) {
      return void 0;
    }
    if (r3.type !== Tok.None) {
      res.r = r3.type === Tok.Number ? r3.value / 255 : r3.value / 100;
    }
    if (g2.type !== Tok.None) {
      res.g = g2.type === Tok.Number ? g2.value / 255 : g2.value / 100;
    }
    if (b2.type !== Tok.None) {
      res.b = b2.type === Tok.Number ? b2.value / 255 : b2.value / 100;
    }
    if (alpha.type !== Tok.None) {
      res.alpha = Math.min(
        1,
        Math.max(
          0,
          alpha.type === Tok.Number ? alpha.value : alpha.value / 100
        )
      );
    }
    return res;
  }
  var parseRgb_default = parseRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rgb/parseTransparent.js
  var parseTransparent = (c3) => c3 === "transparent" ? { mode: "rgb", r: 0, g: 0, b: 0, alpha: 0 } : void 0;
  var parseTransparent_default = parseTransparent;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/interpolate/lerp.js
  var lerp = (a2, b2, t2) => a2 + t2 * (b2 - a2);

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/interpolate/piecewise.js
  var get_classes = (arr) => {
    let classes = [];
    for (let i2 = 0; i2 < arr.length - 1; i2++) {
      let a2 = arr[i2];
      let b2 = arr[i2 + 1];
      if (a2 === void 0 && b2 === void 0) {
        classes.push(void 0);
      } else if (a2 !== void 0 && b2 !== void 0) {
        classes.push([a2, b2]);
      } else {
        classes.push(a2 !== void 0 ? [a2, a2] : [b2, b2]);
      }
    }
    return classes;
  };
  var interpolatorPiecewise = (interpolator) => (arr) => {
    let classes = get_classes(arr);
    return (t2) => {
      let cls = t2 * classes.length;
      let idx = t2 >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);
      let pair = classes[idx];
      return pair === void 0 ? void 0 : interpolator(pair[0], pair[1], cls - idx);
    };
  };

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/interpolate/linear.js
  var interpolatorLinear = interpolatorPiecewise(lerp);

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/fixup/alpha.js
  var fixupAlpha = (arr) => {
    let some_defined = false;
    let res = arr.map((v2) => {
      if (v2 !== void 0) {
        some_defined = true;
        return v2;
      }
      return 1;
    });
    return some_defined ? res : arr;
  };

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rgb/definition.js
  var definition = {
    mode: "rgb",
    channels: ["r", "g", "b", "alpha"],
    parse: [
      parseRgb_default,
      parseHex_default,
      parseRgbLegacy_default,
      parseNamed_default,
      parseTransparent_default,
      "srgb"
    ],
    serialize: "srgb",
    interpolate: {
      r: interpolatorLinear,
      g: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    gamut: true,
    white: { r: 1, g: 1, b: 1 },
    black: { r: 0, g: 0, b: 0 }
  };
  var definition_default = definition;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/a98/convertA98ToXyz65.js
  var linearize = (v2 = 0) => Math.pow(Math.abs(v2), 563 / 256) * Math.sign(v2);
  var convertA98ToXyz65 = (a982) => {
    let r3 = linearize(a982.r);
    let g2 = linearize(a982.g);
    let b2 = linearize(a982.b);
    let res = {
      mode: "xyz65",
      x: 0.5766690429101305 * r3 + 0.1855582379065463 * g2 + 0.1882286462349947 * b2,
      y: 0.297344975250536 * r3 + 0.6273635662554661 * g2 + 0.0752914584939979 * b2,
      z: 0.0270313613864123 * r3 + 0.0706888525358272 * g2 + 0.9913375368376386 * b2
    };
    if (a982.alpha !== void 0) {
      res.alpha = a982.alpha;
    }
    return res;
  };
  var convertA98ToXyz65_default = convertA98ToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/a98/convertXyz65ToA98.js
  var gamma = (v2) => Math.pow(Math.abs(v2), 256 / 563) * Math.sign(v2);
  var convertXyz65ToA98 = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = {
      mode: "a98",
      r: gamma(
        x2 * 2.0415879038107465 - y2 * 0.5650069742788597 - 0.3447313507783297 * z2
      ),
      g: gamma(
        x2 * -0.9692436362808798 + y2 * 1.8759675015077206 + 0.0415550574071756 * z2
      ),
      b: gamma(
        x2 * 0.0134442806320312 - y2 * 0.1183623922310184 + 1.0151749943912058 * z2
      )
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToA98_default = convertXyz65ToA98;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lrgb/convertRgbToLrgb.js
  var fn = (c3 = 0) => {
    const abs2 = Math.abs(c3);
    if (abs2 <= 0.04045) {
      return c3 / 12.92;
    }
    return (Math.sign(c3) || 1) * Math.pow((abs2 + 0.055) / 1.055, 2.4);
  };
  var convertRgbToLrgb = ({ r: r3, g: g2, b: b2, alpha }) => {
    let res = {
      mode: "lrgb",
      r: fn(r3),
      g: fn(g2),
      b: fn(b2)
    };
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertRgbToLrgb_default = convertRgbToLrgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz65/convertRgbToXyz65.js
  var convertRgbToXyz65 = (rgb4) => {
    let { r: r3, g: g2, b: b2, alpha } = convertRgbToLrgb_default(rgb4);
    let res = {
      mode: "xyz65",
      x: 0.4123907992659593 * r3 + 0.357584339383878 * g2 + 0.1804807884018343 * b2,
      y: 0.2126390058715102 * r3 + 0.715168678767756 * g2 + 0.0721923153607337 * b2,
      z: 0.0193308187155918 * r3 + 0.119194779794626 * g2 + 0.9505321522496607 * b2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToXyz65_default = convertRgbToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lrgb/convertLrgbToRgb.js
  var fn2 = (c3 = 0) => {
    const abs2 = Math.abs(c3);
    if (abs2 > 31308e-7) {
      return (Math.sign(c3) || 1) * (1.055 * Math.pow(abs2, 1 / 2.4) - 0.055);
    }
    return c3 * 12.92;
  };
  var convertLrgbToRgb = ({ r: r3, g: g2, b: b2, alpha }, mode = "rgb") => {
    let res = {
      mode,
      r: fn2(r3),
      g: fn2(g2),
      b: fn2(b2)
    };
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertLrgbToRgb_default = convertLrgbToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz65/convertXyz65ToRgb.js
  var convertXyz65ToRgb = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = convertLrgbToRgb_default({
      r: x2 * 3.2409699419045226 - y2 * 1.537383177570094 - 0.4986107602930034 * z2,
      g: x2 * -0.9692436362808796 + y2 * 1.8759675015077204 + 0.0415550574071756 * z2,
      b: x2 * 0.0556300796969936 - y2 * 0.2039769588889765 + 1.0569715142428784 * z2
    });
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToRgb_default = convertXyz65ToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/a98/definition.js
  var definition2 = {
    ...definition_default,
    mode: "a98",
    parse: ["a98-rgb"],
    serialize: "a98-rgb",
    fromMode: {
      rgb: (color2) => convertXyz65ToA98_default(convertRgbToXyz65_default(color2)),
      xyz65: convertXyz65ToA98_default
    },
    toMode: {
      rgb: (color2) => convertXyz65ToRgb_default(convertA98ToXyz65_default(color2)),
      xyz65: convertA98ToXyz65_default
    }
  };
  var definition_default2 = definition2;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/util/normalizeHue.js
  var normalizeHue = (hue3) => (hue3 = hue3 % 360) < 0 ? hue3 + 360 : hue3;
  var normalizeHue_default = normalizeHue;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/fixup/hue.js
  var hue2 = (hues, fn5) => {
    return hues.map((hue3, idx, arr) => {
      if (hue3 === void 0) {
        return hue3;
      }
      let normalized = normalizeHue_default(hue3);
      if (idx === 0 || hues[idx - 1] === void 0) {
        return normalized;
      }
      return fn5(normalized - normalizeHue_default(arr[idx - 1]));
    }).reduce((acc, curr) => {
      if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {
        acc.push(curr);
        return acc;
      }
      acc.push(curr + acc[acc.length - 1]);
      return acc;
    }, []);
  };
  var fixupHueShorter = (arr) => hue2(arr, (d2) => Math.abs(d2) <= 180 ? d2 : d2 - 360 * Math.sign(d2));

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/cubehelix/constants.js
  var M2 = [-0.14861, 1.78277, -0.29227, -0.90649, 1.97294, 0];
  var degToRad = Math.PI / 180;
  var radToDeg = 180 / Math.PI;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/cubehelix/convertRgbToCubehelix.js
  var DE = M2[3] * M2[4];
  var BE = M2[1] * M2[4];
  var BCAD = M2[1] * M2[2] - M2[0] * M2[3];
  var convertRgbToCubehelix = ({ r: r3, g: g2, b: b2, alpha }) => {
    if (r3 === void 0) r3 = 0;
    if (g2 === void 0) g2 = 0;
    if (b2 === void 0) b2 = 0;
    let l2 = (BCAD * b2 + r3 * DE - g2 * BE) / (BCAD + DE - BE);
    let x2 = b2 - l2;
    let y2 = (M2[4] * (g2 - l2) - M2[2] * x2) / M2[3];
    let res = {
      mode: "cubehelix",
      l: l2,
      s: l2 === 0 || l2 === 1 ? void 0 : Math.sqrt(x2 * x2 + y2 * y2) / (M2[4] * l2 * (1 - l2))
    };
    if (res.s) res.h = Math.atan2(y2, x2) * radToDeg - 120;
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertRgbToCubehelix_default = convertRgbToCubehelix;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/cubehelix/convertCubehelixToRgb.js
  var convertCubehelixToRgb = ({ h: h2, s: s2, l: l2, alpha }) => {
    let res = { mode: "rgb" };
    h2 = (h2 === void 0 ? 0 : h2 + 120) * degToRad;
    if (l2 === void 0) l2 = 0;
    let amp = s2 === void 0 ? 0 : s2 * l2 * (1 - l2);
    let cosh = Math.cos(h2);
    let sinh = Math.sin(h2);
    res.r = l2 + amp * (M2[0] * cosh + M2[1] * sinh);
    res.g = l2 + amp * (M2[2] * cosh + M2[3] * sinh);
    res.b = l2 + amp * (M2[4] * cosh + M2[5] * sinh);
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertCubehelixToRgb_default = convertCubehelixToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/difference.js
  var differenceHueSaturation = (std, smp) => {
    if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) {
      return 0;
    }
    let std_h = normalizeHue_default(std.h);
    let smp_h = normalizeHue_default(smp.h);
    let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
    return 2 * Math.sqrt(std.s * smp.s) * dH;
  };
  var differenceHueNaive = (std, smp) => {
    if (std.h === void 0 || smp.h === void 0) {
      return 0;
    }
    let std_h = normalizeHue_default(std.h);
    let smp_h = normalizeHue_default(smp.h);
    if (Math.abs(smp_h - std_h) > 180) {
      return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));
    }
    return smp_h - std_h;
  };
  var differenceHueChroma = (std, smp) => {
    if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) {
      return 0;
    }
    let std_h = normalizeHue_default(std.h);
    let smp_h = normalizeHue_default(smp.h);
    let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
    return 2 * Math.sqrt(std.c * smp.c) * dH;
  };

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/average.js
  var averageAngle = (val) => {
    let sum = val.reduce(
      (sum2, val2) => {
        if (val2 !== void 0) {
          let rad = val2 * Math.PI / 180;
          sum2.sin += Math.sin(rad);
          sum2.cos += Math.cos(rad);
        }
        return sum2;
      },
      { sin: 0, cos: 0 }
    );
    let angle = Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;
    return angle < 0 ? 360 + angle : angle;
  };

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/cubehelix/definition.js
  var definition3 = {
    mode: "cubehelix",
    channels: ["h", "s", "l", "alpha"],
    parse: ["--cubehelix"],
    serialize: "--cubehelix",
    ranges: {
      h: [0, 360],
      s: [0, 4.614],
      l: [0, 1]
    },
    fromMode: {
      rgb: convertRgbToCubehelix_default
    },
    toMode: {
      rgb: convertCubehelixToRgb_default
    },
    interpolate: {
      h: {
        use: interpolatorLinear,
        fixup: fixupHueShorter
      },
      s: interpolatorLinear,
      l: interpolatorLinear,
      alpha: {
        use: interpolatorLinear,
        fixup: fixupAlpha
      }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default3 = definition3;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lch/convertLabToLch.js
  var convertLabToLch = ({ l: l2, a: a2, b: b2, alpha }, mode = "lch") => {
    if (a2 === void 0) a2 = 0;
    if (b2 === void 0) b2 = 0;
    let c3 = Math.sqrt(a2 * a2 + b2 * b2);
    let res = { mode, l: l2, c: c3 };
    if (c3) res.h = normalizeHue_default(Math.atan2(b2, a2) * 180 / Math.PI);
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertLabToLch_default = convertLabToLch;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lch/convertLchToLab.js
  var convertLchToLab = ({ l: l2, c: c3, h: h2, alpha }, mode = "lab") => {
    if (h2 === void 0) h2 = 0;
    let res = {
      mode,
      l: l2,
      a: c3 ? c3 * Math.cos(h2 / 180 * Math.PI) : 0,
      b: c3 ? c3 * Math.sin(h2 / 180 * Math.PI) : 0
    };
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertLchToLab_default = convertLchToLab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz65/constants.js
  var k2 = Math.pow(29, 3) / Math.pow(3, 3);
  var e2 = Math.pow(6, 3) / Math.pow(29, 3);

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/constants.js
  var D50 = {
    X: 0.3457 / 0.3585,
    Y: 1,
    Z: (1 - 0.3457 - 0.3585) / 0.3585
  };
  var D65 = {
    X: 0.3127 / 0.329,
    Y: 1,
    Z: (1 - 0.3127 - 0.329) / 0.329
  };
  var k3 = Math.pow(29, 3) / Math.pow(3, 3);
  var e3 = Math.pow(6, 3) / Math.pow(29, 3);

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab65/convertLab65ToXyz65.js
  var fn3 = (v2) => Math.pow(v2, 3) > e2 ? Math.pow(v2, 3) : (116 * v2 - 16) / k2;
  var convertLab65ToXyz65 = ({ l: l2, a: a2, b: b2, alpha }) => {
    if (l2 === void 0) l2 = 0;
    if (a2 === void 0) a2 = 0;
    if (b2 === void 0) b2 = 0;
    let fy = (l2 + 16) / 116;
    let fx = a2 / 500 + fy;
    let fz = fy - b2 / 200;
    let res = {
      mode: "xyz65",
      x: fn3(fx) * D65.X,
      y: fn3(fy) * D65.Y,
      z: fn3(fz) * D65.Z
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLab65ToXyz65_default = convertLab65ToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab65/convertLab65ToRgb.js
  var convertLab65ToRgb = (lab2) => convertXyz65ToRgb_default(convertLab65ToXyz65_default(lab2));
  var convertLab65ToRgb_default = convertLab65ToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab65/convertXyz65ToLab65.js
  var f3 = (value2) => value2 > e2 ? Math.cbrt(value2) : (k2 * value2 + 16) / 116;
  var convertXyz65ToLab65 = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let f0 = f3(x2 / D65.X);
    let f1 = f3(y2 / D65.Y);
    let f22 = f3(z2 / D65.Z);
    let res = {
      mode: "lab65",
      l: 116 * f1 - 16,
      a: 500 * (f0 - f1),
      b: 200 * (f1 - f22)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToLab65_default = convertXyz65ToLab65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab65/convertRgbToLab65.js
  var convertRgbToLab65 = (rgb4) => {
    let res = convertXyz65ToLab65_default(convertRgbToXyz65_default(rgb4));
    if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var convertRgbToLab65_default = convertRgbToLab65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/dlch/constants.js
  var kE = 1;
  var kCH = 1;
  var \u03B8 = 26 / 180 * Math.PI;
  var cos\u03B8 = Math.cos(\u03B8);
  var sin\u03B8 = Math.sin(\u03B8);
  var factor = 100 / Math.log(139 / 100);

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/dlch/convertDlchToLab65.js
  var convertDlchToLab65 = ({ l: l2, c: c3, h: h2, alpha }) => {
    if (l2 === void 0) l2 = 0;
    if (c3 === void 0) c3 = 0;
    if (h2 === void 0) h2 = 0;
    let res = {
      mode: "lab65",
      l: (Math.exp(l2 * kE / factor) - 1) / 39e-4
    };
    let G2 = (Math.exp(0.0435 * c3 * kCH * kE) - 1) / 0.075;
    let e5 = G2 * Math.cos(h2 / 180 * Math.PI - \u03B8);
    let f5 = G2 * Math.sin(h2 / 180 * Math.PI - \u03B8);
    res.a = e5 * cos\u03B8 - f5 / 0.83 * sin\u03B8;
    res.b = e5 * sin\u03B8 + f5 / 0.83 * cos\u03B8;
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertDlchToLab65_default = convertDlchToLab65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/dlch/convertLab65ToDlch.js
  var convertLab65ToDlch = ({ l: l2, a: a2, b: b2, alpha }) => {
    if (l2 === void 0) l2 = 0;
    if (a2 === void 0) a2 = 0;
    if (b2 === void 0) b2 = 0;
    let e5 = a2 * cos\u03B8 + b2 * sin\u03B8;
    let f5 = 0.83 * (b2 * cos\u03B8 - a2 * sin\u03B8);
    let G2 = Math.sqrt(e5 * e5 + f5 * f5);
    let res = {
      mode: "dlch",
      l: factor / kE * Math.log(1 + 39e-4 * l2),
      c: Math.log(1 + 0.075 * G2) / (0.0435 * kCH * kE)
    };
    if (res.c) {
      res.h = normalizeHue_default((Math.atan2(f5, e5) + \u03B8) / Math.PI * 180);
    }
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertLab65ToDlch_default = convertLab65ToDlch;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/dlab/definition.js
  var convertDlabToLab65 = (c3) => convertDlchToLab65_default(convertLabToLch_default(c3, "dlch"));
  var convertLab65ToDlab = (c3) => convertLchToLab_default(convertLab65ToDlch_default(c3), "dlab");
  var definition4 = {
    mode: "dlab",
    parse: ["--din99o-lab"],
    serialize: "--din99o-lab",
    toMode: {
      lab65: convertDlabToLab65,
      rgb: (c3) => convertLab65ToRgb_default(convertDlabToLab65(c3))
    },
    fromMode: {
      lab65: convertLab65ToDlab,
      rgb: (c3) => convertLab65ToDlab(convertRgbToLab65_default(c3))
    },
    channels: ["l", "a", "b", "alpha"],
    ranges: {
      l: [0, 100],
      a: [-40.09, 45.501],
      b: [-40.469, 44.344]
    },
    interpolate: {
      l: interpolatorLinear,
      a: interpolatorLinear,
      b: interpolatorLinear,
      alpha: {
        use: interpolatorLinear,
        fixup: fixupAlpha
      }
    }
  };
  var definition_default4 = definition4;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/dlch/definition.js
  var definition5 = {
    mode: "dlch",
    parse: ["--din99o-lch"],
    serialize: "--din99o-lch",
    toMode: {
      lab65: convertDlchToLab65_default,
      dlab: (c3) => convertLchToLab_default(c3, "dlab"),
      rgb: (c3) => convertLab65ToRgb_default(convertDlchToLab65_default(c3))
    },
    fromMode: {
      lab65: convertLab65ToDlch_default,
      dlab: (c3) => convertLabToLch_default(c3, "dlch"),
      rgb: (c3) => convertLab65ToDlch_default(convertRgbToLab65_default(c3))
    },
    channels: ["l", "c", "h", "alpha"],
    ranges: {
      l: [0, 100],
      c: [0, 51.484],
      h: [0, 360]
    },
    interpolate: {
      l: interpolatorLinear,
      c: interpolatorLinear,
      h: {
        use: interpolatorLinear,
        fixup: fixupHueShorter
      },
      alpha: {
        use: interpolatorLinear,
        fixup: fixupAlpha
      }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default5 = definition5;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsi/convertHsiToRgb.js
  function convertHsiToRgb({ h: h2, s: s2, i: i2, alpha }) {
    h2 = normalizeHue_default(h2 !== void 0 ? h2 : 0);
    if (s2 === void 0) s2 = 0;
    if (i2 === void 0) i2 = 0;
    let f5 = Math.abs(h2 / 60 % 2 - 1);
    let res;
    switch (Math.floor(h2 / 60)) {
      case 0:
        res = {
          r: i2 * (1 + s2 * (3 / (2 - f5) - 1)),
          g: i2 * (1 + s2 * (3 * (1 - f5) / (2 - f5) - 1)),
          b: i2 * (1 - s2)
        };
        break;
      case 1:
        res = {
          r: i2 * (1 + s2 * (3 * (1 - f5) / (2 - f5) - 1)),
          g: i2 * (1 + s2 * (3 / (2 - f5) - 1)),
          b: i2 * (1 - s2)
        };
        break;
      case 2:
        res = {
          r: i2 * (1 - s2),
          g: i2 * (1 + s2 * (3 / (2 - f5) - 1)),
          b: i2 * (1 + s2 * (3 * (1 - f5) / (2 - f5) - 1))
        };
        break;
      case 3:
        res = {
          r: i2 * (1 - s2),
          g: i2 * (1 + s2 * (3 * (1 - f5) / (2 - f5) - 1)),
          b: i2 * (1 + s2 * (3 / (2 - f5) - 1))
        };
        break;
      case 4:
        res = {
          r: i2 * (1 + s2 * (3 * (1 - f5) / (2 - f5) - 1)),
          g: i2 * (1 - s2),
          b: i2 * (1 + s2 * (3 / (2 - f5) - 1))
        };
        break;
      case 5:
        res = {
          r: i2 * (1 + s2 * (3 / (2 - f5) - 1)),
          g: i2 * (1 - s2),
          b: i2 * (1 + s2 * (3 * (1 - f5) / (2 - f5) - 1))
        };
        break;
      default:
        res = { r: i2 * (1 - s2), g: i2 * (1 - s2), b: i2 * (1 - s2) };
    }
    res.mode = "rgb";
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsi/convertRgbToHsi.js
  function convertRgbToHsi({ r: r3, g: g2, b: b2, alpha }) {
    if (r3 === void 0) r3 = 0;
    if (g2 === void 0) g2 = 0;
    if (b2 === void 0) b2 = 0;
    let M3 = Math.max(r3, g2, b2), m2 = Math.min(r3, g2, b2);
    let res = {
      mode: "hsi",
      s: r3 + g2 + b2 === 0 ? 0 : 1 - 3 * m2 / (r3 + g2 + b2),
      i: (r3 + g2 + b2) / 3
    };
    if (M3 - m2 !== 0)
      res.h = (M3 === r3 ? (g2 - b2) / (M3 - m2) + (g2 < b2) * 6 : M3 === g2 ? (b2 - r3) / (M3 - m2) + 2 : (r3 - g2) / (M3 - m2) + 4) * 60;
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsi/definition.js
  var definition6 = {
    mode: "hsi",
    toMode: {
      rgb: convertHsiToRgb
    },
    parse: ["--hsi"],
    serialize: "--hsi",
    fromMode: {
      rgb: convertRgbToHsi
    },
    channels: ["h", "s", "i", "alpha"],
    ranges: {
      h: [0, 360]
    },
    gamut: "rgb",
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      s: interpolatorLinear,
      i: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default6 = definition6;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsl/convertHslToRgb.js
  function convertHslToRgb({ h: h2, s: s2, l: l2, alpha }) {
    h2 = normalizeHue_default(h2 !== void 0 ? h2 : 0);
    if (s2 === void 0) s2 = 0;
    if (l2 === void 0) l2 = 0;
    let m1 = l2 + s2 * (l2 < 0.5 ? l2 : 1 - l2);
    let m2 = m1 - (m1 - l2) * 2 * Math.abs(h2 / 60 % 2 - 1);
    let res;
    switch (Math.floor(h2 / 60)) {
      case 0:
        res = { r: m1, g: m2, b: 2 * l2 - m1 };
        break;
      case 1:
        res = { r: m2, g: m1, b: 2 * l2 - m1 };
        break;
      case 2:
        res = { r: 2 * l2 - m1, g: m1, b: m2 };
        break;
      case 3:
        res = { r: 2 * l2 - m1, g: m2, b: m1 };
        break;
      case 4:
        res = { r: m2, g: 2 * l2 - m1, b: m1 };
        break;
      case 5:
        res = { r: m1, g: 2 * l2 - m1, b: m2 };
        break;
      default:
        res = { r: 2 * l2 - m1, g: 2 * l2 - m1, b: 2 * l2 - m1 };
    }
    res.mode = "rgb";
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsl/convertRgbToHsl.js
  function convertRgbToHsl({ r: r3, g: g2, b: b2, alpha }) {
    if (r3 === void 0) r3 = 0;
    if (g2 === void 0) g2 = 0;
    if (b2 === void 0) b2 = 0;
    let M3 = Math.max(r3, g2, b2), m2 = Math.min(r3, g2, b2);
    let res = {
      mode: "hsl",
      s: M3 === m2 ? 0 : (M3 - m2) / (1 - Math.abs(M3 + m2 - 1)),
      l: 0.5 * (M3 + m2)
    };
    if (M3 - m2 !== 0)
      res.h = (M3 === r3 ? (g2 - b2) / (M3 - m2) + (g2 < b2) * 6 : M3 === g2 ? (b2 - r3) / (M3 - m2) + 2 : (r3 - g2) / (M3 - m2) + 4) * 60;
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/util/hue.js
  var hueToDeg = (val, unit) => {
    switch (unit) {
      case "deg":
        return +val;
      case "rad":
        return val / Math.PI * 180;
      case "grad":
        return val / 10 * 9;
      case "turn":
        return val * 360;
    }
  };
  var hue_default = hueToDeg;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsl/parseHslLegacy.js
  var hsl_old = new RegExp(
    `^hsla?\\(\\s*${hue}${c2}${per}${c2}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
  );
  var parseHslLegacy = (color2) => {
    let match = color2.match(hsl_old);
    if (!match) return;
    let res = { mode: "hsl" };
    if (match[3] !== void 0) {
      res.h = +match[3];
    } else if (match[1] !== void 0 && match[2] !== void 0) {
      res.h = hue_default(match[1], match[2]);
    }
    if (match[4] !== void 0) {
      res.s = Math.min(Math.max(0, match[4] / 100), 1);
    }
    if (match[5] !== void 0) {
      res.l = Math.min(Math.max(0, match[5] / 100), 1);
    }
    if (match[6] !== void 0) {
      res.alpha = Math.max(0, Math.min(1, match[6] / 100));
    } else if (match[7] !== void 0) {
      res.alpha = Math.max(0, Math.min(1, +match[7]));
    }
    return res;
  };
  var parseHslLegacy_default = parseHslLegacy;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsl/parseHsl.js
  function parseHsl(color2, parsed) {
    if (!parsed || parsed[0] !== "hsl" && parsed[0] !== "hsla") {
      return void 0;
    }
    const res = { mode: "hsl" };
    const [, h2, s2, l2, alpha] = parsed;
    if (h2.type !== Tok.None) {
      if (h2.type === Tok.Percentage) {
        return void 0;
      }
      res.h = h2.value;
    }
    if (s2.type !== Tok.None) {
      if (s2.type === Tok.Hue) {
        return void 0;
      }
      res.s = s2.value / 100;
    }
    if (l2.type !== Tok.None) {
      if (l2.type === Tok.Hue) {
        return void 0;
      }
      res.l = l2.value / 100;
    }
    if (alpha.type !== Tok.None) {
      res.alpha = Math.min(
        1,
        Math.max(
          0,
          alpha.type === Tok.Number ? alpha.value : alpha.value / 100
        )
      );
    }
    return res;
  }
  var parseHsl_default = parseHsl;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsl/definition.js
  var definition7 = {
    mode: "hsl",
    toMode: {
      rgb: convertHslToRgb
    },
    fromMode: {
      rgb: convertRgbToHsl
    },
    channels: ["h", "s", "l", "alpha"],
    ranges: {
      h: [0, 360]
    },
    gamut: "rgb",
    parse: [parseHsl_default, parseHslLegacy_default],
    serialize: (c3) => `hsl(${c3.h !== void 0 ? c3.h : "none"} ${c3.s !== void 0 ? c3.s * 100 + "%" : "none"} ${c3.l !== void 0 ? c3.l * 100 + "%" : "none"}${c3.alpha < 1 ? ` / ${c3.alpha}` : ""})`,
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      s: interpolatorLinear,
      l: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default7 = definition7;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsv/convertHsvToRgb.js
  function convertHsvToRgb({ h: h2, s: s2, v: v2, alpha }) {
    h2 = normalizeHue_default(h2 !== void 0 ? h2 : 0);
    if (s2 === void 0) s2 = 0;
    if (v2 === void 0) v2 = 0;
    let f5 = Math.abs(h2 / 60 % 2 - 1);
    let res;
    switch (Math.floor(h2 / 60)) {
      case 0:
        res = { r: v2, g: v2 * (1 - s2 * f5), b: v2 * (1 - s2) };
        break;
      case 1:
        res = { r: v2 * (1 - s2 * f5), g: v2, b: v2 * (1 - s2) };
        break;
      case 2:
        res = { r: v2 * (1 - s2), g: v2, b: v2 * (1 - s2 * f5) };
        break;
      case 3:
        res = { r: v2 * (1 - s2), g: v2 * (1 - s2 * f5), b: v2 };
        break;
      case 4:
        res = { r: v2 * (1 - s2 * f5), g: v2 * (1 - s2), b: v2 };
        break;
      case 5:
        res = { r: v2, g: v2 * (1 - s2), b: v2 * (1 - s2 * f5) };
        break;
      default:
        res = { r: v2 * (1 - s2), g: v2 * (1 - s2), b: v2 * (1 - s2) };
    }
    res.mode = "rgb";
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsv/convertRgbToHsv.js
  function convertRgbToHsv({ r: r3, g: g2, b: b2, alpha }) {
    if (r3 === void 0) r3 = 0;
    if (g2 === void 0) g2 = 0;
    if (b2 === void 0) b2 = 0;
    let M3 = Math.max(r3, g2, b2), m2 = Math.min(r3, g2, b2);
    let res = {
      mode: "hsv",
      s: M3 === 0 ? 0 : 1 - m2 / M3,
      v: M3
    };
    if (M3 - m2 !== 0)
      res.h = (M3 === r3 ? (g2 - b2) / (M3 - m2) + (g2 < b2) * 6 : M3 === g2 ? (b2 - r3) / (M3 - m2) + 2 : (r3 - g2) / (M3 - m2) + 4) * 60;
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hsv/definition.js
  var definition8 = {
    mode: "hsv",
    toMode: {
      rgb: convertHsvToRgb
    },
    parse: ["--hsv"],
    serialize: "--hsv",
    fromMode: {
      rgb: convertRgbToHsv
    },
    channels: ["h", "s", "v", "alpha"],
    ranges: {
      h: [0, 360]
    },
    gamut: "rgb",
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      s: interpolatorLinear,
      v: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default8 = definition8;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hwb/convertHwbToRgb.js
  function convertHwbToRgb({ h: h2, w: w2, b: b2, alpha }) {
    if (w2 === void 0) w2 = 0;
    if (b2 === void 0) b2 = 0;
    if (w2 + b2 > 1) {
      let s2 = w2 + b2;
      w2 /= s2;
      b2 /= s2;
    }
    return convertHsvToRgb({
      h: h2,
      s: b2 === 1 ? 1 : 1 - w2 / (1 - b2),
      v: 1 - b2,
      alpha
    });
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hwb/convertRgbToHwb.js
  function convertRgbToHwb(rgba) {
    let hsv2 = convertRgbToHsv(rgba);
    if (hsv2 === void 0) return void 0;
    let s2 = hsv2.s !== void 0 ? hsv2.s : 0;
    let v2 = hsv2.v !== void 0 ? hsv2.v : 0;
    let res = {
      mode: "hwb",
      w: (1 - s2) * v2,
      b: 1 - v2
    };
    if (hsv2.h !== void 0) res.h = hsv2.h;
    if (hsv2.alpha !== void 0) res.alpha = hsv2.alpha;
    return res;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hwb/parseHwb.js
  function ParseHwb(color2, parsed) {
    if (!parsed || parsed[0] !== "hwb") {
      return void 0;
    }
    const res = { mode: "hwb" };
    const [, h2, w2, b2, alpha] = parsed;
    if (h2.type !== Tok.None) {
      if (h2.type === Tok.Percentage) {
        return void 0;
      }
      res.h = h2.value;
    }
    if (w2.type !== Tok.None) {
      if (w2.type === Tok.Hue) {
        return void 0;
      }
      res.w = w2.value / 100;
    }
    if (b2.type !== Tok.None) {
      if (b2.type === Tok.Hue) {
        return void 0;
      }
      res.b = b2.value / 100;
    }
    if (alpha.type !== Tok.None) {
      res.alpha = Math.min(
        1,
        Math.max(
          0,
          alpha.type === Tok.Number ? alpha.value : alpha.value / 100
        )
      );
    }
    return res;
  }
  var parseHwb_default = ParseHwb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hwb/definition.js
  var definition9 = {
    mode: "hwb",
    toMode: {
      rgb: convertHwbToRgb
    },
    fromMode: {
      rgb: convertRgbToHwb
    },
    channels: ["h", "w", "b", "alpha"],
    ranges: {
      h: [0, 360]
    },
    gamut: "rgb",
    parse: [parseHwb_default],
    serialize: (c3) => `hwb(${c3.h !== void 0 ? c3.h : "none"} ${c3.w !== void 0 ? c3.w * 100 + "%" : "none"} ${c3.b !== void 0 ? c3.b * 100 + "%" : "none"}${c3.alpha < 1 ? ` / ${c3.alpha}` : ""})`,
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      w: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueNaive
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default9 = definition9;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hdr/constants.js
  var YW = 203;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/hdr/transfer.js
  var M1 = 0.1593017578125;
  var M22 = 78.84375;
  var C1 = 0.8359375;
  var C22 = 18.8515625;
  var C3 = 18.6875;
  function transferPqDecode(v2) {
    if (v2 < 0) return 0;
    const c3 = Math.pow(v2, 1 / M22);
    return 1e4 * Math.pow(Math.max(0, c3 - C1) / (C22 - C3 * c3), 1 / M1);
  }
  function transferPqEncode(v2) {
    if (v2 < 0) return 0;
    const c3 = Math.pow(v2 / 1e4, M1);
    return Math.pow((C1 + C22 * c3) / (1 + C3 * c3), M22);
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/itp/convertItpToXyz65.js
  var toRel = (c3) => Math.max(c3 / YW, 0);
  var convertItpToXyz65 = ({ i: i2, t: t2, p: p4, alpha }) => {
    if (i2 === void 0) i2 = 0;
    if (t2 === void 0) t2 = 0;
    if (p4 === void 0) p4 = 0;
    const l2 = transferPqDecode(
      i2 + 0.008609037037932761 * t2 + 0.11102962500302593 * p4
    );
    const m2 = transferPqDecode(
      i2 - 0.00860903703793275 * t2 - 0.11102962500302599 * p4
    );
    const s2 = transferPqDecode(
      i2 + 0.5600313357106791 * t2 - 0.32062717498731885 * p4
    );
    const res = {
      mode: "xyz65",
      x: toRel(
        2.070152218389422 * l2 - 1.3263473389671556 * m2 + 0.2066510476294051 * s2
      ),
      y: toRel(
        0.3647385209748074 * l2 + 0.680566024947227 * m2 - 0.0453045459220346 * s2
      ),
      z: toRel(
        -0.049747207535812 * l2 - 0.0492609666966138 * m2 + 1.1880659249923042 * s2
      )
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertItpToXyz65_default = convertItpToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/itp/convertXyz65ToItp.js
  var toAbs = (c3 = 0) => Math.max(c3 * YW, 0);
  var convertXyz65ToItp = ({ x: x2, y: y2, z: z2, alpha }) => {
    const absX = toAbs(x2);
    const absY = toAbs(y2);
    const absZ = toAbs(z2);
    const l2 = transferPqEncode(
      0.3592832590121217 * absX + 0.6976051147779502 * absY - 0.0358915932320289 * absZ
    );
    const m2 = transferPqEncode(
      -0.1920808463704995 * absX + 1.1004767970374323 * absY + 0.0753748658519118 * absZ
    );
    const s2 = transferPqEncode(
      0.0070797844607477 * absX + 0.0748396662186366 * absY + 0.8433265453898765 * absZ
    );
    const i2 = 0.5 * l2 + 0.5 * m2;
    const t2 = 1.61376953125 * l2 - 3.323486328125 * m2 + 1.709716796875 * s2;
    const p4 = 4.378173828125 * l2 - 4.24560546875 * m2 - 0.132568359375 * s2;
    const res = { mode: "itp", i: i2, t: t2, p: p4 };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToItp_default = convertXyz65ToItp;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/itp/definition.js
  var definition10 = {
    mode: "itp",
    channels: ["i", "t", "p", "alpha"],
    parse: ["--ictcp"],
    serialize: "--ictcp",
    toMode: {
      xyz65: convertItpToXyz65_default,
      rgb: (color2) => convertXyz65ToRgb_default(convertItpToXyz65_default(color2))
    },
    fromMode: {
      xyz65: convertXyz65ToItp_default,
      rgb: (color2) => convertXyz65ToItp_default(convertRgbToXyz65_default(color2))
    },
    ranges: {
      i: [0, 0.581],
      t: [-0.369, 0.272],
      p: [-0.164, 0.331]
    },
    interpolate: {
      i: interpolatorLinear,
      t: interpolatorLinear,
      p: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default10 = definition10;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jab/convertXyz65ToJab.js
  var p2 = 134.03437499999998;
  var d0 = 16295499532821565e-27;
  var jabPqEncode = (v2) => {
    if (v2 < 0) return 0;
    let vn3 = Math.pow(v2 / 1e4, M1);
    return Math.pow((C1 + C22 * vn3) / (1 + C3 * vn3), p2);
  };
  var abs = (v2 = 0) => Math.max(v2 * 203, 0);
  var convertXyz65ToJab = ({ x: x2, y: y2, z: z2, alpha }) => {
    x2 = abs(x2);
    y2 = abs(y2);
    z2 = abs(z2);
    let xp = 1.15 * x2 - 0.15 * z2;
    let yp = 0.66 * y2 + 0.34 * x2;
    let l2 = jabPqEncode(0.41478972 * xp + 0.579999 * yp + 0.014648 * z2);
    let m2 = jabPqEncode(-0.20151 * xp + 1.120649 * yp + 0.0531008 * z2);
    let s2 = jabPqEncode(-0.0166008 * xp + 0.2648 * yp + 0.6684799 * z2);
    let i2 = (l2 + m2) / 2;
    let res = {
      mode: "jab",
      j: 0.44 * i2 / (1 - 0.56 * i2) - d0,
      a: 3.524 * l2 - 4.066708 * m2 + 0.542708 * s2,
      b: 0.199076 * l2 + 1.096799 * m2 - 1.295875 * s2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToJab_default = convertXyz65ToJab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jab/convertJabToXyz65.js
  var p3 = 134.03437499999998;
  var d02 = 16295499532821565e-27;
  var jabPqDecode = (v2) => {
    if (v2 < 0) return 0;
    let vp = Math.pow(v2, 1 / p3);
    return 1e4 * Math.pow((C1 - vp) / (C3 * vp - C22), 1 / M1);
  };
  var rel = (v2) => v2 / 203;
  var convertJabToXyz65 = ({ j: j2, a: a2, b: b2, alpha }) => {
    if (j2 === void 0) j2 = 0;
    if (a2 === void 0) a2 = 0;
    if (b2 === void 0) b2 = 0;
    let i2 = (j2 + d02) / (0.44 + 0.56 * (j2 + d02));
    let l2 = jabPqDecode(i2 + 0.13860504 * a2 + 0.058047316 * b2);
    let m2 = jabPqDecode(i2 - 0.13860504 * a2 - 0.058047316 * b2);
    let s2 = jabPqDecode(i2 - 0.096019242 * a2 - 0.8118919 * b2);
    let res = {
      mode: "xyz65",
      x: rel(
        1.661373024652174 * l2 - 0.914523081304348 * m2 + 0.23136208173913045 * s2
      ),
      y: rel(
        -0.3250758611844533 * l2 + 1.571847026732543 * m2 - 0.21825383453227928 * s2
      ),
      z: rel(-0.090982811 * l2 - 0.31272829 * m2 + 1.5227666 * s2)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertJabToXyz65_default = convertJabToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jab/convertRgbToJab.js
  var convertRgbToJab = (rgb4) => {
    let res = convertXyz65ToJab_default(convertRgbToXyz65_default(rgb4));
    if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var convertRgbToJab_default = convertRgbToJab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jab/convertJabToRgb.js
  var convertJabToRgb = (color2) => convertXyz65ToRgb_default(convertJabToXyz65_default(color2));
  var convertJabToRgb_default = convertJabToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jab/definition.js
  var definition11 = {
    mode: "jab",
    channels: ["j", "a", "b", "alpha"],
    parse: ["--jzazbz"],
    serialize: "--jzazbz",
    fromMode: {
      rgb: convertRgbToJab_default,
      xyz65: convertXyz65ToJab_default
    },
    toMode: {
      rgb: convertJabToRgb_default,
      xyz65: convertJabToXyz65_default
    },
    ranges: {
      j: [0, 0.222],
      a: [-0.109, 0.129],
      b: [-0.185, 0.134]
    },
    interpolate: {
      j: interpolatorLinear,
      a: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default11 = definition11;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jch/convertJabToJch.js
  var convertJabToJch = ({ j: j2, a: a2, b: b2, alpha }) => {
    if (a2 === void 0) a2 = 0;
    if (b2 === void 0) b2 = 0;
    let c3 = Math.sqrt(a2 * a2 + b2 * b2);
    let res = {
      mode: "jch",
      j: j2,
      c: c3
    };
    if (c3) {
      res.h = normalizeHue_default(Math.atan2(b2, a2) * 180 / Math.PI);
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertJabToJch_default = convertJabToJch;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jch/convertJchToJab.js
  var convertJchToJab = ({ j: j2, c: c3, h: h2, alpha }) => {
    if (h2 === void 0) h2 = 0;
    let res = {
      mode: "jab",
      j: j2,
      a: c3 ? c3 * Math.cos(h2 / 180 * Math.PI) : 0,
      b: c3 ? c3 * Math.sin(h2 / 180 * Math.PI) : 0
    };
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertJchToJab_default = convertJchToJab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/jch/definition.js
  var definition12 = {
    mode: "jch",
    parse: ["--jzczhz"],
    serialize: "--jzczhz",
    toMode: {
      jab: convertJchToJab_default,
      rgb: (c3) => convertJabToRgb_default(convertJchToJab_default(c3))
    },
    fromMode: {
      rgb: (c3) => convertJabToJch_default(convertRgbToJab_default(c3)),
      jab: convertJabToJch_default
    },
    channels: ["j", "c", "h", "alpha"],
    ranges: {
      j: [0, 0.221],
      c: [0, 0.19],
      h: [0, 360]
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      c: interpolatorLinear,
      j: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default12 = definition12;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz50/constants.js
  var k4 = Math.pow(29, 3) / Math.pow(3, 3);
  var e4 = Math.pow(6, 3) / Math.pow(29, 3);

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab/convertLabToXyz50.js
  var fn4 = (v2) => Math.pow(v2, 3) > e4 ? Math.pow(v2, 3) : (116 * v2 - 16) / k4;
  var convertLabToXyz50 = ({ l: l2, a: a2, b: b2, alpha }) => {
    if (l2 === void 0) l2 = 0;
    if (a2 === void 0) a2 = 0;
    if (b2 === void 0) b2 = 0;
    let fy = (l2 + 16) / 116;
    let fx = a2 / 500 + fy;
    let fz = fy - b2 / 200;
    let res = {
      mode: "xyz50",
      x: fn4(fx) * D50.X,
      y: fn4(fy) * D50.Y,
      z: fn4(fz) * D50.Z
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLabToXyz50_default = convertLabToXyz50;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz50/convertXyz50ToRgb.js
  var convertXyz50ToRgb = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = convertLrgbToRgb_default({
      r: x2 * 3.1341359569958707 - y2 * 1.6173863321612538 - 0.4906619460083532 * z2,
      g: x2 * -0.978795502912089 + y2 * 1.916254567259524 + 0.03344273116131949 * z2,
      b: x2 * 0.07195537988411677 - y2 * 0.2289768264158322 + 1.405386058324125 * z2
    });
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz50ToRgb_default = convertXyz50ToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab/convertLabToRgb.js
  var convertLabToRgb = (lab2) => convertXyz50ToRgb_default(convertLabToXyz50_default(lab2));
  var convertLabToRgb_default = convertLabToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz50/convertRgbToXyz50.js
  var convertRgbToXyz50 = (rgb4) => {
    let { r: r3, g: g2, b: b2, alpha } = convertRgbToLrgb_default(rgb4);
    let res = {
      mode: "xyz50",
      x: 0.436065742824811 * r3 + 0.3851514688337912 * g2 + 0.14307845442264197 * b2,
      y: 0.22249319175623702 * r3 + 0.7168870538238823 * g2 + 0.06061979053616537 * b2,
      z: 0.013923904500943465 * r3 + 0.09708128566574634 * g2 + 0.7140993584005155 * b2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToXyz50_default = convertRgbToXyz50;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab/convertXyz50ToLab.js
  var f4 = (value2) => value2 > e4 ? Math.cbrt(value2) : (k4 * value2 + 16) / 116;
  var convertXyz50ToLab = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let f0 = f4(x2 / D50.X);
    let f1 = f4(y2 / D50.Y);
    let f22 = f4(z2 / D50.Z);
    let res = {
      mode: "lab",
      l: 116 * f1 - 16,
      a: 500 * (f0 - f1),
      b: 200 * (f1 - f22)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz50ToLab_default = convertXyz50ToLab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab/convertRgbToLab.js
  var convertRgbToLab = (rgb4) => {
    let res = convertXyz50ToLab_default(convertRgbToXyz50_default(rgb4));
    if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var convertRgbToLab_default = convertRgbToLab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab/parseLab.js
  function parseLab(color2, parsed) {
    if (!parsed || parsed[0] !== "lab") {
      return void 0;
    }
    const res = { mode: "lab" };
    const [, l2, a2, b2, alpha] = parsed;
    if (l2.type === Tok.Hue || a2.type === Tok.Hue || b2.type === Tok.Hue) {
      return void 0;
    }
    if (l2.type !== Tok.None) {
      res.l = Math.min(Math.max(0, l2.value), 100);
    }
    if (a2.type !== Tok.None) {
      res.a = a2.type === Tok.Number ? a2.value : a2.value * 125 / 100;
    }
    if (b2.type !== Tok.None) {
      res.b = b2.type === Tok.Number ? b2.value : b2.value * 125 / 100;
    }
    if (alpha.type !== Tok.None) {
      res.alpha = Math.min(
        1,
        Math.max(
          0,
          alpha.type === Tok.Number ? alpha.value : alpha.value / 100
        )
      );
    }
    return res;
  }
  var parseLab_default = parseLab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab/definition.js
  var definition13 = {
    mode: "lab",
    toMode: {
      xyz50: convertLabToXyz50_default,
      rgb: convertLabToRgb_default
    },
    fromMode: {
      xyz50: convertXyz50ToLab_default,
      rgb: convertRgbToLab_default
    },
    channels: ["l", "a", "b", "alpha"],
    ranges: {
      l: [0, 100],
      a: [-100, 100],
      b: [-100, 100]
    },
    parse: [parseLab_default],
    serialize: (c3) => `lab(${c3.l !== void 0 ? c3.l : "none"} ${c3.a !== void 0 ? c3.a : "none"} ${c3.b !== void 0 ? c3.b : "none"}${c3.alpha < 1 ? ` / ${c3.alpha}` : ""})`,
    interpolate: {
      l: interpolatorLinear,
      a: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default13 = definition13;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lab65/definition.js
  var definition14 = {
    ...definition_default13,
    mode: "lab65",
    parse: ["--lab-d65"],
    serialize: "--lab-d65",
    toMode: {
      xyz65: convertLab65ToXyz65_default,
      rgb: convertLab65ToRgb_default
    },
    fromMode: {
      xyz65: convertXyz65ToLab65_default,
      rgb: convertRgbToLab65_default
    },
    ranges: {
      l: [0, 100],
      a: [-86.182, 98.234],
      b: [-107.86, 94.477]
    }
  };
  var definition_default14 = definition14;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lch/parseLch.js
  function parseLch(color2, parsed) {
    if (!parsed || parsed[0] !== "lch") {
      return void 0;
    }
    const res = { mode: "lch" };
    const [, l2, c3, h2, alpha] = parsed;
    if (l2.type !== Tok.None) {
      if (l2.type === Tok.Hue) {
        return void 0;
      }
      res.l = Math.min(Math.max(0, l2.value), 100);
    }
    if (c3.type !== Tok.None) {
      res.c = Math.max(
        0,
        c3.type === Tok.Number ? c3.value : c3.value * 150 / 100
      );
    }
    if (h2.type !== Tok.None) {
      if (h2.type === Tok.Percentage) {
        return void 0;
      }
      res.h = h2.value;
    }
    if (alpha.type !== Tok.None) {
      res.alpha = Math.min(
        1,
        Math.max(
          0,
          alpha.type === Tok.Number ? alpha.value : alpha.value / 100
        )
      );
    }
    return res;
  }
  var parseLch_default = parseLch;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lch/definition.js
  var definition15 = {
    mode: "lch",
    toMode: {
      lab: convertLchToLab_default,
      rgb: (c3) => convertLabToRgb_default(convertLchToLab_default(c3))
    },
    fromMode: {
      rgb: (c3) => convertLabToLch_default(convertRgbToLab_default(c3)),
      lab: convertLabToLch_default
    },
    channels: ["l", "c", "h", "alpha"],
    ranges: {
      l: [0, 100],
      c: [0, 150],
      h: [0, 360]
    },
    parse: [parseLch_default],
    serialize: (c3) => `lch(${c3.l !== void 0 ? c3.l : "none"} ${c3.c !== void 0 ? c3.c : "none"} ${c3.h !== void 0 ? c3.h : "none"}${c3.alpha < 1 ? ` / ${c3.alpha}` : ""})`,
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      c: interpolatorLinear,
      l: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default15 = definition15;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lch65/definition.js
  var definition16 = {
    ...definition_default15,
    mode: "lch65",
    parse: ["--lch-d65"],
    serialize: "--lch-d65",
    toMode: {
      lab65: (c3) => convertLchToLab_default(c3, "lab65"),
      rgb: (c3) => convertLab65ToRgb_default(convertLchToLab_default(c3, "lab65"))
    },
    fromMode: {
      rgb: (c3) => convertLabToLch_default(convertRgbToLab65_default(c3), "lch65"),
      lab65: (c3) => convertLabToLch_default(c3, "lch65")
    },
    ranges: {
      l: [0, 100],
      c: [0, 133.807],
      h: [0, 360]
    }
  };
  var definition_default16 = definition16;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lchuv/convertLuvToLchuv.js
  var convertLuvToLchuv = ({ l: l2, u: u2, v: v2, alpha }) => {
    if (u2 === void 0) u2 = 0;
    if (v2 === void 0) v2 = 0;
    let c3 = Math.sqrt(u2 * u2 + v2 * v2);
    let res = {
      mode: "lchuv",
      l: l2,
      c: c3
    };
    if (c3) {
      res.h = normalizeHue_default(Math.atan2(v2, u2) * 180 / Math.PI);
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLuvToLchuv_default = convertLuvToLchuv;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lchuv/convertLchuvToLuv.js
  var convertLchuvToLuv = ({ l: l2, c: c3, h: h2, alpha }) => {
    if (h2 === void 0) h2 = 0;
    let res = {
      mode: "luv",
      l: l2,
      u: c3 ? c3 * Math.cos(h2 / 180 * Math.PI) : 0,
      v: c3 ? c3 * Math.sin(h2 / 180 * Math.PI) : 0
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLchuvToLuv_default = convertLchuvToLuv;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/luv/convertXyz50ToLuv.js
  var u_fn = (x2, y2, z2) => 4 * x2 / (x2 + 15 * y2 + 3 * z2);
  var v_fn = (x2, y2, z2) => 9 * y2 / (x2 + 15 * y2 + 3 * z2);
  var un = u_fn(D50.X, D50.Y, D50.Z);
  var vn = v_fn(D50.X, D50.Y, D50.Z);
  var l_fn = (value2) => value2 <= e4 ? k4 * value2 : 116 * Math.cbrt(value2) - 16;
  var convertXyz50ToLuv = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let l2 = l_fn(y2 / D50.Y);
    let u2 = u_fn(x2, y2, z2);
    let v2 = v_fn(x2, y2, z2);
    if (!isFinite(u2) || !isFinite(v2)) {
      l2 = u2 = v2 = 0;
    } else {
      u2 = 13 * l2 * (u2 - un);
      v2 = 13 * l2 * (v2 - vn);
    }
    let res = {
      mode: "luv",
      l: l2,
      u: u2,
      v: v2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz50ToLuv_default = convertXyz50ToLuv;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/luv/convertLuvToXyz50.js
  var u_fn2 = (x2, y2, z2) => 4 * x2 / (x2 + 15 * y2 + 3 * z2);
  var v_fn2 = (x2, y2, z2) => 9 * y2 / (x2 + 15 * y2 + 3 * z2);
  var un2 = u_fn2(D50.X, D50.Y, D50.Z);
  var vn2 = v_fn2(D50.X, D50.Y, D50.Z);
  var convertLuvToXyz50 = ({ l: l2, u: u2, v: v2, alpha }) => {
    if (l2 === void 0) l2 = 0;
    if (l2 === 0) {
      return { mode: "xyz50", x: 0, y: 0, z: 0 };
    }
    if (u2 === void 0) u2 = 0;
    if (v2 === void 0) v2 = 0;
    let up = u2 / (13 * l2) + un2;
    let vp = v2 / (13 * l2) + vn2;
    let y2 = D50.Y * (l2 <= 8 ? l2 / k4 : Math.pow((l2 + 16) / 116, 3));
    let x2 = y2 * (9 * up) / (4 * vp);
    let z2 = y2 * (12 - 3 * up - 20 * vp) / (4 * vp);
    let res = { mode: "xyz50", x: x2, y: y2, z: z2 };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLuvToXyz50_default = convertLuvToXyz50;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lchuv/definition.js
  var convertRgbToLchuv = (rgb4) => convertLuvToLchuv_default(convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb4)));
  var convertLchuvToRgb = (lchuv2) => convertXyz50ToRgb_default(convertLuvToXyz50_default(convertLchuvToLuv_default(lchuv2)));
  var definition17 = {
    mode: "lchuv",
    toMode: {
      luv: convertLchuvToLuv_default,
      rgb: convertLchuvToRgb
    },
    fromMode: {
      rgb: convertRgbToLchuv,
      luv: convertLuvToLchuv_default
    },
    channels: ["l", "c", "h", "alpha"],
    parse: ["--lchuv"],
    serialize: "--lchuv",
    ranges: {
      l: [0, 100],
      c: [0, 176.956],
      h: [0, 360]
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      c: interpolatorLinear,
      l: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var definition_default17 = definition17;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/lrgb/definition.js
  var definition18 = {
    ...definition_default,
    mode: "lrgb",
    toMode: {
      rgb: convertLrgbToRgb_default
    },
    fromMode: {
      rgb: convertRgbToLrgb_default
    },
    parse: ["srgb-linear"],
    serialize: "srgb-linear"
  };
  var definition_default18 = definition18;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/luv/definition.js
  var definition19 = {
    mode: "luv",
    toMode: {
      xyz50: convertLuvToXyz50_default,
      rgb: (luv2) => convertXyz50ToRgb_default(convertLuvToXyz50_default(luv2))
    },
    fromMode: {
      xyz50: convertXyz50ToLuv_default,
      rgb: (rgb4) => convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb4))
    },
    channels: ["l", "u", "v", "alpha"],
    parse: ["--luv"],
    serialize: "--luv",
    ranges: {
      l: [0, 100],
      u: [-84.936, 175.042],
      v: [-125.882, 87.243]
    },
    interpolate: {
      l: interpolatorLinear,
      u: interpolatorLinear,
      v: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default19 = definition19;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklab/convertLrgbToOklab.js
  var convertLrgbToOklab = ({ r: r3, g: g2, b: b2, alpha }) => {
    if (r3 === void 0) r3 = 0;
    if (g2 === void 0) g2 = 0;
    if (b2 === void 0) b2 = 0;
    let L3 = Math.cbrt(
      0.41222147079999993 * r3 + 0.5363325363 * g2 + 0.0514459929 * b2
    );
    let M3 = Math.cbrt(
      0.2119034981999999 * r3 + 0.6806995450999999 * g2 + 0.1073969566 * b2
    );
    let S3 = Math.cbrt(
      0.08830246189999998 * r3 + 0.2817188376 * g2 + 0.6299787005000002 * b2
    );
    let res = {
      mode: "oklab",
      l: 0.2104542553 * L3 + 0.793617785 * M3 - 0.0040720468 * S3,
      a: 1.9779984951 * L3 - 2.428592205 * M3 + 0.4505937099 * S3,
      b: 0.0259040371 * L3 + 0.7827717662 * M3 - 0.808675766 * S3
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLrgbToOklab_default = convertLrgbToOklab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklab/convertRgbToOklab.js
  var convertRgbToOklab = (rgb4) => {
    let res = convertLrgbToOklab_default(convertRgbToLrgb_default(rgb4));
    if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var convertRgbToOklab_default = convertRgbToOklab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklab/convertOklabToLrgb.js
  var convertOklabToLrgb = ({ l: l2, a: a2, b: b2, alpha }) => {
    if (l2 === void 0) l2 = 0;
    if (a2 === void 0) a2 = 0;
    if (b2 === void 0) b2 = 0;
    let L3 = Math.pow(
      l2 * 0.9999999984505198 + 0.39633779217376786 * a2 + 0.2158037580607588 * b2,
      3
    );
    let M3 = Math.pow(
      l2 * 1.0000000088817609 - 0.10556134232365635 * a2 - 0.06385417477170591 * b2,
      3
    );
    let S3 = Math.pow(
      l2 * 1.0000000546724108 - 0.08948418209496575 * a2 - 1.2914855378640917 * b2,
      3
    );
    let res = {
      mode: "lrgb",
      r: 4.076741661347994 * L3 - 3.307711590408193 * M3 + 0.230969928729428 * S3,
      g: -1.2684380040921763 * L3 + 2.6097574006633715 * M3 - 0.3413193963102197 * S3,
      b: -0.004196086541837188 * L3 - 0.7034186144594493 * M3 + 1.7076147009309444 * S3
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertOklabToLrgb_default = convertOklabToLrgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklab/convertOklabToRgb.js
  var convertOklabToRgb = (c3) => convertLrgbToRgb_default(convertOklabToLrgb_default(c3));
  var convertOklabToRgb_default = convertOklabToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/okhsl/helpers.js
  function toe(x2) {
    const k_1 = 0.206;
    const k_2 = 0.03;
    const k_3 = (1 + k_1) / (1 + k_2);
    return 0.5 * (k_3 * x2 - k_1 + Math.sqrt((k_3 * x2 - k_1) * (k_3 * x2 - k_1) + 4 * k_2 * k_3 * x2));
  }
  function toe_inv(x2) {
    const k_1 = 0.206;
    const k_2 = 0.03;
    const k_3 = (1 + k_1) / (1 + k_2);
    return (x2 * x2 + k_1 * x2) / (k_3 * (x2 + k_2));
  }
  function compute_max_saturation(a2, b2) {
    let k0, k1, k22, k32, k42, wl, wm, ws;
    if (-1.88170328 * a2 - 0.80936493 * b2 > 1) {
      k0 = 1.19086277;
      k1 = 1.76576728;
      k22 = 0.59662641;
      k32 = 0.75515197;
      k42 = 0.56771245;
      wl = 4.0767416621;
      wm = -3.3077115913;
      ws = 0.2309699292;
    } else if (1.81444104 * a2 - 1.19445276 * b2 > 1) {
      k0 = 0.73956515;
      k1 = -0.45954404;
      k22 = 0.08285427;
      k32 = 0.1254107;
      k42 = 0.14503204;
      wl = -1.2684380046;
      wm = 2.6097574011;
      ws = -0.3413193965;
    } else {
      k0 = 1.35733652;
      k1 = -915799e-8;
      k22 = -1.1513021;
      k32 = -0.50559606;
      k42 = 692167e-8;
      wl = -0.0041960863;
      wm = -0.7034186147;
      ws = 1.707614701;
    }
    let S3 = k0 + k1 * a2 + k22 * b2 + k32 * a2 * a2 + k42 * a2 * b2;
    let k_l = 0.3963377774 * a2 + 0.2158037573 * b2;
    let k_m = -0.1055613458 * a2 - 0.0638541728 * b2;
    let k_s = -0.0894841775 * a2 - 1.291485548 * b2;
    {
      let l_ = 1 + S3 * k_l;
      let m_ = 1 + S3 * k_m;
      let s_ = 1 + S3 * k_s;
      let l2 = l_ * l_ * l_;
      let m2 = m_ * m_ * m_;
      let s2 = s_ * s_ * s_;
      let l_dS = 3 * k_l * l_ * l_;
      let m_dS = 3 * k_m * m_ * m_;
      let s_dS = 3 * k_s * s_ * s_;
      let l_dS2 = 6 * k_l * k_l * l_;
      let m_dS2 = 6 * k_m * k_m * m_;
      let s_dS2 = 6 * k_s * k_s * s_;
      let f5 = wl * l2 + wm * m2 + ws * s2;
      let f1 = wl * l_dS + wm * m_dS + ws * s_dS;
      let f22 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
      S3 = S3 - f5 * f1 / (f1 * f1 - 0.5 * f5 * f22);
    }
    return S3;
  }
  function find_cusp(a2, b2) {
    let S_cusp = compute_max_saturation(a2, b2);
    let rgb4 = convertOklabToLrgb_default({ l: 1, a: S_cusp * a2, b: S_cusp * b2 });
    let L_cusp = Math.cbrt(1 / Math.max(rgb4.r, rgb4.g, rgb4.b));
    let C_cusp = L_cusp * S_cusp;
    return [L_cusp, C_cusp];
  }
  function find_gamut_intersection(a2, b2, L1, C12, L0, cusp = null) {
    if (!cusp) {
      cusp = find_cusp(a2, b2);
    }
    let t2;
    if ((L1 - L0) * cusp[1] - (cusp[0] - L0) * C12 <= 0) {
      t2 = cusp[1] * L0 / (C12 * cusp[0] + cusp[1] * (L0 - L1));
    } else {
      t2 = cusp[1] * (L0 - 1) / (C12 * (cusp[0] - 1) + cusp[1] * (L0 - L1));
      {
        let dL = L1 - L0;
        let dC = C12;
        let k_l = 0.3963377774 * a2 + 0.2158037573 * b2;
        let k_m = -0.1055613458 * a2 - 0.0638541728 * b2;
        let k_s = -0.0894841775 * a2 - 1.291485548 * b2;
        let l_dt = dL + dC * k_l;
        let m_dt = dL + dC * k_m;
        let s_dt = dL + dC * k_s;
        {
          let L3 = L0 * (1 - t2) + t2 * L1;
          let C4 = t2 * C12;
          let l_ = L3 + C4 * k_l;
          let m_ = L3 + C4 * k_m;
          let s_ = L3 + C4 * k_s;
          let l2 = l_ * l_ * l_;
          let m2 = m_ * m_ * m_;
          let s2 = s_ * s_ * s_;
          let ldt = 3 * l_dt * l_ * l_;
          let mdt = 3 * m_dt * m_ * m_;
          let sdt = 3 * s_dt * s_ * s_;
          let ldt2 = 6 * l_dt * l_dt * l_;
          let mdt2 = 6 * m_dt * m_dt * m_;
          let sdt2 = 6 * s_dt * s_dt * s_;
          let r3 = 4.0767416621 * l2 - 3.3077115913 * m2 + 0.2309699292 * s2 - 1;
          let r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt;
          let r22 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2;
          let u_r = r1 / (r1 * r1 - 0.5 * r3 * r22);
          let t_r = -r3 * u_r;
          let g2 = -1.2684380046 * l2 + 2.6097574011 * m2 - 0.3413193965 * s2 - 1;
          let g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt;
          let g22 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2;
          let u_g = g1 / (g1 * g1 - 0.5 * g2 * g22);
          let t_g = -g2 * u_g;
          let b3 = -0.0041960863 * l2 - 0.7034186147 * m2 + 1.707614701 * s2 - 1;
          let b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt;
          let b22 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2;
          let u_b = b1 / (b1 * b1 - 0.5 * b3 * b22);
          let t_b = -b3 * u_b;
          t_r = u_r >= 0 ? t_r : 1e6;
          t_g = u_g >= 0 ? t_g : 1e6;
          t_b = u_b >= 0 ? t_b : 1e6;
          t2 += Math.min(t_r, Math.min(t_g, t_b));
        }
      }
    }
    return t2;
  }
  function get_ST_max(a_, b_, cusp = null) {
    if (!cusp) {
      cusp = find_cusp(a_, b_);
    }
    let L3 = cusp[0];
    let C4 = cusp[1];
    return [C4 / L3, C4 / (1 - L3)];
  }
  function get_Cs(L3, a_, b_) {
    let cusp = find_cusp(a_, b_);
    let C_max = find_gamut_intersection(a_, b_, L3, 1, L3, cusp);
    let ST_max = get_ST_max(a_, b_, cusp);
    let S_mid = 0.11516993 + 1 / (7.4477897 + 4.1590124 * b_ + a_ * (-2.19557347 + 1.75198401 * b_ + a_ * (-2.13704948 - 10.02301043 * b_ + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));
    let T_mid = 0.11239642 + 1 / (1.6132032 - 0.68124379 * b_ + a_ * (0.40370612 + 0.90148123 * b_ + a_ * (-0.27087943 + 0.6122399 * b_ + a_ * (299215e-8 - 0.45399568 * b_ - 0.14661872 * a_))));
    let k5 = C_max / Math.min(L3 * ST_max[0], (1 - L3) * ST_max[1]);
    let C_a = L3 * S_mid;
    let C_b = (1 - L3) * T_mid;
    let C_mid = 0.9 * k5 * Math.sqrt(
      Math.sqrt(
        1 / (1 / (C_a * C_a * C_a * C_a) + 1 / (C_b * C_b * C_b * C_b))
      )
    );
    C_a = L3 * 0.4;
    C_b = (1 - L3) * 0.8;
    let C_0 = Math.sqrt(1 / (1 / (C_a * C_a) + 1 / (C_b * C_b)));
    return [C_0, C_mid, C_max];
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/okhsl/convertOklabToOkhsl.js
  function convertOklabToOkhsl(lab2) {
    const l2 = lab2.l !== void 0 ? lab2.l : 0;
    const a2 = lab2.a !== void 0 ? lab2.a : 0;
    const b2 = lab2.b !== void 0 ? lab2.b : 0;
    const ret = { mode: "okhsl", l: toe(l2) };
    if (lab2.alpha !== void 0) {
      ret.alpha = lab2.alpha;
    }
    let c3 = Math.sqrt(a2 * a2 + b2 * b2);
    if (!c3) {
      ret.s = 0;
      return ret;
    }
    let [C_0, C_mid, C_max] = get_Cs(l2, a2 / c3, b2 / c3);
    let s2;
    if (c3 < C_mid) {
      let k_0 = 0;
      let k_1 = 0.8 * C_0;
      let k_2 = 1 - k_1 / C_mid;
      let t2 = (c3 - k_0) / (k_1 + k_2 * (c3 - k_0));
      s2 = t2 * 0.8;
    } else {
      let k_0 = C_mid;
      let k_1 = 0.2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
      let k_2 = 1 - k_1 / (C_max - C_mid);
      let t2 = (c3 - k_0) / (k_1 + k_2 * (c3 - k_0));
      s2 = 0.8 + 0.2 * t2;
    }
    if (s2) {
      ret.s = s2;
      ret.h = normalizeHue_default(Math.atan2(b2, a2) * 180 / Math.PI);
    }
    return ret;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/okhsl/convertOkhslToOklab.js
  function convertOkhslToOklab(hsl3) {
    let h2 = hsl3.h !== void 0 ? hsl3.h : 0;
    let s2 = hsl3.s !== void 0 ? hsl3.s : 0;
    let l2 = hsl3.l !== void 0 ? hsl3.l : 0;
    const ret = { mode: "oklab", l: toe_inv(l2) };
    if (hsl3.alpha !== void 0) {
      ret.alpha = hsl3.alpha;
    }
    if (!s2 || l2 === 1) {
      ret.a = ret.b = 0;
      return ret;
    }
    let a_ = Math.cos(h2 / 180 * Math.PI);
    let b_ = Math.sin(h2 / 180 * Math.PI);
    let [C_0, C_mid, C_max] = get_Cs(ret.l, a_, b_);
    let t2, k_0, k_1, k_2;
    if (s2 < 0.8) {
      t2 = 1.25 * s2;
      k_0 = 0;
      k_1 = 0.8 * C_0;
      k_2 = 1 - k_1 / C_mid;
    } else {
      t2 = 5 * (s2 - 0.8);
      k_0 = C_mid;
      k_1 = 0.2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
      k_2 = 1 - k_1 / (C_max - C_mid);
    }
    let C4 = k_0 + t2 * k_1 / (1 - k_2 * t2);
    ret.a = C4 * a_;
    ret.b = C4 * b_;
    return ret;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/okhsl/modeOkhsl.js
  var modeOkhsl = {
    ...definition_default7,
    mode: "okhsl",
    channels: ["h", "s", "l", "alpha"],
    parse: ["--okhsl"],
    serialize: "--okhsl",
    fromMode: {
      oklab: convertOklabToOkhsl,
      rgb: (c3) => convertOklabToOkhsl(convertRgbToOklab_default(c3))
    },
    toMode: {
      oklab: convertOkhslToOklab,
      rgb: (c3) => convertOklabToRgb_default(convertOkhslToOklab(c3))
    }
  };
  var modeOkhsl_default = modeOkhsl;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/okhsv/convertOklabToOkhsv.js
  function convertOklabToOkhsv(lab2) {
    let l2 = lab2.l !== void 0 ? lab2.l : 0;
    let a2 = lab2.a !== void 0 ? lab2.a : 0;
    let b2 = lab2.b !== void 0 ? lab2.b : 0;
    let c3 = Math.sqrt(a2 * a2 + b2 * b2);
    let a_ = c3 ? a2 / c3 : 1;
    let b_ = c3 ? b2 / c3 : 1;
    let [S_max, T3] = get_ST_max(a_, b_);
    let S_0 = 0.5;
    let k5 = 1 - S_0 / S_max;
    let t2 = T3 / (c3 + l2 * T3);
    let L_v = t2 * l2;
    let C_v = t2 * c3;
    let L_vt = toe_inv(L_v);
    let C_vt = C_v * L_vt / L_v;
    let rgb_scale = convertOklabToLrgb_default({ l: L_vt, a: a_ * C_vt, b: b_ * C_vt });
    let scale_L = Math.cbrt(
      1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0)
    );
    l2 = l2 / scale_L;
    c3 = c3 / scale_L * toe(l2) / l2;
    l2 = toe(l2);
    const ret = {
      mode: "okhsv",
      s: c3 ? (S_0 + T3) * C_v / (T3 * S_0 + T3 * k5 * C_v) : 0,
      v: l2 ? l2 / L_v : 0
    };
    if (ret.s) {
      ret.h = normalizeHue_default(Math.atan2(b2, a2) * 180 / Math.PI);
    }
    if (lab2.alpha !== void 0) {
      ret.alpha = lab2.alpha;
    }
    return ret;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/okhsv/convertOkhsvToOklab.js
  function convertOkhsvToOklab(hsv2) {
    const ret = { mode: "oklab" };
    if (hsv2.alpha !== void 0) {
      ret.alpha = hsv2.alpha;
    }
    const h2 = hsv2.h !== void 0 ? hsv2.h : 0;
    const s2 = hsv2.s !== void 0 ? hsv2.s : 0;
    const v2 = hsv2.v !== void 0 ? hsv2.v : 0;
    const a_ = Math.cos(h2 / 180 * Math.PI);
    const b_ = Math.sin(h2 / 180 * Math.PI);
    const [S_max, T3] = get_ST_max(a_, b_);
    const S_0 = 0.5;
    const k5 = 1 - S_0 / S_max;
    const L_v = 1 - s2 * S_0 / (S_0 + T3 - T3 * k5 * s2);
    const C_v = s2 * T3 * S_0 / (S_0 + T3 - T3 * k5 * s2);
    const L_vt = toe_inv(L_v);
    const C_vt = C_v * L_vt / L_v;
    const rgb_scale = convertOklabToLrgb_default({
      l: L_vt,
      a: a_ * C_vt,
      b: b_ * C_vt
    });
    const scale_L = Math.cbrt(
      1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0)
    );
    const L_new = toe_inv(v2 * L_v);
    const C4 = C_v * L_new / L_v;
    ret.l = L_new * scale_L;
    ret.a = C4 * a_ * scale_L;
    ret.b = C4 * b_ * scale_L;
    return ret;
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/okhsv/modeOkhsv.js
  var modeOkhsv = {
    ...definition_default8,
    mode: "okhsv",
    channels: ["h", "s", "v", "alpha"],
    parse: ["--okhsv"],
    serialize: "--okhsv",
    fromMode: {
      oklab: convertOklabToOkhsv,
      rgb: (c3) => convertOklabToOkhsv(convertRgbToOklab_default(c3))
    },
    toMode: {
      oklab: convertOkhsvToOklab,
      rgb: (c3) => convertOklabToRgb_default(convertOkhsvToOklab(c3))
    }
  };
  var modeOkhsv_default = modeOkhsv;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklab/parseOklab.js
  function parseOklab(color2, parsed) {
    if (!parsed || parsed[0] !== "oklab") {
      return void 0;
    }
    const res = { mode: "oklab" };
    const [, l2, a2, b2, alpha] = parsed;
    if (l2.type === Tok.Hue || a2.type === Tok.Hue || b2.type === Tok.Hue) {
      return void 0;
    }
    if (l2.type !== Tok.None) {
      res.l = Math.min(
        Math.max(0, l2.type === Tok.Number ? l2.value : l2.value / 100),
        1
      );
    }
    if (a2.type !== Tok.None) {
      res.a = a2.type === Tok.Number ? a2.value : a2.value * 0.4 / 100;
    }
    if (b2.type !== Tok.None) {
      res.b = b2.type === Tok.Number ? b2.value : b2.value * 0.4 / 100;
    }
    if (alpha.type !== Tok.None) {
      res.alpha = Math.min(
        1,
        Math.max(
          0,
          alpha.type === Tok.Number ? alpha.value : alpha.value / 100
        )
      );
    }
    return res;
  }
  var parseOklab_default = parseOklab;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklab/definition.js
  var definition20 = {
    ...definition_default13,
    mode: "oklab",
    toMode: {
      lrgb: convertOklabToLrgb_default,
      rgb: convertOklabToRgb_default
    },
    fromMode: {
      lrgb: convertLrgbToOklab_default,
      rgb: convertRgbToOklab_default
    },
    ranges: {
      l: [0, 1],
      a: [-0.4, 0.4],
      b: [-0.4, 0.4]
    },
    parse: [parseOklab_default],
    serialize: (c3) => `oklab(${c3.l !== void 0 ? c3.l : "none"} ${c3.a !== void 0 ? c3.a : "none"} ${c3.b !== void 0 ? c3.b : "none"}${c3.alpha < 1 ? ` / ${c3.alpha}` : ""})`
  };
  var definition_default20 = definition20;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklch/parseOklch.js
  function parseOklch(color2, parsed) {
    if (!parsed || parsed[0] !== "oklch") {
      return void 0;
    }
    const res = { mode: "oklch" };
    const [, l2, c3, h2, alpha] = parsed;
    if (l2.type !== Tok.None) {
      if (l2.type === Tok.Hue) {
        return void 0;
      }
      res.l = Math.min(
        Math.max(0, l2.type === Tok.Number ? l2.value : l2.value / 100),
        1
      );
    }
    if (c3.type !== Tok.None) {
      res.c = Math.max(
        0,
        c3.type === Tok.Number ? c3.value : c3.value * 0.4 / 100
      );
    }
    if (h2.type !== Tok.None) {
      if (h2.type === Tok.Percentage) {
        return void 0;
      }
      res.h = h2.value;
    }
    if (alpha.type !== Tok.None) {
      res.alpha = Math.min(
        1,
        Math.max(
          0,
          alpha.type === Tok.Number ? alpha.value : alpha.value / 100
        )
      );
    }
    return res;
  }
  var parseOklch_default = parseOklch;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/oklch/definition.js
  var definition21 = {
    ...definition_default15,
    mode: "oklch",
    toMode: {
      oklab: (c3) => convertLchToLab_default(c3, "oklab"),
      rgb: (c3) => convertOklabToRgb_default(convertLchToLab_default(c3, "oklab"))
    },
    fromMode: {
      rgb: (c3) => convertLabToLch_default(convertRgbToOklab_default(c3), "oklch"),
      oklab: (c3) => convertLabToLch_default(c3, "oklch")
    },
    parse: [parseOklch_default],
    serialize: (c3) => `oklch(${c3.l !== void 0 ? c3.l : "none"} ${c3.c !== void 0 ? c3.c : "none"} ${c3.h !== void 0 ? c3.h : "none"}${c3.alpha < 1 ? ` / ${c3.alpha}` : ""})`,
    ranges: {
      l: [0, 1],
      c: [0, 0.4],
      h: [0, 360]
    }
  };
  var definition_default21 = definition21;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/p3/convertP3ToXyz65.js
  var convertP3ToXyz65 = (rgb4) => {
    let { r: r3, g: g2, b: b2, alpha } = convertRgbToLrgb_default(rgb4);
    let res = {
      mode: "xyz65",
      x: 0.486570948648216 * r3 + 0.265667693169093 * g2 + 0.1982172852343625 * b2,
      y: 0.2289745640697487 * r3 + 0.6917385218365062 * g2 + 0.079286914093745 * b2,
      z: 0 * r3 + 0.0451133818589026 * g2 + 1.043944368900976 * b2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertP3ToXyz65_default = convertP3ToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/p3/convertXyz65ToP3.js
  var convertXyz65ToP3 = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = convertLrgbToRgb_default(
      {
        r: x2 * 2.4934969119414263 - y2 * 0.9313836179191242 - 0.402710784450717 * z2,
        g: x2 * -0.8294889695615749 + y2 * 1.7626640603183465 + 0.0236246858419436 * z2,
        b: x2 * 0.0358458302437845 - y2 * 0.0761723892680418 + 0.9568845240076871 * z2
      },
      "p3"
    );
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToP3_default = convertXyz65ToP3;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/p3/definition.js
  var definition22 = {
    ...definition_default,
    mode: "p3",
    parse: ["display-p3"],
    serialize: "display-p3",
    fromMode: {
      rgb: (color2) => convertXyz65ToP3_default(convertRgbToXyz65_default(color2)),
      xyz65: convertXyz65ToP3_default
    },
    toMode: {
      rgb: (color2) => convertXyz65ToRgb_default(convertP3ToXyz65_default(color2)),
      xyz65: convertP3ToXyz65_default
    }
  };
  var definition_default22 = definition22;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/prophoto/convertXyz50ToProphoto.js
  var gamma2 = (v2) => {
    let abs2 = Math.abs(v2);
    if (abs2 >= 1 / 512) {
      return Math.sign(v2) * Math.pow(abs2, 1 / 1.8);
    }
    return 16 * v2;
  };
  var convertXyz50ToProphoto = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = {
      mode: "prophoto",
      r: gamma2(
        x2 * 1.3457868816471585 - y2 * 0.2555720873797946 - 0.0511018649755453 * z2
      ),
      g: gamma2(
        x2 * -0.5446307051249019 + y2 * 1.5082477428451466 + 0.0205274474364214 * z2
      ),
      b: gamma2(x2 * 0 + y2 * 0 + 1.2119675456389452 * z2)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz50ToProphoto_default = convertXyz50ToProphoto;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/prophoto/convertProphotoToXyz50.js
  var linearize2 = (v2 = 0) => {
    let abs2 = Math.abs(v2);
    if (abs2 >= 16 / 512) {
      return Math.sign(v2) * Math.pow(abs2, 1.8);
    }
    return v2 / 16;
  };
  var convertProphotoToXyz50 = (prophoto2) => {
    let r3 = linearize2(prophoto2.r);
    let g2 = linearize2(prophoto2.g);
    let b2 = linearize2(prophoto2.b);
    let res = {
      mode: "xyz50",
      x: 0.7977666449006423 * r3 + 0.1351812974005331 * g2 + 0.0313477341283922 * b2,
      y: 0.2880748288194013 * r3 + 0.7118352342418731 * g2 + 899369387256e-16 * b2,
      z: 0 * r3 + 0 * g2 + 0.8251046025104602 * b2
    };
    if (prophoto2.alpha !== void 0) {
      res.alpha = prophoto2.alpha;
    }
    return res;
  };
  var convertProphotoToXyz50_default = convertProphotoToXyz50;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/prophoto/definition.js
  var definition23 = {
    ...definition_default,
    mode: "prophoto",
    parse: ["prophoto-rgb"],
    serialize: "prophoto-rgb",
    fromMode: {
      xyz50: convertXyz50ToProphoto_default,
      rgb: (color2) => convertXyz50ToProphoto_default(convertRgbToXyz50_default(color2))
    },
    toMode: {
      xyz50: convertProphotoToXyz50_default,
      rgb: (color2) => convertXyz50ToRgb_default(convertProphotoToXyz50_default(color2))
    }
  };
  var definition_default23 = definition23;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rec2020/convertXyz65ToRec2020.js
  var \u03B1 = 1.09929682680944;
  var \u03B2 = 0.018053968510807;
  var gamma3 = (v2) => {
    const abs2 = Math.abs(v2);
    if (abs2 > \u03B2) {
      return (Math.sign(v2) || 1) * (\u03B1 * Math.pow(abs2, 0.45) - (\u03B1 - 1));
    }
    return 4.5 * v2;
  };
  var convertXyz65ToRec2020 = ({ x: x2, y: y2, z: z2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = {
      mode: "rec2020",
      r: gamma3(
        x2 * 1.7166511879712683 - y2 * 0.3556707837763925 - 0.2533662813736599 * z2
      ),
      g: gamma3(
        x2 * -0.6666843518324893 + y2 * 1.6164812366349395 + 0.0157685458139111 * z2
      ),
      b: gamma3(
        x2 * 0.0176398574453108 - y2 * 0.0427706132578085 + 0.9421031212354739 * z2
      )
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToRec2020_default = convertXyz65ToRec2020;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rec2020/convertRec2020ToXyz65.js
  var \u03B12 = 1.09929682680944;
  var \u03B22 = 0.018053968510807;
  var linearize3 = (v2 = 0) => {
    let abs2 = Math.abs(v2);
    if (abs2 < \u03B22 * 4.5) {
      return v2 / 4.5;
    }
    return (Math.sign(v2) || 1) * Math.pow((abs2 + \u03B12 - 1) / \u03B12, 1 / 0.45);
  };
  var convertRec2020ToXyz65 = (rec20202) => {
    let r3 = linearize3(rec20202.r);
    let g2 = linearize3(rec20202.g);
    let b2 = linearize3(rec20202.b);
    let res = {
      mode: "xyz65",
      x: 0.6369580483012911 * r3 + 0.1446169035862083 * g2 + 0.1688809751641721 * b2,
      y: 0.262700212011267 * r3 + 0.6779980715188708 * g2 + 0.059301716469862 * b2,
      z: 0 * r3 + 0.0280726930490874 * g2 + 1.0609850577107909 * b2
    };
    if (rec20202.alpha !== void 0) {
      res.alpha = rec20202.alpha;
    }
    return res;
  };
  var convertRec2020ToXyz65_default = convertRec2020ToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/rec2020/definition.js
  var definition24 = {
    ...definition_default,
    mode: "rec2020",
    fromMode: {
      xyz65: convertXyz65ToRec2020_default,
      rgb: (color2) => convertXyz65ToRec2020_default(convertRgbToXyz65_default(color2))
    },
    toMode: {
      xyz65: convertRec2020ToXyz65_default,
      rgb: (color2) => convertXyz65ToRgb_default(convertRec2020ToXyz65_default(color2))
    },
    parse: ["rec2020"],
    serialize: "rec2020"
  };
  var definition_default24 = definition24;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyb/constants.js
  var bias = 0.0037930732552754493;
  var bias_cbrt = Math.cbrt(bias);

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyb/convertRgbToXyb.js
  var transfer = (v2) => Math.cbrt(v2) - bias_cbrt;
  var convertRgbToXyb = (color2) => {
    const { r: r3, g: g2, b: b2, alpha } = convertRgbToLrgb_default(color2);
    const l2 = transfer(0.3 * r3 + 0.622 * g2 + 0.078 * b2 + bias);
    const m2 = transfer(0.23 * r3 + 0.692 * g2 + 0.078 * b2 + bias);
    const s2 = transfer(
      0.2434226892454782 * r3 + 0.2047674442449682 * g2 + 0.5518098665095535 * b2 + bias
    );
    const res = {
      mode: "xyb",
      x: (l2 - m2) / 2,
      y: (l2 + m2) / 2,
      /* Apply default chroma from luma (subtract Y from B) */
      b: s2 - (l2 + m2) / 2
    };
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertRgbToXyb_default = convertRgbToXyb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyb/convertXybToRgb.js
  var transfer2 = (v2) => Math.pow(v2 + bias_cbrt, 3);
  var convertXybToRgb = ({ x: x2, y: y2, b: b2, alpha }) => {
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (b2 === void 0) b2 = 0;
    const l2 = transfer2(x2 + y2) - bias;
    const m2 = transfer2(y2 - x2) - bias;
    const s2 = transfer2(b2 + y2) - bias;
    const res = convertLrgbToRgb_default({
      r: 11.031566904639861 * l2 - 9.866943908131562 * m2 - 0.16462299650829934 * s2,
      g: -3.2541473810744237 * l2 + 4.418770377582723 * m2 - 0.16462299650829934 * s2,
      b: -3.6588512867136815 * l2 + 2.7129230459360922 * m2 + 1.9459282407775895 * s2
    });
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertXybToRgb_default = convertXybToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyb/definition.js
  var definition25 = {
    mode: "xyb",
    channels: ["x", "y", "b", "alpha"],
    parse: ["--xyb"],
    serialize: "--xyb",
    toMode: {
      rgb: convertXybToRgb_default
    },
    fromMode: {
      rgb: convertRgbToXyb_default
    },
    ranges: {
      x: [-0.0154, 0.0281],
      y: [0, 0.8453],
      b: [-0.2778, 0.388]
    },
    interpolate: {
      x: interpolatorLinear,
      y: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default25 = definition25;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz50/definition.js
  var definition26 = {
    mode: "xyz50",
    parse: ["xyz-d50"],
    serialize: "xyz-d50",
    toMode: {
      rgb: convertXyz50ToRgb_default,
      lab: convertXyz50ToLab_default
    },
    fromMode: {
      rgb: convertRgbToXyz50_default,
      lab: convertLabToXyz50_default
    },
    channels: ["x", "y", "z", "alpha"],
    ranges: {
      x: [0, 0.964],
      y: [0, 0.999],
      z: [0, 0.825]
    },
    interpolate: {
      x: interpolatorLinear,
      y: interpolatorLinear,
      z: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default26 = definition26;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz65/convertXyz65ToXyz50.js
  var convertXyz65ToXyz50 = (xyz652) => {
    let { x: x2, y: y2, z: z2, alpha } = xyz652;
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = {
      mode: "xyz50",
      x: 1.0479298208405488 * x2 + 0.0229467933410191 * y2 - 0.0501922295431356 * z2,
      y: 0.0296278156881593 * x2 + 0.990434484573249 * y2 - 0.0170738250293851 * z2,
      z: -0.0092430581525912 * x2 + 0.0150551448965779 * y2 + 0.7518742899580008 * z2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToXyz50_default = convertXyz65ToXyz50;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz65/convertXyz50ToXyz65.js
  var convertXyz50ToXyz65 = (xyz502) => {
    let { x: x2, y: y2, z: z2, alpha } = xyz502;
    if (x2 === void 0) x2 = 0;
    if (y2 === void 0) y2 = 0;
    if (z2 === void 0) z2 = 0;
    let res = {
      mode: "xyz65",
      x: 0.9554734527042182 * x2 - 0.0230985368742614 * y2 + 0.0632593086610217 * z2,
      y: -0.0283697069632081 * x2 + 1.0099954580058226 * y2 + 0.021041398966943 * z2,
      z: 0.0123140016883199 * x2 - 0.0205076964334779 * y2 + 1.3303659366080753 * z2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz50ToXyz65_default = convertXyz50ToXyz65;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/xyz65/definition.js
  var definition27 = {
    mode: "xyz65",
    toMode: {
      rgb: convertXyz65ToRgb_default,
      xyz50: convertXyz65ToXyz50_default
    },
    fromMode: {
      rgb: convertRgbToXyz65_default,
      xyz50: convertXyz50ToXyz65_default
    },
    ranges: {
      x: [0, 0.95],
      y: [0, 1],
      z: [0, 1.088]
    },
    channels: ["x", "y", "z", "alpha"],
    parse: ["xyz", "xyz-d65"],
    serialize: "xyz-d65",
    interpolate: {
      x: interpolatorLinear,
      y: interpolatorLinear,
      z: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default27 = definition27;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/yiq/convertRgbToYiq.js
  var convertRgbToYiq = ({ r: r3, g: g2, b: b2, alpha }) => {
    if (r3 === void 0) r3 = 0;
    if (g2 === void 0) g2 = 0;
    if (b2 === void 0) b2 = 0;
    const res = {
      mode: "yiq",
      y: 0.29889531 * r3 + 0.58662247 * g2 + 0.11448223 * b2,
      i: 0.59597799 * r3 - 0.2741761 * g2 - 0.32180189 * b2,
      q: 0.21147017 * r3 - 0.52261711 * g2 + 0.31114694 * b2
    };
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertRgbToYiq_default = convertRgbToYiq;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/yiq/convertYiqToRgb.js
  var convertYiqToRgb = ({ y: y2, i: i2, q: q2, alpha }) => {
    if (y2 === void 0) y2 = 0;
    if (i2 === void 0) i2 = 0;
    if (q2 === void 0) q2 = 0;
    const res = {
      mode: "rgb",
      r: y2 + 0.95608445 * i2 + 0.6208885 * q2,
      g: y2 - 0.27137664 * i2 - 0.6486059 * q2,
      b: y2 - 1.10561724 * i2 + 1.70250126 * q2
    };
    if (alpha !== void 0) res.alpha = alpha;
    return res;
  };
  var convertYiqToRgb_default = convertYiqToRgb;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/yiq/definition.js
  var definition28 = {
    mode: "yiq",
    toMode: {
      rgb: convertYiqToRgb_default
    },
    fromMode: {
      rgb: convertRgbToYiq_default
    },
    channels: ["y", "i", "q", "alpha"],
    parse: ["--yiq"],
    serialize: "--yiq",
    ranges: {
      i: [-0.595, 0.595],
      q: [-0.522, 0.522]
    },
    interpolate: {
      y: interpolatorLinear,
      i: interpolatorLinear,
      q: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var definition_default28 = definition28;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/round.js
  var r2 = (value2, precision) => Math.round(value2 * (precision = Math.pow(10, precision))) / precision;
  var round = (precision = 4) => (value2) => typeof value2 === "number" ? r2(value2, precision) : value2;
  var round_default = round;

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/formatter.js
  var twoDecimals = round_default(2);
  var clamp = (value2) => Math.max(0, Math.min(1, value2 || 0));
  var fixup = (value2) => Math.round(clamp(value2) * 255);
  var rgb = converter_default("rgb");
  var hsl = converter_default("hsl");
  var serializeHex = (color2) => {
    if (color2 === void 0) {
      return void 0;
    }
    let r3 = fixup(color2.r);
    let g2 = fixup(color2.g);
    let b2 = fixup(color2.b);
    return "#" + (1 << 24 | r3 << 16 | g2 << 8 | b2).toString(16).slice(1);
  };
  var serializeHex8 = (color2) => {
    if (color2 === void 0) {
      return void 0;
    }
    let a2 = fixup(color2.alpha !== void 0 ? color2.alpha : 1);
    return serializeHex(color2) + (1 << 8 | a2).toString(16).slice(1);
  };
  var serializeRgb = (color2) => {
    if (color2 === void 0) {
      return void 0;
    }
    let r3 = fixup(color2.r);
    let g2 = fixup(color2.g);
    let b2 = fixup(color2.b);
    if (color2.alpha === void 0 || color2.alpha === 1) {
      return `rgb(${r3}, ${g2}, ${b2})`;
    } else {
      return `rgba(${r3}, ${g2}, ${b2}, ${twoDecimals(clamp(color2.alpha))})`;
    }
  };
  var formatHex = (c3) => serializeHex(rgb(c3));
  var formatHex8 = (c3) => serializeHex8(rgb(c3));
  var formatRgb = (c3) => serializeRgb(rgb(c3));

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/clamp.js
  var rgb2 = converter_default("rgb");
  var fixup_rgb = (c3) => {
    const res = {
      mode: c3.mode,
      r: Math.max(0, Math.min(c3.r !== void 0 ? c3.r : 0, 1)),
      g: Math.max(0, Math.min(c3.g !== void 0 ? c3.g : 0, 1)),
      b: Math.max(0, Math.min(c3.b !== void 0 ? c3.b : 0, 1))
    };
    if (c3.alpha !== void 0) {
      res.alpha = c3.alpha;
    }
    return res;
  };
  var to_displayable_srgb = (c3) => fixup_rgb(rgb2(c3));
  var inrange_rgb = (c3) => {
    return c3 !== void 0 && (c3.r === void 0 || c3.r >= 0 && c3.r <= 1) && (c3.g === void 0 || c3.g >= 0 && c3.g <= 1) && (c3.b === void 0 || c3.b >= 0 && c3.b <= 1);
  };
  function displayable(color2) {
    return inrange_rgb(rgb2(color2));
  }
  function inGamut(mode = "rgb") {
    const { gamut } = getMode(mode);
    if (!gamut) {
      return (color2) => true;
    }
    const conv = converter_default(typeof gamut === "string" ? gamut : mode);
    return (color2) => inrange_rgb(conv(color2));
  }
  function clampRgb(color2) {
    color2 = prepare_default(color2);
    if (color2 === void 0 || displayable(color2)) return color2;
    let conv = converter_default(color2.mode);
    return conv(to_displayable_srgb(color2));
  }

  // node_modules/.pnpm/culori@4.0.1/node_modules/culori/src/index.js
  var a98 = useMode(definition_default2);
  var cubehelix = useMode(definition_default3);
  var dlab = useMode(definition_default4);
  var dlch = useMode(definition_default5);
  var hsi = useMode(definition_default6);
  var hsl2 = useMode(definition_default7);
  var hsv = useMode(definition_default8);
  var hwb = useMode(definition_default9);
  var itp = useMode(definition_default10);
  var jab = useMode(definition_default11);
  var jch = useMode(definition_default12);
  var lab = useMode(definition_default13);
  var lab65 = useMode(definition_default14);
  var lch = useMode(definition_default15);
  var lch65 = useMode(definition_default16);
  var lchuv = useMode(definition_default17);
  var lrgb = useMode(definition_default18);
  var luv = useMode(definition_default19);
  var okhsl = useMode(modeOkhsl_default);
  var okhsv = useMode(modeOkhsv_default);
  var oklab = useMode(definition_default20);
  var oklch = useMode(definition_default21);
  var p32 = useMode(definition_default22);
  var prophoto = useMode(definition_default23);
  var rec2020 = useMode(definition_default24);
  var rgb3 = useMode(definition_default);
  var xyb = useMode(definition_default25);
  var xyz50 = useMode(definition_default26);
  var xyz65 = useMode(definition_default27);
  var yiq = useMode(definition_default28);

  // node_modules/.pnpm/postcss@8.4.47/node_modules/postcss/lib/postcss.mjs
  var import_postcss = __toESM(require_postcss(), 1);
  var postcss_default = import_postcss.default;
  var stringify2 = import_postcss.default.stringify;
  var fromJSON = import_postcss.default.fromJSON;
  var plugin = import_postcss.default.plugin;
  var parse3 = import_postcss.default.parse;
  var list = import_postcss.default.list;
  var document2 = import_postcss.default.document;
  var comment = import_postcss.default.comment;
  var atRule = import_postcss.default.atRule;
  var rule = import_postcss.default.rule;
  var decl = import_postcss.default.decl;
  var root = import_postcss.default.root;
  var CssSyntaxError = import_postcss.default.CssSyntaxError;
  var Declaration = import_postcss.default.Declaration;
  var Container = import_postcss.default.Container;
  var Processor = import_postcss.default.Processor;
  var Document = import_postcss.default.Document;
  var Comment = import_postcss.default.Comment;
  var Warning = import_postcss.default.Warning;
  var AtRule = import_postcss.default.AtRule;
  var Result = import_postcss.default.Result;
  var Input = import_postcss.default.Input;
  var Rule = import_postcss.default.Rule;
  var Root = import_postcss.default.Root;
  var Node = import_postcss.default.Node;

  // node_modules/.pnpm/color-name@2.0.0/node_modules/color-name/index.js
  var color_name_default = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };

  // node_modules/.pnpm/monaco-tailwindcss@0.6.1_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_line_column = __toESM(require_line_column(), 1);
  var import_moo = __toESM(require_moo(), 1);
  var import_moo2 = __toESM(require_moo(), 1);
  var import_moo3 = __toESM(require_moo(), 1);
  var import_tmp_cache = __toESM(require_lib(), 1);
  var import_dlv4 = __toESM(require_dlv_umd(), 1);
  var import_css = __toESM(require_css_escape(), 1);

  // node_modules/.pnpm/is-regexp@3.1.0/node_modules/is-regexp/index.js
  var { toString } = Object.prototype;
  function isRegexp(value2) {
    return toString.call(value2) === "[object RegExp]";
  }

  // node_modules/.pnpm/is-obj@3.0.0/node_modules/is-obj/index.js
  function isObject(value2) {
    const type = typeof value2;
    return value2 !== null && (type === "object" || type === "function");
  }

  // node_modules/.pnpm/get-own-enumerable-keys@1.0.0/node_modules/get-own-enumerable-keys/index.js
  var { propertyIsEnumerable } = Object.prototype;
  function getOwnEnumerableKeys(object) {
    return [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object).filter((key) => propertyIsEnumerable.call(object, key))
    ];
  }

  // node_modules/.pnpm/stringify-object@5.0.0/node_modules/stringify-object/index.js
  function stringifyObject(input, options, pad) {
    const seen = [];
    return function stringify3(input2, options2 = {}, pad2 = "") {
      const indent = options2.indent || "	";
      let tokens;
      if (options2.inlineCharacterLimit === void 0) {
        tokens = {
          newline: "\n",
          newlineOrSpace: "\n",
          pad: pad2,
          indent: pad2 + indent
        };
      } else {
        tokens = {
          newline: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
          newlineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
          pad: "@@__STRINGIFY_OBJECT_PAD__@@",
          indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
        };
      }
      const expandWhiteSpace = (string) => {
        if (options2.inlineCharacterLimit === void 0) {
          return string;
        }
        const oneLined = string.replace(new RegExp(tokens.newline, "g"), "").replace(new RegExp(tokens.newlineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
        if (oneLined.length <= options2.inlineCharacterLimit) {
          return oneLined;
        }
        return string.replace(new RegExp(tokens.newline + "|" + tokens.newlineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + indent);
      };
      if (seen.includes(input2)) {
        return '"[Circular]"';
      }
      if (input2 === null || input2 === void 0 || typeof input2 === "number" || typeof input2 === "boolean" || typeof input2 === "function" || typeof input2 === "symbol" || isRegexp(input2)) {
        return String(input2);
      }
      if (input2 instanceof Date) {
        return `new Date('${input2.toISOString()}')`;
      }
      if (Array.isArray(input2)) {
        if (input2.length === 0) {
          return "[]";
        }
        seen.push(input2);
        const returnValue = "[" + tokens.newline + input2.map((element, i2) => {
          const eol = input2.length - 1 === i2 ? tokens.newline : "," + tokens.newlineOrSpace;
          let value2 = stringify3(element, options2, pad2 + indent);
          if (options2.transform) {
            value2 = options2.transform(input2, i2, value2);
          }
          return tokens.indent + value2 + eol;
        }).join("") + tokens.pad + "]";
        seen.pop();
        return expandWhiteSpace(returnValue);
      }
      if (isObject(input2)) {
        let objectKeys = getOwnEnumerableKeys(input2);
        if (options2.filter) {
          objectKeys = objectKeys.filter((element) => options2.filter(input2, element));
        }
        if (objectKeys.length === 0) {
          return "{}";
        }
        seen.push(input2);
        const returnValue = "{" + tokens.newline + objectKeys.map((element, index2) => {
          const eol = objectKeys.length - 1 === index2 ? tokens.newline : "," + tokens.newlineOrSpace;
          const isSymbol = typeof element === "symbol";
          const isClassic = !isSymbol && /^[a-z$_][$\w]*$/i.test(element);
          const key = isSymbol || isClassic ? element : stringify3(element, options2);
          let value2 = stringify3(input2[element], options2, pad2 + indent);
          if (options2.transform) {
            value2 = options2.transform(input2, element, value2);
          }
          return tokens.indent + String(key) + ": " + value2 + eol;
        }).join("") + tokens.pad + "}";
        seen.pop();
        return expandWhiteSpace(returnValue);
      }
      input2 = input2.replace(/\\/g, "\\\\");
      input2 = String(input2).replace(/[\r\n]/g, (x2) => x2 === "\n" ? "\\n" : "\\r");
      if (options2.singleQuotes === false) {
        input2 = input2.replace(/"/g, '\\"');
        return `"${input2}"`;
      }
      input2 = input2.replace(/'/g, "\\'");
      return `'${input2}'`;
    }(input, options, pad);
  }

  // node_modules/.pnpm/monaco-tailwindcss@0.6.1_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_gte = __toESM(require_gte(), 1);
  var import_lte = __toESM(require_lte(), 1);
  var import_dlv5 = __toESM(require_dlv_umd(), 1);
  var import_dlv6 = __toESM(require_dlv_umd(), 1);
  var import_dlv7 = __toESM(require_dlv_umd(), 1);
  var import_sift_string = __toESM(require_sift_string(), 1);
  var import_dlv8 = __toESM(require_dlv_umd(), 1);
  var import_dlv9 = __toESM(require_dlv_umd(), 1);
  var import_line_column2 = __toESM(require_line_column(), 1);
  var import_dlv10 = __toESM(require_dlv_umd(), 1);
  var import_postcss_selector_parser = __toESM(require_dist(), 1);
  var import_dlv11 = __toESM(require_dlv_umd(), 1);

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/errors.js
  var ErrorHandler = class {
    constructor() {
      this.listeners = [];
      this.unexpectedErrorHandler = function(e5) {
        setTimeout(() => {
          if (e5.stack) {
            if (ErrorNoTelemetry.isErrorNoTelemetry(e5)) {
              throw new ErrorNoTelemetry(e5.message + "\n\n" + e5.stack);
            }
            throw new Error(e5.message + "\n\n" + e5.stack);
          }
          throw e5;
        }, 0);
      };
    }
    emit(e5) {
      this.listeners.forEach((listener) => {
        listener(e5);
      });
    }
    onUnexpectedError(e5) {
      this.unexpectedErrorHandler(e5);
      this.emit(e5);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e5) {
      this.unexpectedErrorHandler(e5);
    }
  };
  var errorHandler = new ErrorHandler();
  function onUnexpectedError(e5) {
    if (!isCancellationError(e5)) {
      errorHandler.onUnexpectedError(e5);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      const { name, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name,
        message,
        stack,
        noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
      };
    }
    return error;
  }
  var canceledName = "Canceled";
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var CancellationError = class extends Error {
    constructor() {
      super(canceledName);
      this.name = this.message;
    }
  };
  var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
    constructor(msg) {
      super(msg);
      this.name = "CodeExpectedError";
    }
    static fromError(err) {
      if (err instanceof _ErrorNoTelemetry) {
        return err;
      }
      const result = new _ErrorNoTelemetry();
      result.message = err.message;
      result.stack = err.stack;
      return result;
    }
    static isErrorNoTelemetry(err) {
      return err.name === "CodeExpectedError";
    }
  };
  var BugIndicatingError = class _BugIndicatingError extends Error {
    constructor(message) {
      super(message || "An unexpected bug occurred.");
      Object.setPrototypeOf(this, _BugIndicatingError.prototype);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/functional.js
  function createSingleCallFunction(fn5, fnDidRunCallback) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      if (fnDidRunCallback) {
        try {
          result = fn5.apply(_this, arguments);
        } finally {
          fnDidRunCallback();
        }
      } else {
        result = fn5.apply(_this, arguments);
      }
      return result;
    };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  (function(Iterable2) {
    function is(thing) {
      return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
    }
    Iterable2.is = is;
    const _empty2 = Object.freeze([]);
    function empty() {
      return _empty2;
    }
    Iterable2.empty = empty;
    function* single(element) {
      yield element;
    }
    Iterable2.single = single;
    function wrap(iterableOrElement) {
      if (is(iterableOrElement)) {
        return iterableOrElement;
      } else {
        return single(iterableOrElement);
      }
    }
    Iterable2.wrap = wrap;
    function from(iterable) {
      return iterable || _empty2;
    }
    Iterable2.from = from;
    function* reverse(array) {
      for (let i2 = array.length - 1; i2 >= 0; i2--) {
        yield array[i2];
      }
    }
    Iterable2.reverse = reverse;
    function isEmpty(iterable) {
      return !iterable || iterable[Symbol.iterator]().next().done === true;
    }
    Iterable2.isEmpty = isEmpty;
    function first(iterable) {
      return iterable[Symbol.iterator]().next().value;
    }
    Iterable2.first = first;
    function some(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return true;
        }
      }
      return false;
    }
    Iterable2.some = some;
    function find(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return element;
        }
      }
      return void 0;
    }
    Iterable2.find = find;
    function* filter(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          yield element;
        }
      }
    }
    Iterable2.filter = filter;
    function* map(iterable, fn5) {
      let index2 = 0;
      for (const element of iterable) {
        yield fn5(element, index2++);
      }
    }
    Iterable2.map = map;
    function* concat(...iterables) {
      for (const iterable of iterables) {
        yield* iterable;
      }
    }
    Iterable2.concat = concat;
    function reduce(iterable, reducer, initialValue) {
      let value2 = initialValue;
      for (const element of iterable) {
        value2 = reducer(value2, element);
      }
      return value2;
    }
    Iterable2.reduce = reduce;
    function* slice(arr, from2, to = arr.length) {
      if (from2 < 0) {
        from2 += arr.length;
      }
      if (to < 0) {
        to += arr.length;
      } else if (to > arr.length) {
        to = arr.length;
      }
      for (; from2 < to; from2++) {
        yield arr[from2];
      }
    }
    Iterable2.slice = slice;
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
      const consumed = [];
      if (atMost === 0) {
        return [consumed, iterable];
      }
      const iterator = iterable[Symbol.iterator]();
      for (let i2 = 0; i2 < atMost; i2++) {
        const next = iterator.next();
        if (next.done) {
          return [consumed, Iterable2.empty()];
        }
        consumed.push(next.value);
      }
      return [consumed, { [Symbol.iterator]() {
        return iterator;
      } }];
    }
    Iterable2.consume = consume;
    async function asyncToArray(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return Promise.resolve(result);
    }
    Iterable2.asyncToArray = asyncToArray;
  })(Iterable || (Iterable = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  var TRACK_DISPOSABLES = false;
  var disposableTracker = null;
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  if (TRACK_DISPOSABLES) {
    const __is_disposable_tracked__ = "__is_disposable_tracked__";
    setDisposableTracker(new class {
      trackDisposable(x2) {
        const stack = new Error("Potentially leaked disposable").stack;
        setTimeout(() => {
          if (!x2[__is_disposable_tracked__]) {
            console.log(stack);
          }
        }, 3e3);
      }
      setParent(child, parent) {
        if (child && child !== Disposable.None) {
          try {
            child[__is_disposable_tracked__] = true;
          } catch (_a4) {
          }
        }
      }
      markAsDisposed(disposable) {
        if (disposable && disposable !== Disposable.None) {
          try {
            disposable[__is_disposable_tracked__] = true;
          } catch (_a4) {
          }
        }
      }
      markAsSingleton(disposable) {
      }
    }());
  }
  function trackDisposable(x2) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x2);
    return x2;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      const errors = [];
      for (const d2 of arg) {
        if (d2) {
          try {
            d2.dispose();
          } catch (e5) {
            errors.push(e5);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn5) {
    const self2 = trackDisposable({
      dispose: createSingleCallFunction(() => {
        markAsDisposed(self2);
        fn5();
      })
    });
    return self2;
  }
  var DisposableStore = class _DisposableStore {
    constructor() {
      this._toDispose = /* @__PURE__ */ new Set();
      this._isDisposed = false;
      trackDisposable(this);
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
      if (this._isDisposed) {
        return;
      }
      markAsDisposed(this);
      this._isDisposed = true;
      this.clear();
    }
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
      if (this._toDispose.size === 0) {
        return;
      }
      try {
        dispose(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
    }
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add(o2) {
      if (!o2) {
        return o2;
      }
      if (o2 === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      setParentOfDisposable(o2, this);
      if (this._isDisposed) {
        if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
          console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
        }
      } else {
        this._toDispose.add(o2);
      }
      return o2;
    }
    /**
     * Deletes the value from the store, but does not dispose it.
     */
    deleteAndLeak(o2) {
      if (!o2) {
        return;
      }
      if (this._toDispose.has(o2)) {
        this._toDispose.delete(o2);
        setParentOfDisposable(o2, null);
      }
    }
  };
  DisposableStore.DISABLE_DISPOSED_WARNING = false;
  var Disposable = class {
    constructor() {
      this._store = new DisposableStore();
      trackDisposable(this);
      setParentOfDisposable(this._store, this);
    }
    dispose() {
      markAsDisposed(this);
      this._store.dispose();
    }
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    _register(o2) {
      if (o2 === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      return this._store.add(o2);
    }
  };
  Disposable.None = Object.freeze({ dispose() {
  } });

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node2 = class _Node {
    constructor(element) {
      this.element = element;
      this.next = _Node.Undefined;
      this.prev = _Node.Undefined;
    }
  };
  Node2.Undefined = new Node2(void 0);
  var LinkedList = class {
    constructor() {
      this._first = Node2.Undefined;
      this._last = Node2.Undefined;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._first === Node2.Undefined;
    }
    clear() {
      let node = this._first;
      while (node !== Node2.Undefined) {
        const next = node.next;
        node.prev = Node2.Undefined;
        node.next = Node2.Undefined;
        node = next;
      }
      this._first = Node2.Undefined;
      this._last = Node2.Undefined;
      this._size = 0;
    }
    unshift(element) {
      return this._insert(element, false);
    }
    push(element) {
      return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
      const newNode = new Node2(element);
      if (this._first === Node2.Undefined) {
        this._first = newNode;
        this._last = newNode;
      } else if (atTheEnd) {
        const oldLast = this._last;
        this._last = newNode;
        newNode.prev = oldLast;
        oldLast.next = newNode;
      } else {
        const oldFirst = this._first;
        this._first = newNode;
        newNode.next = oldFirst;
        oldFirst.prev = newNode;
      }
      this._size += 1;
      let didRemove = false;
      return () => {
        if (!didRemove) {
          didRemove = true;
          this._remove(newNode);
        }
      };
    }
    shift() {
      if (this._first === Node2.Undefined) {
        return void 0;
      } else {
        const res = this._first.element;
        this._remove(this._first);
        return res;
      }
    }
    pop() {
      if (this._last === Node2.Undefined) {
        return void 0;
      } else {
        const res = this._last.element;
        this._remove(this._last);
        return res;
      }
    }
    _remove(node) {
      if (node.prev !== Node2.Undefined && node.next !== Node2.Undefined) {
        const anchor = node.prev;
        anchor.next = node.next;
        node.next.prev = anchor;
      } else if (node.prev === Node2.Undefined && node.next === Node2.Undefined) {
        this._first = Node2.Undefined;
        this._last = Node2.Undefined;
      } else if (node.next === Node2.Undefined) {
        this._last = this._last.prev;
        this._last.next = Node2.Undefined;
      } else if (node.prev === Node2.Undefined) {
        this._first = this._first.next;
        this._first.prev = Node2.Undefined;
      }
      this._size -= 1;
    }
    *[Symbol.iterator]() {
      let node = this._first;
      while (node !== Node2.Undefined) {
        yield node.element;
        node = node.next;
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
  var StopWatch = class _StopWatch {
    static create(highResolution) {
      return new _StopWatch(highResolution);
    }
    constructor(highResolution) {
      this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
      this._startTime = this._now();
      this._stopTime = -1;
    }
    stop() {
      this._stopTime = this._now();
    }
    reset() {
      this._startTime = this._now();
      this._stopTime = -1;
    }
    elapsed() {
      if (this._stopTime !== -1) {
        return this._stopTime - this._startTime;
      }
      return this._now() - this._startTime;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableListenerGCedWarning = false;
  var _enableDisposeWithListenerWarning = false;
  var _enableSnapshotPotentialLeakWarning = false;
  var Event;
  (function(Event2) {
    Event2.None = () => Disposable.None;
    function _addLeakageTraceLogic(options) {
      if (_enableSnapshotPotentialLeakWarning) {
        const { onDidAddListener: origListenerDidAdd } = options;
        const stack = Stacktrace.create();
        let count = 0;
        options.onDidAddListener = () => {
          if (++count === 2) {
            console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
            stack.print();
          }
          origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
        };
      }
    }
    function defer(event, disposable) {
      return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
    }
    Event2.defer = defer;
    function once(event) {
      return (listener, thisArgs = null, disposables) => {
        let didFire = false;
        let result = void 0;
        result = event((e5) => {
          if (didFire) {
            return;
          } else if (result) {
            result.dispose();
          } else {
            didFire = true;
          }
          return listener.call(thisArgs, e5);
        }, null, disposables);
        if (didFire) {
          result.dispose();
        }
        return result;
      };
    }
    Event2.once = once;
    function map(event, map2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i2) => listener.call(thisArgs, map2(i2)), null, disposables), disposable);
    }
    Event2.map = map;
    function forEach(event, each, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i2) => {
        each(i2);
        listener.call(thisArgs, i2);
      }, null, disposables), disposable);
    }
    Event2.forEach = forEach;
    function filter(event, filter2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((e5) => filter2(e5) && listener.call(thisArgs, e5), null, disposables), disposable);
    }
    Event2.filter = filter;
    function signal(event) {
      return event;
    }
    Event2.signal = signal;
    function any2(...events) {
      return (listener, thisArgs = null, disposables) => {
        const disposable = combinedDisposable(...events.map((event) => event((e5) => listener.call(thisArgs, e5))));
        return addAndReturnDisposable(disposable, disposables);
      };
    }
    Event2.any = any2;
    function reduce(event, merge, initial, disposable) {
      let output = initial;
      return map(event, (e5) => {
        output = merge(output, e5);
        return output;
      }, disposable);
    }
    Event2.reduce = reduce;
    function snapshot(event, disposable) {
      let listener;
      const options = {
        onWillAddFirstListener() {
          listener = event(emitter.fire, emitter);
        },
        onDidRemoveLastListener() {
          listener === null || listener === void 0 ? void 0 : listener.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    function addAndReturnDisposable(d2, store) {
      if (store instanceof Array) {
        store.push(d2);
      } else if (store) {
        store.add(d2);
      }
      return d2;
    }
    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
      let subscription;
      let output = void 0;
      let handle = void 0;
      let numDebouncedCalls = 0;
      let doFire;
      const options = {
        leakWarningThreshold,
        onWillAddFirstListener() {
          subscription = event((cur) => {
            numDebouncedCalls++;
            output = merge(output, cur);
            if (leading && !handle) {
              emitter.fire(output);
              output = void 0;
            }
            doFire = () => {
              const _output = output;
              output = void 0;
              handle = void 0;
              if (!leading || numDebouncedCalls > 1) {
                emitter.fire(_output);
              }
              numDebouncedCalls = 0;
            };
            if (typeof delay === "number") {
              clearTimeout(handle);
              handle = setTimeout(doFire, delay);
            } else {
              if (handle === void 0) {
                handle = 0;
                queueMicrotask(doFire);
              }
            }
          });
        },
        onWillRemoveListener() {
          if (flushOnListenerRemove && numDebouncedCalls > 0) {
            doFire === null || doFire === void 0 ? void 0 : doFire();
          }
        },
        onDidRemoveLastListener() {
          doFire = void 0;
          subscription.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    Event2.debounce = debounce;
    function accumulate(event, delay = 0, disposable) {
      return Event2.debounce(event, (last, e5) => {
        if (!last) {
          return [e5];
        }
        last.push(e5);
        return last;
      }, delay, void 0, true, void 0, disposable);
    }
    Event2.accumulate = accumulate;
    function latch(event, equals3 = (a2, b2) => a2 === b2, disposable) {
      let firstCall = true;
      let cache3;
      return filter(event, (value2) => {
        const shouldEmit = firstCall || !equals3(value2, cache3);
        firstCall = false;
        cache3 = value2;
        return shouldEmit;
      }, disposable);
    }
    Event2.latch = latch;
    function split(event, isT, disposable) {
      return [
        Event2.filter(event, isT, disposable),
        Event2.filter(event, (e5) => !isT(e5), disposable)
      ];
    }
    Event2.split = split;
    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
      let buffer2 = _buffer.slice();
      let listener = event((e5) => {
        if (buffer2) {
          buffer2.push(e5);
        } else {
          emitter.fire(e5);
        }
      });
      if (disposable) {
        disposable.add(listener);
      }
      const flush = () => {
        buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e5) => emitter.fire(e5));
        buffer2 = null;
      };
      const emitter = new Emitter({
        onWillAddFirstListener() {
          if (!listener) {
            listener = event((e5) => emitter.fire(e5));
            if (disposable) {
              disposable.add(listener);
            }
          }
        },
        onDidAddFirstListener() {
          if (buffer2) {
            if (flushAfterTimeout) {
              setTimeout(flush);
            } else {
              flush();
            }
          }
        },
        onDidRemoveLastListener() {
          if (listener) {
            listener.dispose();
          }
          listener = null;
        }
      });
      if (disposable) {
        disposable.add(emitter);
      }
      return emitter.event;
    }
    Event2.buffer = buffer;
    function chain(event, sythensize) {
      const fn5 = (listener, thisArgs, disposables) => {
        const cs = sythensize(new ChainableSynthesis());
        return event(function(value2) {
          const result = cs.evaluate(value2);
          if (result !== HaltChainable) {
            listener.call(thisArgs, result);
          }
        }, void 0, disposables);
      };
      return fn5;
    }
    Event2.chain = chain;
    const HaltChainable = Symbol("HaltChainable");
    class ChainableSynthesis {
      constructor() {
        this.steps = [];
      }
      map(fn5) {
        this.steps.push(fn5);
        return this;
      }
      forEach(fn5) {
        this.steps.push((v2) => {
          fn5(v2);
          return v2;
        });
        return this;
      }
      filter(fn5) {
        this.steps.push((v2) => fn5(v2) ? v2 : HaltChainable);
        return this;
      }
      reduce(merge, initial) {
        let last = initial;
        this.steps.push((v2) => {
          last = merge(last, v2);
          return last;
        });
        return this;
      }
      latch(equals3 = (a2, b2) => a2 === b2) {
        let firstCall = true;
        let cache3;
        this.steps.push((value2) => {
          const shouldEmit = firstCall || !equals3(value2, cache3);
          firstCall = false;
          cache3 = value2;
          return shouldEmit ? value2 : HaltChainable;
        });
        return this;
      }
      evaluate(value2) {
        for (const step of this.steps) {
          value2 = step(value2);
          if (value2 === HaltChainable) {
            break;
          }
        }
        return value2;
      }
    }
    function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
      const fn5 = (...args) => result.fire(map2(...args));
      const onFirstListenerAdd = () => emitter.on(eventName, fn5);
      const onLastListenerRemove = () => emitter.removeListener(eventName, fn5);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
      const fn5 = (...args) => result.fire(map2(...args));
      const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn5);
      const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn5);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromDOMEventEmitter = fromDOMEventEmitter;
    function toPromise(event) {
      return new Promise((resolve2) => once(event)(resolve2));
    }
    Event2.toPromise = toPromise;
    function fromPromise(promise) {
      const result = new Emitter();
      promise.then((res) => {
        result.fire(res);
      }, () => {
        result.fire(void 0);
      }).finally(() => {
        result.dispose();
      });
      return result.event;
    }
    Event2.fromPromise = fromPromise;
    function runAndSubscribe(event, handler, initial) {
      handler(initial);
      return event((e5) => handler(e5));
    }
    Event2.runAndSubscribe = runAndSubscribe;
    class EmitterObserver {
      constructor(_observable, store) {
        this._observable = _observable;
        this._counter = 0;
        this._hasChanged = false;
        const options = {
          onWillAddFirstListener: () => {
            _observable.addObserver(this);
          },
          onDidRemoveLastListener: () => {
            _observable.removeObserver(this);
          }
        };
        if (!store) {
          _addLeakageTraceLogic(options);
        }
        this.emitter = new Emitter(options);
        if (store) {
          store.add(this.emitter);
        }
      }
      beginUpdate(_observable) {
        this._counter++;
      }
      handlePossibleChange(_observable) {
      }
      handleChange(_observable, _change) {
        this._hasChanged = true;
      }
      endUpdate(_observable) {
        this._counter--;
        if (this._counter === 0) {
          this._observable.reportChanges();
          if (this._hasChanged) {
            this._hasChanged = false;
            this.emitter.fire(this._observable.get());
          }
        }
      }
    }
    function fromObservable(obs, store) {
      const observer = new EmitterObserver(obs, store);
      return observer.emitter.event;
    }
    Event2.fromObservable = fromObservable;
    function fromObservableLight(observable) {
      return (listener, thisArgs, disposables) => {
        let count = 0;
        let didChange = false;
        const observer = {
          beginUpdate() {
            count++;
          },
          endUpdate() {
            count--;
            if (count === 0) {
              observable.reportChanges();
              if (didChange) {
                didChange = false;
                listener.call(thisArgs);
              }
            }
          },
          handlePossibleChange() {
          },
          handleChange() {
            didChange = true;
          }
        };
        observable.addObserver(observer);
        observable.reportChanges();
        const disposable = {
          dispose() {
            observable.removeObserver(observer);
          }
        };
        if (disposables instanceof DisposableStore) {
          disposables.add(disposable);
        } else if (Array.isArray(disposables)) {
          disposables.push(disposable);
        }
        return disposable;
      };
    }
    Event2.fromObservableLight = fromObservableLight;
  })(Event || (Event = {}));
  var EventProfiling = class _EventProfiling {
    constructor(name) {
      this.listenerCount = 0;
      this.invocationCount = 0;
      this.elapsedOverall = 0;
      this.durations = [];
      this.name = `${name}_${_EventProfiling._idPool++}`;
      _EventProfiling.all.add(this);
    }
    start(listenerCount) {
      this._stopWatch = new StopWatch();
      this.listenerCount = listenerCount;
    }
    stop() {
      if (this._stopWatch) {
        const elapsed = this._stopWatch.elapsed();
        this.durations.push(elapsed);
        this.elapsedOverall += elapsed;
        this.invocationCount += 1;
        this._stopWatch = void 0;
      }
    }
  };
  EventProfiling.all = /* @__PURE__ */ new Set();
  EventProfiling._idPool = 0;
  var _globalLeakWarningThreshold = -1;
  var LeakageMonitor = class {
    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
      this.threshold = threshold;
      this.name = name;
      this._warnCountdown = 0;
    }
    dispose() {
      var _a4;
      (_a4 = this._stacks) === null || _a4 === void 0 ? void 0 : _a4.clear();
    }
    check(stack, listenerCount) {
      const threshold = this.threshold;
      if (threshold <= 0 || listenerCount < threshold) {
        return void 0;
      }
      if (!this._stacks) {
        this._stacks = /* @__PURE__ */ new Map();
      }
      const count = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count + 1);
      this._warnCountdown -= 1;
      if (this._warnCountdown <= 0) {
        this._warnCountdown = threshold * 0.5;
        let topStack;
        let topCount = 0;
        for (const [stack2, count2] of this._stacks) {
          if (!topStack || topCount < count2) {
            topStack = stack2;
            topCount = count2;
          }
        }
        console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
        console.warn(topStack);
      }
      return () => {
        const count2 = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count2 - 1);
      };
    }
  };
  var Stacktrace = class _Stacktrace {
    static create() {
      var _a4;
      return new _Stacktrace((_a4 = new Error().stack) !== null && _a4 !== void 0 ? _a4 : "");
    }
    constructor(value2) {
      this.value = value2;
    }
    print() {
      console.warn(this.value.split("\n").slice(2).join("\n"));
    }
  };
  var UniqueContainer = class {
    constructor(value2) {
      this.value = value2;
    }
  };
  var compactionThreshold = 2;
  var forEachListener = (listeners, fn5) => {
    if (listeners instanceof UniqueContainer) {
      fn5(listeners);
    } else {
      for (let i2 = 0; i2 < listeners.length; i2++) {
        const l2 = listeners[i2];
        if (l2) {
          fn5(l2);
        }
      }
    }
  };
  var _listenerFinalizers = _enableListenerGCedWarning ? new FinalizationRegistry((heldValue) => {
    if (typeof heldValue === "string") {
      console.warn("[LEAKING LISTENER] GC'ed a listener that was NOT yet disposed. This is where is was created:");
      console.warn(heldValue);
    }
  }) : void 0;
  var Emitter = class {
    constructor(options) {
      var _a4, _b3, _c, _d, _e;
      this._size = 0;
      this._options = options;
      this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.leakWarningThreshold) ? new LeakageMonitor((_c = (_b3 = this._options) === null || _b3 === void 0 ? void 0 : _b3.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : void 0;
      this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
      this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
    }
    dispose() {
      var _a4, _b3, _c, _d;
      if (!this._disposed) {
        this._disposed = true;
        if (((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) === this) {
          this._deliveryQueue.reset();
        }
        if (this._listeners) {
          if (_enableDisposeWithListenerWarning) {
            const listeners = this._listeners;
            queueMicrotask(() => {
              forEachListener(listeners, (l2) => {
                var _a5;
                return (_a5 = l2.stack) === null || _a5 === void 0 ? void 0 : _a5.print();
              });
            });
          }
          this._listeners = void 0;
          this._size = 0;
        }
        (_c = (_b3 = this._options) === null || _b3 === void 0 ? void 0 : _b3.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b3);
        (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
      }
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
      var _a4;
      (_a4 = this._event) !== null && _a4 !== void 0 ? _a4 : this._event = (callback, thisArgs, disposables) => {
        var _a5, _b3, _c, _d, _e;
        if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
          console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
          return Disposable.None;
        }
        if (this._disposed) {
          return Disposable.None;
        }
        if (thisArgs) {
          callback = callback.bind(thisArgs);
        }
        const contained = new UniqueContainer(callback);
        let removeMonitor;
        let stack;
        if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
          contained.stack = Stacktrace.create();
          removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
        }
        if (_enableDisposeWithListenerWarning) {
          contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
        }
        if (!this._listeners) {
          (_b3 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.onWillAddFirstListener) === null || _b3 === void 0 ? void 0 : _b3.call(_a5, this);
          this._listeners = contained;
          (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        } else if (this._listeners instanceof UniqueContainer) {
          (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();
          this._listeners = [this._listeners, contained];
        } else {
          this._listeners.push(contained);
        }
        this._size++;
        const result = toDisposable(() => {
          _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);
          removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
          this._removeListener(contained);
        });
        if (disposables instanceof DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }
        if (_listenerFinalizers) {
          const stack2 = new Error().stack.split("\n").slice(2).join("\n").trim();
          _listenerFinalizers.register(result, stack2, result);
        }
        return result;
      };
      return this._event;
    }
    _removeListener(listener) {
      var _a4, _b3, _c, _d;
      (_b3 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b3 === void 0 ? void 0 : _b3.call(_a4, this);
      if (!this._listeners) {
        return;
      }
      if (this._size === 1) {
        this._listeners = void 0;
        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this._size = 0;
        return;
      }
      const listeners = this._listeners;
      const index2 = listeners.indexOf(listener);
      if (index2 === -1) {
        console.log("disposed?", this._disposed);
        console.log("size?", this._size);
        console.log("arr?", JSON.stringify(this._listeners));
        throw new Error("Attempted to dispose unknown listener");
      }
      this._size--;
      listeners[index2] = void 0;
      const adjustDeliveryQueue = this._deliveryQueue.current === this;
      if (this._size * compactionThreshold <= listeners.length) {
        let n2 = 0;
        for (let i2 = 0; i2 < listeners.length; i2++) {
          if (listeners[i2]) {
            listeners[n2++] = listeners[i2];
          } else if (adjustDeliveryQueue) {
            this._deliveryQueue.end--;
            if (n2 < this._deliveryQueue.i) {
              this._deliveryQueue.i--;
            }
          }
        }
        listeners.length = n2;
      }
    }
    _deliver(listener, value2) {
      var _a4;
      if (!listener) {
        return;
      }
      const errorHandler2 = ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onListenerError) || onUnexpectedError;
      if (!errorHandler2) {
        listener.value(value2);
        return;
      }
      try {
        listener.value(value2);
      } catch (e5) {
        errorHandler2(e5);
      }
    }
    /** Delivers items in the queue. Assumes the queue is ready to go. */
    _deliverQueue(dq) {
      const listeners = dq.current._listeners;
      while (dq.i < dq.end) {
        this._deliver(listeners[dq.i++], dq.value);
      }
      dq.reset();
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
      var _a4, _b3, _c, _d;
      if ((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) {
        this._deliverQueue(this._deliveryQueue);
        (_b3 = this._perfMon) === null || _b3 === void 0 ? void 0 : _b3.stop();
      }
      (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);
      if (!this._listeners) {
      } else if (this._listeners instanceof UniqueContainer) {
        this._deliver(this._listeners, event);
      } else {
        const dq = this._deliveryQueue;
        dq.enqueue(this, event, this._listeners.length);
        this._deliverQueue(dq);
      }
      (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
    }
    hasListeners() {
      return this._size > 0;
    }
  };
  var EventDeliveryQueuePrivate = class {
    constructor() {
      this.i = -1;
      this.end = 0;
    }
    enqueue(emitter, value2, end) {
      this.i = 0;
      this.end = end;
      this.current = emitter;
      this.value = value2;
    }
    reset() {
      this.i = this.end;
      this.current = void 0;
      this.value = void 0;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/types.js
  function isString(str) {
    return typeof str === "string";
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/objects.js
  function getAllPropertyNames(obj) {
    let res = [];
    while (Object.prototype !== obj) {
      res = res.concat(Object.getOwnPropertyNames(obj));
      obj = Object.getPrototypeOf(obj);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/nls.js
  var isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
  function _format(message, args) {
    let result;
    if (args.length === 0) {
      result = message;
    } else {
      result = message.replace(/\{(\d+)\}/g, (match, rest) => {
        const index2 = rest[0];
        const arg = args[index2];
        let result2 = match;
        if (typeof arg === "string") {
          result2 = arg;
        } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
          result2 = String(arg);
        }
        return result2;
      });
    }
    if (isPseudo) {
      result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
    }
    return result;
  }
  function localize(data, message, ...args) {
    return _format(message, args);
  }
  function getConfiguredDefaultLocale(_2) {
    return void 0;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/platform.js
  var _a;
  var _b;
  var LANGUAGE_DEFAULT = "en";
  var _isWindows = false;
  var _isMacintosh = false;
  var _isLinux = false;
  var _isLinuxSnap = false;
  var _isNative = false;
  var _isWeb = false;
  var _isElectron = false;
  var _isIOS = false;
  var _isCI = false;
  var _isMobile = false;
  var _locale = void 0;
  var _language = LANGUAGE_DEFAULT;
  var _platformLocale = LANGUAGE_DEFAULT;
  var _translationsConfigFile = void 0;
  var _userAgent = void 0;
  var $globalThis = globalThis;
  var nodeProcess = void 0;
  if (typeof $globalThis.vscode !== "undefined" && typeof $globalThis.vscode.process !== "undefined") {
    nodeProcess = $globalThis.vscode.process;
  } else if (typeof process !== "undefined" && typeof ((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) === "string") {
    nodeProcess = process;
  }
  var isElectronProcess = typeof ((_b = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _b === void 0 ? void 0 : _b.electron) === "string";
  var isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
  if (typeof nodeProcess === "object") {
    _isWindows = nodeProcess.platform === "win32";
    _isMacintosh = nodeProcess.platform === "darwin";
    _isLinux = nodeProcess.platform === "linux";
    _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
    _isElectron = isElectronProcess;
    _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
    if (rawNlsConfig) {
      try {
        const nlsConfig = JSON.parse(rawNlsConfig);
        const resolved = nlsConfig.availableLanguages["*"];
        _locale = nlsConfig.locale;
        _platformLocale = nlsConfig.osLocale;
        _language = resolved ? resolved : LANGUAGE_DEFAULT;
        _translationsConfigFile = nlsConfig._translationsConfigFile;
      } catch (e5) {
      }
    }
    _isNative = true;
  } else if (typeof navigator === "object" && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf("Windows") >= 0;
    _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
    _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf("Linux") >= 0;
    _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
    _isWeb = true;
    const configuredLocale = getConfiguredDefaultLocale(
      // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
      // to ensure that the NLS AMD Loader plugin has been loaded and configured.
      // This is because the loader plugin decides what the default locale is based on
      // how it's able to resolve the strings.
      localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
    );
    _locale = configuredLocale || LANGUAGE_DEFAULT;
    _language = _locale;
    _platformLocale = navigator.language;
  } else {
    console.error("Unable to resolve platform.");
  }
  var _platform = 0;
  if (_isMacintosh) {
    _platform = 1;
  } else if (_isWindows) {
    _platform = 3;
  } else if (_isLinux) {
    _platform = 2;
  }
  var isWindows = _isWindows;
  var isMacintosh = _isMacintosh;
  var isWebWorker = _isWeb && typeof $globalThis.importScripts === "function";
  var webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;
  var userAgent = _userAgent;
  var setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
  var setTimeout0 = (() => {
    if (setTimeout0IsFaster) {
      const pending = [];
      $globalThis.addEventListener("message", (e5) => {
        if (e5.data && e5.data.vscodeScheduleAsyncWork) {
          for (let i2 = 0, len = pending.length; i2 < len; i2++) {
            const candidate = pending[i2];
            if (candidate.id === e5.data.vscodeScheduleAsyncWork) {
              pending.splice(i2, 1);
              candidate.callback();
              return;
            }
          }
        }
      });
      let lastId = 0;
      return (callback) => {
        const myId = ++lastId;
        pending.push({
          id: myId,
          callback
        });
        $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
      };
    }
    return (callback) => setTimeout(callback);
  })();
  var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
  var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
  var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
  var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
  var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/cache.js
  function identity2(t2) {
    return t2;
  }
  var LRUCachedFunction = class {
    constructor(arg1, arg2) {
      this.lastCache = void 0;
      this.lastArgKey = void 0;
      if (typeof arg1 === "function") {
        this._fn = arg1;
        this._computeKey = identity2;
      } else {
        this._fn = arg2;
        this._computeKey = arg1.getCacheKey;
      }
    }
    get(arg) {
      const key = this._computeKey(arg);
      if (this.lastArgKey !== key) {
        this.lastArgKey = key;
        this.lastCache = this._fn(arg);
      }
      return this.lastCache;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy = class {
    constructor(executor) {
      this.executor = executor;
      this._didRun = false;
    }
    /**
     * Get the wrapped value.
     *
     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
     */
    get value() {
      if (!this._didRun) {
        try {
          this._value = this.executor();
        } catch (err) {
          this._error = err;
        } finally {
          this._didRun = true;
        }
      }
      if (this._error) {
        throw this._error;
      }
      return this._value;
    }
    /**
     * Get the wrapped value without forcing evaluation.
     */
    get rawValue() {
      return this._value;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/strings.js
  var _a2;
  function escapeRegExpCharacters(value2) {
    return value2.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i2 = 0, len = str.length; i2 < len; i2++) {
      const chCode = str.charCodeAt(i2);
      if (chCode !== 32 && chCode !== 9) {
        return i2;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i2 = startIndex; i2 >= 0; i2--) {
      const chCode = str.charCodeAt(i2);
      if (chCode !== 32 && chCode !== 9) {
        return i2;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  var UTF8_BOM_CHARACTER = String.fromCharCode(
    65279
    /* CharCode.UTF8_BOM */
  );
  var GraphemeBreakTree = class _GraphemeBreakTree {
    static getInstance() {
      if (!_GraphemeBreakTree._INSTANCE) {
        _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
      }
      return _GraphemeBreakTree._INSTANCE;
    }
    constructor() {
      this._data = getGraphemeBreakRawData();
    }
    getGraphemeBreakType(codePoint) {
      if (codePoint < 32) {
        if (codePoint === 10) {
          return 3;
        }
        if (codePoint === 13) {
          return 2;
        }
        return 4;
      }
      if (codePoint < 127) {
        return 0;
      }
      const data = this._data;
      const nodeCount = data.length / 3;
      let nodeIndex = 1;
      while (nodeIndex <= nodeCount) {
        if (codePoint < data[3 * nodeIndex]) {
          nodeIndex = 2 * nodeIndex;
        } else if (codePoint > data[3 * nodeIndex + 1]) {
          nodeIndex = 2 * nodeIndex + 1;
        } else {
          return data[3 * nodeIndex + 2];
        }
      }
      return 0;
    }
  };
  GraphemeBreakTree._INSTANCE = null;
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var AmbiguousCharacters = class {
    static getInstance(locales) {
      return _a2.cache.get(Array.from(locales));
    }
    static getLocales() {
      return _a2._locales.value;
    }
    constructor(confusableDictionary) {
      this.confusableDictionary = confusableDictionary;
    }
    isAmbiguous(codePoint) {
      return this.confusableDictionary.has(codePoint);
    }
    /**
     * Returns the non basic ASCII code point that the given code point can be confused,
     * or undefined if such code point does note exist.
     */
    getPrimaryConfusable(codePoint) {
      return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
      return new Set(this.confusableDictionary.keys());
    }
  };
  _a2 = AmbiguousCharacters;
  AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
    return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
  });
  AmbiguousCharacters.cache = new LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {
    function arrayToMap(arr) {
      const result = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < arr.length; i2 += 2) {
        result.set(arr[i2], arr[i2 + 1]);
      }
      return result;
    }
    function mergeMaps(map1, map2) {
      const result = new Map(map1);
      for (const [key, value2] of map2) {
        result.set(key, value2);
      }
      return result;
    }
    function intersectMaps(map1, map2) {
      if (!map1) {
        return map2;
      }
      const result = /* @__PURE__ */ new Map();
      for (const [key, value2] of map1) {
        if (map2.has(key)) {
          result.set(key, value2);
        }
      }
      return result;
    }
    const data = _a2.ambiguousCharacterData.value;
    let filteredLocales = locales.filter((l2) => !l2.startsWith("_") && l2 in data);
    if (filteredLocales.length === 0) {
      filteredLocales = ["_default"];
    }
    let languageSpecificMap = void 0;
    for (const locale of filteredLocales) {
      const map2 = arrayToMap(data[locale]);
      languageSpecificMap = intersectMaps(languageSpecificMap, map2);
    }
    const commonMap = arrayToMap(data["_common"]);
    const map = mergeMaps(commonMap, languageSpecificMap);
    return new _a2(map);
  });
  AmbiguousCharacters._locales = new Lazy(() => Object.keys(_a2.ambiguousCharacterData.value).filter((k5) => !k5.startsWith("_")));
  var InvisibleCharacters = class _InvisibleCharacters {
    static getRawData() {
      return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
    }
    static getData() {
      if (!this._data) {
        this._data = new Set(_InvisibleCharacters.getRawData());
      }
      return this._data;
    }
    static isInvisibleCharacter(codePoint) {
      return _InvisibleCharacters.getData().has(codePoint);
    }
    static get codePoints() {
      return _InvisibleCharacters.getData();
    }
  };
  InvisibleCharacters._data = void 0;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
  var INITIALIZE = "$initialize";
  var RequestMessage = class {
    constructor(vsWorker, req, method, args) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.method = method;
      this.args = args;
      this.type = 0;
    }
  };
  var ReplyMessage = class {
    constructor(vsWorker, seq, res, err) {
      this.vsWorker = vsWorker;
      this.seq = seq;
      this.res = res;
      this.err = err;
      this.type = 1;
    }
  };
  var SubscribeEventMessage = class {
    constructor(vsWorker, req, eventName, arg) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.eventName = eventName;
      this.arg = arg;
      this.type = 2;
    }
  };
  var EventMessage = class {
    constructor(vsWorker, req, event) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.event = event;
      this.type = 3;
    }
  };
  var UnsubscribeEventMessage = class {
    constructor(vsWorker, req) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.type = 4;
    }
  };
  var SimpleWorkerProtocol = class {
    constructor(handler) {
      this._workerId = -1;
      this._handler = handler;
      this._lastSentReq = 0;
      this._pendingReplies = /* @__PURE__ */ Object.create(null);
      this._pendingEmitters = /* @__PURE__ */ new Map();
      this._pendingEvents = /* @__PURE__ */ new Map();
    }
    setWorkerId(workerId) {
      this._workerId = workerId;
    }
    sendMessage(method, args) {
      const req = String(++this._lastSentReq);
      return new Promise((resolve2, reject) => {
        this._pendingReplies[req] = {
          resolve: resolve2,
          reject
        };
        this._send(new RequestMessage(this._workerId, req, method, args));
      });
    }
    listen(eventName, arg) {
      let req = null;
      const emitter = new Emitter({
        onWillAddFirstListener: () => {
          req = String(++this._lastSentReq);
          this._pendingEmitters.set(req, emitter);
          this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
        },
        onDidRemoveLastListener: () => {
          this._pendingEmitters.delete(req);
          this._send(new UnsubscribeEventMessage(this._workerId, req));
          req = null;
        }
      });
      return emitter.event;
    }
    handleMessage(message) {
      if (!message || !message.vsWorker) {
        return;
      }
      if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
        return;
      }
      this._handleMessage(message);
    }
    _handleMessage(msg) {
      switch (msg.type) {
        case 1:
          return this._handleReplyMessage(msg);
        case 0:
          return this._handleRequestMessage(msg);
        case 2:
          return this._handleSubscribeEventMessage(msg);
        case 3:
          return this._handleEventMessage(msg);
        case 4:
          return this._handleUnsubscribeEventMessage(msg);
      }
    }
    _handleReplyMessage(replyMessage) {
      if (!this._pendingReplies[replyMessage.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      const reply = this._pendingReplies[replyMessage.seq];
      delete this._pendingReplies[replyMessage.seq];
      if (replyMessage.err) {
        let err = replyMessage.err;
        if (replyMessage.err.$isError) {
          err = new Error();
          err.name = replyMessage.err.name;
          err.message = replyMessage.err.message;
          err.stack = replyMessage.err.stack;
        }
        reply.reject(err);
        return;
      }
      reply.resolve(replyMessage.res);
    }
    _handleRequestMessage(requestMessage) {
      const req = requestMessage.req;
      const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
      result.then((r3) => {
        this._send(new ReplyMessage(this._workerId, req, r3, void 0));
      }, (e5) => {
        if (e5.detail instanceof Error) {
          e5.detail = transformErrorForSerialization(e5.detail);
        }
        this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e5)));
      });
    }
    _handleSubscribeEventMessage(msg) {
      const req = msg.req;
      const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
        this._send(new EventMessage(this._workerId, req, event));
      });
      this._pendingEvents.set(req, disposable);
    }
    _handleEventMessage(msg) {
      if (!this._pendingEmitters.has(msg.req)) {
        console.warn("Got event for unknown req");
        return;
      }
      this._pendingEmitters.get(msg.req).fire(msg.event);
    }
    _handleUnsubscribeEventMessage(msg) {
      if (!this._pendingEvents.has(msg.req)) {
        console.warn("Got unsubscribe for unknown req");
        return;
      }
      this._pendingEvents.get(msg.req).dispose();
      this._pendingEvents.delete(msg.req);
    }
    _send(msg) {
      const transfer3 = [];
      if (msg.type === 0) {
        for (let i2 = 0; i2 < msg.args.length; i2++) {
          if (msg.args[i2] instanceof ArrayBuffer) {
            transfer3.push(msg.args[i2]);
          }
        }
      } else if (msg.type === 1) {
        if (msg.res instanceof ArrayBuffer) {
          transfer3.push(msg.res);
        }
      }
      this._handler.sendMessage(msg, transfer3);
    }
  };
  function propertyIsEvent(name) {
    return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name) {
    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
  }
  function createProxyObject2(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const createProxyDynamicEvent = (eventName) => {
      return function(arg) {
        return proxyListen(eventName, arg);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      if (propertyIsDynamicEvent(methodName)) {
        result[methodName] = createProxyDynamicEvent(methodName);
        continue;
      }
      if (propertyIsEvent(methodName)) {
        result[methodName] = proxyListen(methodName, void 0);
        continue;
      }
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var SimpleWorkerServer = class {
    constructor(postMessage, requestHandlerFactory) {
      this._requestHandlerFactory = requestHandlerFactory;
      this._requestHandler = null;
      this._protocol = new SimpleWorkerProtocol({
        sendMessage: (msg, transfer3) => {
          postMessage(msg, transfer3);
        },
        handleMessage: (method, args) => this._handleMessage(method, args),
        handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
      });
    }
    onmessage(msg) {
      this._protocol.handleMessage(msg);
    }
    _handleMessage(method, args) {
      if (method === INITIALIZE) {
        return this.initialize(args[0], args[1], args[2], args[3]);
      }
      if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
      } catch (e5) {
        return Promise.reject(e5);
      }
    }
    _handleEvent(eventName, arg) {
      if (!this._requestHandler) {
        throw new Error(`Missing requestHandler`);
      }
      if (propertyIsDynamicEvent(eventName)) {
        const event = this._requestHandler[eventName].call(this._requestHandler, arg);
        if (typeof event !== "function") {
          throw new Error(`Missing dynamic event ${eventName} on request handler.`);
        }
        return event;
      }
      if (propertyIsEvent(eventName)) {
        const event = this._requestHandler[eventName];
        if (typeof event !== "function") {
          throw new Error(`Missing event ${eventName} on request handler.`);
        }
        return event;
      }
      throw new Error(`Malformed event name ${eventName}`);
    }
    initialize(workerId, loaderConfig, moduleId, hostMethods) {
      this._protocol.setWorkerId(workerId);
      const proxyMethodRequest = (method, args) => {
        return this._protocol.sendMessage(method, args);
      };
      const proxyListen = (eventName, arg) => {
        return this._protocol.listen(eventName, arg);
      };
      const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
      if (this._requestHandlerFactory) {
        this._requestHandler = this._requestHandlerFactory(hostProxy);
        return Promise.resolve(getAllMethodNames(this._requestHandler));
      }
      if (loaderConfig) {
        if (typeof loaderConfig.baseUrl !== "undefined") {
          delete loaderConfig["baseUrl"];
        }
        if (typeof loaderConfig.paths !== "undefined") {
          if (typeof loaderConfig.paths.vs !== "undefined") {
            delete loaderConfig.paths["vs"];
          }
        }
        if (typeof loaderConfig.trustedTypesPolicy !== "undefined") {
          delete loaderConfig["trustedTypesPolicy"];
        }
        loaderConfig.catchError = true;
        globalThis.require.config(loaderConfig);
      }
      return new Promise((resolve2, reject) => {
        const req = globalThis.require;
        req([moduleId], (module) => {
          this._requestHandler = module.create(hostProxy);
          if (!this._requestHandler) {
            reject(new Error(`No RequestHandler!`));
            return;
          }
          resolve2(getAllMethodNames(this._requestHandler));
        }, reject);
      });
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
  var DiffChange = class {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
      this.originalStart = originalStart;
      this.originalLength = originalLength;
      this.modifiedStart = modifiedStart;
      this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
      return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
      return this.modifiedStart + this.modifiedLength;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s2, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i2 = 0, length2 = s2.length; i2 < length2; i2++) {
      hashVal = numberHash(s2.charCodeAt(i2), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value2, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value2 << bits | (mask & value2) >>> delta) >>> 0;
  }
  function fill(dest, index2 = 0, count = dest.byteLength, value2 = 0) {
    for (let i2 = 0; i2 < count; i2++) {
      dest[index2 + i2] = value2;
    }
  }
  function leftPad(value2, length2, char = "0") {
    while (value2.length < length2) {
      value2 = char + value2;
    }
    return value2;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b2) => b2.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1 = class _StringSHA1 {
    constructor() {
      this._h0 = 1732584193;
      this._h1 = 4023233417;
      this._h2 = 2562383102;
      this._h3 = 271733878;
      this._h4 = 3285377520;
      this._buff = new Uint8Array(
        64 + 3
        /* to fit any utf-8 */
      );
      this._buffDV = new DataView(this._buff.buffer);
      this._buffLen = 0;
      this._totalLen = 0;
      this._leftoverHighSurrogate = 0;
      this._finished = false;
    }
    update(str) {
      const strLen = str.length;
      if (strLen === 0) {
        return;
      }
      const buff = this._buff;
      let buffLen = this._buffLen;
      let leftoverHighSurrogate = this._leftoverHighSurrogate;
      let charCode;
      let offset;
      if (leftoverHighSurrogate !== 0) {
        charCode = leftoverHighSurrogate;
        offset = -1;
        leftoverHighSurrogate = 0;
      } else {
        charCode = str.charCodeAt(0);
        offset = 0;
      }
      while (true) {
        let codePoint = charCode;
        if (isHighSurrogate(charCode)) {
          if (offset + 1 < strLen) {
            const nextCharCode = str.charCodeAt(offset + 1);
            if (isLowSurrogate(nextCharCode)) {
              offset++;
              codePoint = computeCodePoint(charCode, nextCharCode);
            } else {
              codePoint = 65533;
            }
          } else {
            leftoverHighSurrogate = charCode;
            break;
          }
        } else if (isLowSurrogate(charCode)) {
          codePoint = 65533;
        }
        buffLen = this._push(buff, buffLen, codePoint);
        offset++;
        if (offset < strLen) {
          charCode = str.charCodeAt(offset);
        } else {
          break;
        }
      }
      this._buffLen = buffLen;
      this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
      if (codePoint < 128) {
        buff[buffLen++] = codePoint;
      } else if (codePoint < 2048) {
        buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint < 65536) {
        buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else {
        buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
        buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      }
      if (buffLen >= 64) {
        this._step();
        buffLen -= 64;
        this._totalLen += 64;
        buff[0] = buff[64 + 0];
        buff[1] = buff[64 + 1];
        buff[2] = buff[64 + 2];
      }
      return buffLen;
    }
    digest() {
      if (!this._finished) {
        this._finished = true;
        if (this._leftoverHighSurrogate) {
          this._leftoverHighSurrogate = 0;
          this._buffLen = this._push(
            this._buff,
            this._buffLen,
            65533
            /* SHA1Constant.UNICODE_REPLACEMENT */
          );
        }
        this._totalLen += this._buffLen;
        this._wrapUp();
      }
      return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
      this._buff[this._buffLen++] = 128;
      fill(this._buff, this._buffLen);
      if (this._buffLen > 56) {
        this._step();
        fill(this._buff);
      }
      const ml = 8 * this._totalLen;
      this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
      this._buffDV.setUint32(60, ml % 4294967296, false);
      this._step();
    }
    _step() {
      const bigBlock32 = _StringSHA1._bigBlock32;
      const data = this._buffDV;
      for (let j2 = 0; j2 < 64; j2 += 4) {
        bigBlock32.setUint32(j2, data.getUint32(j2, false), false);
      }
      for (let j2 = 64; j2 < 320; j2 += 4) {
        bigBlock32.setUint32(j2, leftRotate(bigBlock32.getUint32(j2 - 12, false) ^ bigBlock32.getUint32(j2 - 32, false) ^ bigBlock32.getUint32(j2 - 56, false) ^ bigBlock32.getUint32(j2 - 64, false), 1), false);
      }
      let a2 = this._h0;
      let b2 = this._h1;
      let c3 = this._h2;
      let d2 = this._h3;
      let e5 = this._h4;
      let f5, k5;
      let temp;
      for (let j2 = 0; j2 < 80; j2++) {
        if (j2 < 20) {
          f5 = b2 & c3 | ~b2 & d2;
          k5 = 1518500249;
        } else if (j2 < 40) {
          f5 = b2 ^ c3 ^ d2;
          k5 = 1859775393;
        } else if (j2 < 60) {
          f5 = b2 & c3 | b2 & d2 | c3 & d2;
          k5 = 2400959708;
        } else {
          f5 = b2 ^ c3 ^ d2;
          k5 = 3395469782;
        }
        temp = leftRotate(a2, 5) + f5 + e5 + k5 + bigBlock32.getUint32(j2 * 4, false) & 4294967295;
        e5 = d2;
        d2 = c3;
        c3 = leftRotate(b2, 30);
        b2 = a2;
        a2 = temp;
      }
      this._h0 = this._h0 + a2 & 4294967295;
      this._h1 = this._h1 + b2 & 4294967295;
      this._h2 = this._h2 + c3 & 4294967295;
      this._h3 = this._h3 + d2 & 4294967295;
      this._h4 = this._h4 + e5 & 4294967295;
    }
  };
  StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
  var StringDiffSequence = class {
    constructor(source) {
      this.source = source;
    }
    getElements() {
      const source = this.source;
      const characters = new Int32Array(source.length);
      for (let i2 = 0, len = source.length; i2 < len; i2++) {
        characters[i2] = source.charCodeAt(i2);
      }
      return characters;
    }
  };
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var Debug = class {
    static Assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
  };
  var MyArray = class {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length2) {
      for (let i2 = 0; i2 < length2; i2++) {
        destinationArray[destinationIndex + i2] = sourceArray[sourceIndex + i2];
      }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length2) {
      for (let i2 = 0; i2 < length2; i2++) {
        destinationArray[destinationIndex + i2] = sourceArray[sourceIndex + i2];
      }
    }
  };
  var DiffChangeHelper = class {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
      this.m_changes = [];
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
      }
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      this.m_changes.reverse();
      return this.m_changes;
    }
  };
  var LcsDiff = class _LcsDiff {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
      this.ContinueProcessingPredicate = continueProcessingPredicate;
      this._originalSequence = originalSequence;
      this._modifiedSequence = modifiedSequence;
      const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
      const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
      this._hasStrings = originalHasStrings && modifiedHasStrings;
      this._originalStringElements = originalStringElements;
      this._originalElementsOrHash = originalElementsOrHash;
      this._modifiedStringElements = modifiedStringElements;
      this._modifiedElementsOrHash = modifiedElementsOrHash;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
      return arr.length > 0 && typeof arr[0] === "string";
    }
    static _getElements(sequence) {
      const elements = sequence.getElements();
      if (_LcsDiff._isStringArray(elements)) {
        const hashes = new Int32Array(elements.length);
        for (let i2 = 0, len = elements.length; i2 < len; i2++) {
          hashes[i2] = stringHash(elements[i2], 0);
        }
        return [elements, hashes, true];
      }
      if (elements instanceof Int32Array) {
        return [[], elements, false];
      }
      return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
      if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
      if (!this.ElementsAreEqual(originalIndex, newIndex)) {
        return false;
      }
      const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
      const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
      return originalElement === modifiedElement;
    }
    static _getStrictElement(sequence, index2) {
      if (typeof sequence.getStrictElement === "function") {
        return sequence.getStrictElement(index2);
      }
      return null;
    }
    OriginalElementsAreEqual(index1, index2) {
      if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
    }
    ModifiedElementsAreEqual(index1, index2) {
      if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
    }
    ComputeDiff(pretty) {
      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
      const quitEarlyArr = [false];
      let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
      if (pretty) {
        changes = this.PrettifyChanges(changes);
      }
      return {
        quitEarly: quitEarlyArr[0],
        changes
      };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
      quitEarlyArr[0] = false;
      while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
        originalStart++;
        modifiedStart++;
      }
      while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
        originalEnd--;
        modifiedEnd--;
      }
      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
        let changes;
        if (modifiedStart <= modifiedEnd) {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          changes = [
            new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        } else if (originalStart <= originalEnd) {
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
          ];
        } else {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [];
        }
        return changes;
      }
      const midOriginalArr = [0];
      const midModifiedArr = [0];
      const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
      const midOriginal = midOriginalArr[0];
      const midModified = midModifiedArr[0];
      if (result !== null) {
        return result;
      } else if (!quitEarlyArr[0]) {
        const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
        let rightChanges = [];
        if (!quitEarlyArr[0]) {
          rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
        } else {
          rightChanges = [
            new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
          ];
        }
        return this.ConcatenateChanges(leftChanges, rightChanges);
      }
      return [
        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
      ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
      let forwardChanges = null;
      let reverseChanges = null;
      let changeHelper = new DiffChangeHelper();
      let diagonalMin = diagonalForwardStart;
      let diagonalMax = diagonalForwardEnd;
      let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
      let lastOriginalIndex = -1073741824;
      let historyIndex = this.m_forwardHistory.length - 1;
      do {
        const diagonal = diagonalRelative + diagonalForwardBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
          diagonalRelative = diagonal + 1 - diagonalForwardBase;
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex - 1;
          changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalForwardBase;
        }
        if (historyIndex >= 0) {
          forwardPoints = this.m_forwardHistory[historyIndex];
          diagonalForwardBase = forwardPoints[0];
          diagonalMin = 1;
          diagonalMax = forwardPoints.length - 1;
        }
      } while (--historyIndex >= -1);
      forwardChanges = changeHelper.getReverseChanges();
      if (quitEarlyArr[0]) {
        let originalStartPoint = midOriginalArr[0] + 1;
        let modifiedStartPoint = midModifiedArr[0] + 1;
        if (forwardChanges !== null && forwardChanges.length > 0) {
          const lastForwardChange = forwardChanges[forwardChanges.length - 1];
          originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
          modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
        }
        reverseChanges = [
          new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
        ];
      } else {
        changeHelper = new DiffChangeHelper();
        diagonalMin = diagonalReverseStart;
        diagonalMax = diagonalReverseEnd;
        diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
        lastOriginalIndex = 1073741824;
        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
        do {
          const diagonal = diagonalRelative + diagonalReverseBase;
          if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex + 1;
            changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal + 1 - diagonalReverseBase;
          } else {
            originalIndex = reversePoints[diagonal - 1];
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex;
            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal - 1 - diagonalReverseBase;
          }
          if (historyIndex >= 0) {
            reversePoints = this.m_reverseHistory[historyIndex];
            diagonalReverseBase = reversePoints[0];
            diagonalMin = 1;
            diagonalMax = reversePoints.length - 1;
          }
        } while (--historyIndex >= -1);
        reverseChanges = changeHelper.getChanges();
      }
      return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
      let originalIndex = 0, modifiedIndex = 0;
      let diagonalForwardStart = 0, diagonalForwardEnd = 0;
      let diagonalReverseStart = 0, diagonalReverseEnd = 0;
      originalStart--;
      modifiedStart--;
      midOriginalArr[0] = 0;
      midModifiedArr[0] = 0;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
      const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
      const numDiagonals = maxDifferences + 1;
      const forwardPoints = new Int32Array(numDiagonals);
      const reversePoints = new Int32Array(numDiagonals);
      const diagonalForwardBase = modifiedEnd - modifiedStart;
      const diagonalReverseBase = originalEnd - originalStart;
      const diagonalForwardOffset = originalStart - modifiedStart;
      const diagonalReverseOffset = originalEnd - modifiedEnd;
      const delta = diagonalReverseBase - diagonalForwardBase;
      const deltaIsEven = delta % 2 === 0;
      forwardPoints[diagonalForwardBase] = originalStart;
      reversePoints[diagonalReverseBase] = originalEnd;
      quitEarlyArr[0] = false;
      for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
        let furthestOriginalIndex = 0;
        let furthestModifiedIndex = 0;
        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
          if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
            originalIndex = forwardPoints[diagonal + 1];
          } else {
            originalIndex = forwardPoints[diagonal - 1] + 1;
          }
          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
            originalIndex++;
            modifiedIndex++;
          }
          forwardPoints[diagonal] = originalIndex;
          if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
            furthestOriginalIndex = originalIndex;
            furthestModifiedIndex = modifiedIndex;
          }
          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
            if (originalIndex >= reversePoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
          quitEarlyArr[0] = true;
          midOriginalArr[0] = furthestOriginalIndex;
          midModifiedArr[0] = furthestModifiedIndex;
          if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
          } else {
            originalStart++;
            modifiedStart++;
            return [
              new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
          }
        }
        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
          if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
          } else {
            originalIndex = reversePoints[diagonal - 1];
          }
          modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
            originalIndex--;
            modifiedIndex--;
          }
          reversePoints[diagonal] = originalIndex;
          if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
            if (originalIndex <= forwardPoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        if (numDifferences <= 1447) {
          let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
          temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
          MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
          this.m_forwardHistory.push(temp);
          temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
          temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
          MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
          this.m_reverseHistory.push(temp);
        }
      }
      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
      for (let i2 = 0; i2 < changes.length; i2++) {
        const change = changes[i2];
        const originalStop = i2 < changes.length - 1 ? changes[i2 + 1].originalStart : this._originalElementsOrHash.length;
        const modifiedStop = i2 < changes.length - 1 ? changes[i2 + 1].modifiedStart : this._modifiedElementsOrHash.length;
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
          const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
          const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
          if (endStrictEqual && !startStrictEqual) {
            break;
          }
          change.originalStart++;
          change.modifiedStart++;
        }
        const mergedChangeArr = [null];
        if (i2 < changes.length - 1 && this.ChangesOverlap(changes[i2], changes[i2 + 1], mergedChangeArr)) {
          changes[i2] = mergedChangeArr[0];
          changes.splice(i2 + 1, 1);
          i2--;
          continue;
        }
      }
      for (let i2 = changes.length - 1; i2 >= 0; i2--) {
        const change = changes[i2];
        let originalStop = 0;
        let modifiedStop = 0;
        if (i2 > 0) {
          const prevChange = changes[i2 - 1];
          originalStop = prevChange.originalStart + prevChange.originalLength;
          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
        }
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        let bestDelta = 0;
        let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
        for (let delta = 1; ; delta++) {
          const originalStart = change.originalStart - delta;
          const modifiedStart = change.modifiedStart - delta;
          if (originalStart < originalStop || modifiedStart < modifiedStop) {
            break;
          }
          if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
            break;
          }
          if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
            break;
          }
          const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
          const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
          if (score2 > bestScore) {
            bestScore = score2;
            bestDelta = delta;
          }
        }
        change.originalStart -= bestDelta;
        change.modifiedStart -= bestDelta;
        const mergedChangeArr = [null];
        if (i2 > 0 && this.ChangesOverlap(changes[i2 - 1], changes[i2], mergedChangeArr)) {
          changes[i2 - 1] = mergedChangeArr[0];
          changes.splice(i2, 1);
          i2++;
          continue;
        }
      }
      if (this._hasStrings) {
        for (let i2 = 1, len = changes.length; i2 < len; i2++) {
          const aChange = changes[i2 - 1];
          const bChange = changes[i2];
          const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
          const aOriginalStart = aChange.originalStart;
          const bOriginalEnd = bChange.originalStart + bChange.originalLength;
          const abOriginalLength = bOriginalEnd - aOriginalStart;
          const aModifiedStart = aChange.modifiedStart;
          const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
          const abModifiedLength = bModifiedEnd - aModifiedStart;
          if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
            const t2 = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
            if (t2) {
              const [originalMatchStart, modifiedMatchStart] = t2;
              if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                aChange.originalLength = originalMatchStart - aChange.originalStart;
                aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                bChange.originalStart = originalMatchStart + matchedLength;
                bChange.modifiedStart = modifiedMatchStart + matchedLength;
                bChange.originalLength = bOriginalEnd - bChange.originalStart;
                bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
              }
            }
          }
        }
      }
      return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
      if (originalLength < desiredLength || modifiedLength < desiredLength) {
        return null;
      }
      const originalMax = originalStart + originalLength - desiredLength + 1;
      const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
      let bestScore = 0;
      let bestOriginalStart = 0;
      let bestModifiedStart = 0;
      for (let i2 = originalStart; i2 < originalMax; i2++) {
        for (let j2 = modifiedStart; j2 < modifiedMax; j2++) {
          const score2 = this._contiguousSequenceScore(i2, j2, desiredLength);
          if (score2 > 0 && score2 > bestScore) {
            bestScore = score2;
            bestOriginalStart = i2;
            bestModifiedStart = j2;
          }
        }
      }
      if (bestScore > 0) {
        return [bestOriginalStart, bestModifiedStart];
      }
      return null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length2) {
      let score2 = 0;
      for (let l2 = 0; l2 < length2; l2++) {
        if (!this.ElementsAreEqual(originalStart + l2, modifiedStart + l2)) {
          return 0;
        }
        score2 += this._originalStringElements[originalStart + l2].length;
      }
      return score2;
    }
    _OriginalIsBoundary(index2) {
      if (index2 <= 0 || index2 >= this._originalElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._originalStringElements[index2]);
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
      if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
        return true;
      }
      if (originalLength > 0) {
        const originalEnd = originalStart + originalLength;
        if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
          return true;
        }
      }
      return false;
    }
    _ModifiedIsBoundary(index2) {
      if (index2 <= 0 || index2 >= this._modifiedElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index2]);
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
      if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
        return true;
      }
      if (modifiedLength > 0) {
        const modifiedEnd = modifiedStart + modifiedLength;
        if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
          return true;
        }
      }
      return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
      const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
      const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
      return originalScore + modifiedScore;
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
      const mergedChangeArr = [];
      if (left.length === 0 || right.length === 0) {
        return right.length > 0 ? right : left;
      } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
        const result = new Array(left.length + right.length - 1);
        MyArray.Copy(left, 0, result, 0, left.length - 1);
        result[left.length - 1] = mergedChangeArr[0];
        MyArray.Copy(right, 1, result, left.length, right.length - 1);
        return result;
      } else {
        const result = new Array(left.length + right.length);
        MyArray.Copy(left, 0, result, 0, left.length);
        MyArray.Copy(right, 0, result, left.length, right.length);
        return result;
      }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
      Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
      Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        const originalStart = left.originalStart;
        let originalLength = left.originalLength;
        const modifiedStart = left.modifiedStart;
        let modifiedLength = left.modifiedLength;
        if (left.originalStart + left.originalLength >= right.originalStart) {
          originalLength = right.originalStart + right.originalLength - left.originalStart;
        }
        if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
          modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
        }
        mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
        return true;
      } else {
        mergedChangeArr[0] = null;
        return false;
      }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
      if (diagonal >= 0 && diagonal < numDiagonals) {
        return diagonal;
      }
      const diagonalsBelow = diagonalBaseIndex;
      const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
      const diffEven = numDifferences % 2 === 0;
      if (diagonal < 0) {
        const lowerBoundEven = diagonalsBelow % 2 === 0;
        return diffEven === lowerBoundEven ? 0 : 1;
      } else {
        const upperBoundEven = diagonalsAbove % 2 === 0;
        return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess;
  var vscodeGlobal = globalThis.vscode;
  if (typeof vscodeGlobal !== "undefined" && typeof vscodeGlobal.process !== "undefined") {
    const sandboxProcess = vscodeGlobal.process;
    safeProcess = {
      get platform() {
        return sandboxProcess.platform;
      },
      get arch() {
        return sandboxProcess.arch;
      },
      get env() {
        return sandboxProcess.env;
      },
      cwd() {
        return sandboxProcess.cwd();
      }
    };
  } else if (typeof process !== "undefined") {
    safeProcess = {
      get platform() {
        return process.platform;
      },
      get arch() {
        return process.arch;
      },
      get env() {
        return process.env;
      },
      cwd() {
        return process.env["VSCODE_CWD"] || process.cwd();
      }
    };
  } else {
    safeProcess = {
      // Supported
      get platform() {
        return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
      },
      get arch() {
        return void 0;
      },
      // Unsupported
      get env() {
        return {};
      },
      cwd() {
        return "/";
      }
    };
  }
  var cwd = safeProcess.cwd;
  var env = safeProcess.env;
  var platform = safeProcess.platform;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/path.js
  var CHAR_UPPERCASE_A = 65;
  var CHAR_LOWERCASE_A = 97;
  var CHAR_UPPERCASE_Z = 90;
  var CHAR_LOWERCASE_Z = 122;
  var CHAR_DOT = 46;
  var CHAR_FORWARD_SLASH = 47;
  var CHAR_BACKWARD_SLASH = 92;
  var CHAR_COLON = 58;
  var CHAR_QUESTION_MARK = 63;
  var ErrorInvalidArgType = class extends Error {
    constructor(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && expected.indexOf("not ") === 0) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      const type = name.indexOf(".") !== -1 ? "property" : "argument";
      let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
      msg += `. Received type ${typeof actual}`;
      super(msg);
      this.code = "ERR_INVALID_ARG_TYPE";
    }
  };
  function validateObject(pathObject, name) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType(name, "Object", pathObject);
    }
  }
  function validateString(value2, name) {
    if (typeof value2 !== "string") {
      throw new ErrorInvalidArgType(name, "string", value2);
    }
  }
  var platformIsWin32 = platform === "win32";
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i2 = 0; i2 <= path.length; ++i2) {
      if (i2 < path.length) {
        code = path.charCodeAt(i2);
      } else if (isPathSeparator2(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code)) {
        if (lastSlash === i2 - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i2;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i2)}`;
          } else {
            res = path.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format2(sep2, pathObject) {
    validateObject(pathObject, "pathObject");
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedDevice = "";
      let resolvedTail = "";
      let resolvedAbsolute = false;
      for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
        let path;
        if (i2 >= 0) {
          path = pathSegments[i2];
          validateString(path, "path");
          if (path.length === 0) {
            continue;
          }
        } else if (resolvedDevice.length === 0) {
          path = cwd();
        } else {
          path = env[`=${resolvedDevice}`] || cwd();
          if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            path = `${resolvedDevice}\\`;
          }
        }
        const len = path.length;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len === 1) {
          if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
          }
        } else if (isPathSeparator(code)) {
          isAbsolute = true;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              const firstPart = path.slice(last, j2);
              last = j2;
              while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                  j2++;
                }
                if (j2 === len || j2 !== last) {
                  device = `\\\\${firstPart}\\${path.slice(last, j2)}`;
                  rootEnd = j2;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
            isAbsolute = true;
            rootEnd = 3;
          }
        }
        if (device.length > 0) {
          if (resolvedDevice.length > 0) {
            if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
              continue;
            }
          } else {
            resolvedDevice = device;
          }
        }
        if (resolvedAbsolute) {
          if (resolvedDevice.length > 0) {
            break;
          }
        } else {
          resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
          resolvedAbsolute = isAbsolute;
          if (isAbsolute && resolvedDevice.length > 0) {
            break;
          }
        }
      }
      resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
      return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
    },
    normalize(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = 0;
      let device;
      let isAbsolute = false;
      const code = path.charCodeAt(0);
      if (len === 1) {
        return isPosixPathSeparator(code) ? "\\" : path;
      }
      if (isPathSeparator(code)) {
        isAbsolute = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
            j2++;
          }
          if (j2 < len && j2 !== last) {
            const firstPart = path.slice(last, j2);
            last = j2;
            while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 === len) {
                return `\\\\${firstPart}\\${path.slice(last)}\\`;
              }
              if (j2 !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j2)}`;
                rootEnd = j2;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute = true;
          rootEnd = 3;
        }
      }
      let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
      if (tail.length === 0 && !isAbsolute) {
        tail = ".";
      }
      if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
      }
      if (device === void 0) {
        return isAbsolute ? `\\${tail}` : tail;
      }
      return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return false;
      }
      const code = path.charCodeAt(0);
      return isPathSeparator(code) || // Possible device root
      len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      let firstPart;
      for (let i2 = 0; i2 < paths.length; ++i2) {
        const arg = paths[i2];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = firstPart = arg;
          } else {
            joined += `\\${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      let needsReplace = true;
      let slashCount = 0;
      if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
          ++slashCount;
          if (firstLen > 2) {
            if (isPathSeparator(firstPart.charCodeAt(2))) {
              ++slashCount;
            } else {
              needsReplace = false;
            }
          }
        }
      }
      if (needsReplace) {
        while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
          slashCount++;
        }
        if (slashCount >= 2) {
          joined = `\\${joined.slice(slashCount)}`;
        }
      }
      return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      const fromOrig = win32.resolve(from);
      const toOrig = win32.resolve(to);
      if (fromOrig === toOrig) {
        return "";
      }
      from = fromOrig.toLowerCase();
      to = toOrig.toLowerCase();
      if (from === to) {
        return "";
      }
      let fromStart = 0;
      while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
        fromStart++;
      }
      let fromEnd = from.length;
      while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
        fromEnd--;
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 0;
      while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        toStart++;
      }
      let toEnd = to.length;
      while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
        toEnd--;
      }
      const toLen = toEnd - toStart;
      const length2 = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i2 = 0;
      for (; i2 < length2; i2++) {
        const fromCode = from.charCodeAt(fromStart + i2);
        if (fromCode !== to.charCodeAt(toStart + i2)) {
          break;
        } else if (fromCode === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i2;
        }
      }
      if (i2 !== length2) {
        if (lastCommonSep === -1) {
          return toOrig;
        }
      } else {
        if (toLen > length2) {
          if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH) {
            return toOrig.slice(toStart + i2 + 1);
          }
          if (i2 === 2) {
            return toOrig.slice(toStart + i2);
          }
        }
        if (fromLen > length2) {
          if (from.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH) {
            lastCommonSep = i2;
          } else if (i2 === 2) {
            lastCommonSep = 3;
          }
        }
        if (lastCommonSep === -1) {
          lastCommonSep = 0;
        }
      }
      let out = "";
      for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
        if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_BACKWARD_SLASH) {
          out += out.length === 0 ? ".." : "\\..";
        }
      }
      toStart += lastCommonSep;
      if (out.length > 0) {
        return `${out}${toOrig.slice(toStart, toEnd)}`;
      }
      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        ++toStart;
      }
      return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path) {
      if (typeof path !== "string" || path.length === 0) {
        return path;
      }
      const resolvedPath = win32.resolve(path);
      if (resolvedPath.length <= 2) {
        return path;
      }
      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
          const code = resolvedPath.charCodeAt(2);
          if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
            return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
          }
        }
      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = -1;
      let offset = 0;
      const code = path.charCodeAt(0);
      if (len === 1) {
        return isPathSeparator(code) ? path : ".";
      }
      if (isPathSeparator(code)) {
        rootEnd = offset = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
            j2++;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 === len) {
                return path;
              }
              if (j2 !== last) {
                rootEnd = offset = j2 + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
        offset = rootEnd;
      }
      let end = -1;
      let matchedSlash = true;
      for (let i2 = len - 1; i2 >= offset; --i2) {
        if (isPathSeparator(path.charCodeAt(i2))) {
          if (!matchedSlash) {
            end = i2;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        if (rootEnd === -1) {
          return ".";
        }
        end = rootEnd;
      }
      return path.slice(0, end);
    },
    basename(path, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i2;
      if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
        start = 2;
      }
      if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
        if (ext === path) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i2 = path.length - 1; i2 >= start; --i2) {
          const code = path.charCodeAt(i2);
          if (isPathSeparator(code)) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i2 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i2;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start, end);
      }
      for (i2 = path.length - 1; i2 >= start; --i2) {
        if (isPathSeparator(path.charCodeAt(i2))) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start, end);
    },
    extname(path) {
      validateString(path, "path");
      let start = 0;
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
      }
      for (let i2 = path.length - 1; i2 >= start; --i2) {
        const code = path.charCodeAt(i2);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "\\"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const len = path.length;
      let rootEnd = 0;
      let code = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          ret.root = ret.dir = path;
          return ret;
        }
        ret.base = ret.name = path;
        return ret;
      }
      if (isPathSeparator(code)) {
        rootEnd = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
            j2++;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            while (j2 < len && isPathSeparator(path.charCodeAt(j2))) {
              j2++;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              while (j2 < len && !isPathSeparator(path.charCodeAt(j2))) {
                j2++;
              }
              if (j2 === len) {
                rootEnd = j2;
              } else if (j2 !== last) {
                rootEnd = j2 + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        if (len <= 2) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 2;
        if (isPathSeparator(path.charCodeAt(2))) {
          if (len === 3) {
            ret.root = ret.dir = path;
            return ret;
          }
          rootEnd = 3;
        }
      }
      if (rootEnd > 0) {
        ret.root = path.slice(0, rootEnd);
      }
      let startDot = -1;
      let startPart = rootEnd;
      let end = -1;
      let matchedSlash = true;
      let i2 = path.length - 1;
      let preDotState = 0;
      for (; i2 >= rootEnd; --i2) {
        code = path.charCodeAt(i2);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(startPart, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
      } else {
        ret.dir = ret.root;
      }
      return ret;
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null
  };
  var posixCwd = (() => {
    if (platformIsWin32) {
      const regexp = /\\/g;
      return () => {
        const cwd2 = cwd().replace(regexp, "/");
        return cwd2.slice(cwd2.indexOf("/"));
      };
    }
    return () => cwd();
  })();
  var posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
        const path = i2 >= 0 ? pathSegments[i2] : posixCwd();
        validateString(path, "path");
        if (path.length === 0) {
          continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
      if (resolvedAbsolute) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    },
    normalize(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
      path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
      if (path.length === 0) {
        if (isAbsolute) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path += "/";
      }
      return isAbsolute ? `/${path}` : path;
    },
    isAbsolute(path) {
      validateString(path, "path");
      return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      for (let i2 = 0; i2 < paths.length; ++i2) {
        const arg = paths[i2];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = arg;
          } else {
            joined += `/${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return posix.normalize(joined);
    },
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) {
        return "";
      }
      const fromStart = 1;
      const fromEnd = from.length;
      const fromLen = fromEnd - fromStart;
      const toStart = 1;
      const toLen = to.length - toStart;
      const length2 = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i2 = 0;
      for (; i2 < length2; i2++) {
        const fromCode = from.charCodeAt(fromStart + i2);
        if (fromCode !== to.charCodeAt(toStart + i2)) {
          break;
        } else if (fromCode === CHAR_FORWARD_SLASH) {
          lastCommonSep = i2;
        }
      }
      if (i2 === length2) {
        if (toLen > length2) {
          if (to.charCodeAt(toStart + i2) === CHAR_FORWARD_SLASH) {
            return to.slice(toStart + i2 + 1);
          }
          if (i2 === 0) {
            return to.slice(toStart + i2);
          }
        } else if (fromLen > length2) {
          if (from.charCodeAt(fromStart + i2) === CHAR_FORWARD_SLASH) {
            lastCommonSep = i2;
          } else if (i2 === 0) {
            lastCommonSep = 0;
          }
        }
      }
      let out = "";
      for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
        if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_FORWARD_SLASH) {
          out += out.length === 0 ? ".." : "/..";
        }
      }
      return `${out}${to.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path) {
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let end = -1;
      let matchedSlash = true;
      for (let i2 = path.length - 1; i2 >= 1; --i2) {
        if (path.charCodeAt(i2) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            end = i2;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end === 1) {
        return "//";
      }
      return path.slice(0, end);
    },
    basename(path, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i2;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
        if (ext === path) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i2 = path.length - 1; i2 >= 0; --i2) {
          const code = path.charCodeAt(i2);
          if (code === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i2 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i2;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start, end);
      }
      for (i2 = path.length - 1; i2 >= 0; --i2) {
        if (path.charCodeAt(i2) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start, end);
    },
    extname(path) {
      validateString(path, "path");
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i2 = path.length - 1; i2 >= 0; --i2) {
        const code = path.charCodeAt(i2);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "/"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i2 = path.length - 1;
      let preDotState = 0;
      for (; i2 >= start; --i2) {
        const code = path.charCodeAt(i2);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(start2, end);
        } else {
          ret.name = path.slice(start2, startDot);
          ret.base = path.slice(start2, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0) {
        ret.dir = path.slice(0, startPart - 1);
      } else if (isAbsolute) {
        ret.dir = "/";
      }
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.win32 = win32.win32 = win32;
  posix.posix = win32.posix = posix;
  var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
  var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
  var relative = platformIsWin32 ? win32.relative : posix.relative;
  var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
  var basename = platformIsWin32 ? win32.basename : posix.basename;
  var extname = platformIsWin32 ? win32.extname : posix.extname;
  var sep = platformIsWin32 ? win32.sep : posix.sep;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/uri.js
  var _schemePattern = /^\w[\w\d+.-]*$/;
  var _singleSlashStart = /^\//;
  var _doubleSlashStart = /^\/\//;
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  var _empty = "";
  var _slash = "/";
  var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  var URI2 = class _URI {
    static isUri(thing) {
      if (thing instanceof _URI) {
        return true;
      }
      if (!thing) {
        return false;
      }
      return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
    }
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
      if (typeof schemeOrData === "object") {
        this.scheme = schemeOrData.scheme || _empty;
        this.authority = schemeOrData.authority || _empty;
        this.path = schemeOrData.path || _empty;
        this.query = schemeOrData.query || _empty;
        this.fragment = schemeOrData.fragment || _empty;
      } else {
        this.scheme = _schemeFix(schemeOrData, _strict);
        this.authority = authority || _empty;
        this.path = _referenceResolution(this.scheme, path || _empty);
        this.query = query || _empty;
        this.fragment = fragment || _empty;
        _validateUri(this, _strict);
      }
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
      return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
      if (!change) {
        return this;
      }
      let { scheme, authority, path, query, fragment } = change;
      if (scheme === void 0) {
        scheme = this.scheme;
      } else if (scheme === null) {
        scheme = _empty;
      }
      if (authority === void 0) {
        authority = this.authority;
      } else if (authority === null) {
        authority = _empty;
      }
      if (path === void 0) {
        path = this.path;
      } else if (path === null) {
        path = _empty;
      }
      if (query === void 0) {
        query = this.query;
      } else if (query === null) {
        query = _empty;
      }
      if (fragment === void 0) {
        fragment = this.fragment;
      } else if (fragment === null) {
        fragment = _empty;
      }
      if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
        return this;
      }
      return new Uri(scheme, authority, path, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value2, _strict = false) {
      const match = _regexp.exec(value2);
      if (!match) {
        return new Uri(_empty, _empty, _empty, _empty, _empty);
      }
      return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path) {
      let authority = _empty;
      if (isWindows) {
        path = path.replace(/\\/g, _slash);
      }
      if (path[0] === _slash && path[1] === _slash) {
        const idx = path.indexOf(_slash, 2);
        if (idx === -1) {
          authority = path.substring(2);
          path = _slash;
        } else {
          authority = path.substring(2, idx);
          path = path.substring(idx) || _slash;
        }
      }
      return new Uri("file", authority, path, _empty, _empty);
    }
    /**
     * Creates new URI from uri components.
     *
     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
     * validation and should be used for untrusted uri components retrieved from storage,
     * user input, command arguments etc
     */
    static from(components, strict) {
      const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
      return result;
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
      if (!uri.path) {
        throw new Error(`[UriError]: cannot call joinPath on URI without path`);
      }
      let newPath;
      if (isWindows && uri.scheme === "file") {
        newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
      } else {
        newPath = posix.join(uri.path, ...pathFragment);
      }
      return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
      return _asFormatted(this, skipEncoding);
    }
    toJSON() {
      return this;
    }
    static revive(data) {
      var _a4, _b3;
      if (!data) {
        return data;
      } else if (data instanceof _URI) {
        return data;
      } else {
        const result = new Uri(data);
        result._formatted = (_a4 = data.external) !== null && _a4 !== void 0 ? _a4 : null;
        result._fsPath = data._sep === _pathSepMarker ? (_b3 = data.fsPath) !== null && _b3 !== void 0 ? _b3 : null : null;
        return result;
      }
    }
  };
  var _pathSepMarker = isWindows ? 1 : void 0;
  var Uri = class extends URI2 {
    constructor() {
      super(...arguments);
      this._formatted = null;
      this._fsPath = null;
    }
    get fsPath() {
      if (!this._fsPath) {
        this._fsPath = uriToFsPath(this, false);
      }
      return this._fsPath;
    }
    toString(skipEncoding = false) {
      if (!skipEncoding) {
        if (!this._formatted) {
          this._formatted = _asFormatted(this, false);
        }
        return this._formatted;
      } else {
        return _asFormatted(this, true);
      }
    }
    toJSON() {
      const res = {
        $mid: 1
        /* MarshalledId.Uri */
      };
      if (this._fsPath) {
        res.fsPath = this._fsPath;
        res._sep = _pathSepMarker;
      }
      if (this._formatted) {
        res.external = this._formatted;
      }
      if (this.path) {
        res.path = this.path;
      }
      if (this.scheme) {
        res.scheme = this.scheme;
      }
      if (this.authority) {
        res.authority = this.authority;
      }
      if (this.query) {
        res.query = this.query;
      }
      if (this.fragment) {
        res.fragment = this.fragment;
      }
      return res;
    }
  };
  var encodeTable = {
    [
      58
      /* CharCode.Colon */
    ]: "%3A",
    // gen-delims
    [
      47
      /* CharCode.Slash */
    ]: "%2F",
    [
      63
      /* CharCode.QuestionMark */
    ]: "%3F",
    [
      35
      /* CharCode.Hash */
    ]: "%23",
    [
      91
      /* CharCode.OpenSquareBracket */
    ]: "%5B",
    [
      93
      /* CharCode.CloseSquareBracket */
    ]: "%5D",
    [
      64
      /* CharCode.AtSign */
    ]: "%40",
    [
      33
      /* CharCode.ExclamationMark */
    ]: "%21",
    // sub-delims
    [
      36
      /* CharCode.DollarSign */
    ]: "%24",
    [
      38
      /* CharCode.Ampersand */
    ]: "%26",
    [
      39
      /* CharCode.SingleQuote */
    ]: "%27",
    [
      40
      /* CharCode.OpenParen */
    ]: "%28",
    [
      41
      /* CharCode.CloseParen */
    ]: "%29",
    [
      42
      /* CharCode.Asterisk */
    ]: "%2A",
    [
      43
      /* CharCode.Plus */
    ]: "%2B",
    [
      44
      /* CharCode.Comma */
    ]: "%2C",
    [
      59
      /* CharCode.Semicolon */
    ]: "%3B",
    [
      61
      /* CharCode.Equals */
    ]: "%3D",
    [
      32
      /* CharCode.Space */
    ]: "%20"
  };
  function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code = path.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value2;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value2 = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value2 = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value2 = uri.path.substr(1);
      }
    } else {
      value2 = uri.path;
    }
    if (isWindows) {
      value2 = value2.replace(/\//g, "\\");
    }
    return value2;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false, false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false, true);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(authority, false, true);
      } else {
        res += encoder(authority.substr(0, idx), false, true);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code = path.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code = path.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true, false);
    }
    if (query) {
      res += "?";
      res += encoder(query, false, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a4) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js
  var Position2 = class _Position {
    constructor(lineNumber, column) {
      this.lineNumber = lineNumber;
      this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
      if (newLineNumber === this.lineNumber && newColumn === this.column) {
        return this;
      } else {
        return new _Position(newLineNumber, newColumn);
      }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
      return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
      return _Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a2, b2) {
      if (!a2 && !b2) {
        return true;
      }
      return !!a2 && !!b2 && a2.lineNumber === b2.lineNumber && a2.column === b2.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
      return _Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a2, b2) {
      if (a2.lineNumber < b2.lineNumber) {
        return true;
      }
      if (b2.lineNumber < a2.lineNumber) {
        return false;
      }
      return a2.column < b2.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
      return _Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a2, b2) {
      if (a2.lineNumber < b2.lineNumber) {
        return true;
      }
      if (b2.lineNumber < a2.lineNumber) {
        return false;
      }
      return a2.column <= b2.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a2, b2) {
      const aLineNumber = a2.lineNumber | 0;
      const bLineNumber = b2.lineNumber | 0;
      if (aLineNumber === bLineNumber) {
        const aColumn = a2.column | 0;
        const bColumn = b2.column | 0;
        return aColumn - bColumn;
      }
      return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
      return new _Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")";
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
      return new _Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
      return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
    }
    toJSON() {
      return {
        lineNumber: this.lineNumber,
        column: this.column
      };
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js
  var Range2 = class _Range {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
      if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
        this.startLineNumber = endLineNumber;
        this.startColumn = endColumn;
        this.endLineNumber = startLineNumber;
        this.endColumn = startColumn;
      } else {
        this.startLineNumber = startLineNumber;
        this.startColumn = startColumn;
        this.endLineNumber = endLineNumber;
        this.endColumn = endColumn;
      }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
      return _Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
      return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position2) {
      return _Range.containsPosition(this, position2);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position2) {
      if (position2.lineNumber < range.startLineNumber || position2.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position2.lineNumber === range.startLineNumber && position2.column < range.startColumn) {
        return false;
      }
      if (position2.lineNumber === range.endLineNumber && position2.column > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range, position2) {
      if (position2.lineNumber < range.startLineNumber || position2.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position2.lineNumber === range.startLineNumber && position2.column <= range.startColumn) {
        return false;
      }
      if (position2.lineNumber === range.endLineNumber && position2.column >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
      return _Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
      return _Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
      return _Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a2, b2) {
      let startLineNumber;
      let startColumn;
      let endLineNumber;
      let endColumn;
      if (b2.startLineNumber < a2.startLineNumber) {
        startLineNumber = b2.startLineNumber;
        startColumn = b2.startColumn;
      } else if (b2.startLineNumber === a2.startLineNumber) {
        startLineNumber = b2.startLineNumber;
        startColumn = Math.min(b2.startColumn, a2.startColumn);
      } else {
        startLineNumber = a2.startLineNumber;
        startColumn = a2.startColumn;
      }
      if (b2.endLineNumber > a2.endLineNumber) {
        endLineNumber = b2.endLineNumber;
        endColumn = b2.endColumn;
      } else if (b2.endLineNumber === a2.endLineNumber) {
        endLineNumber = b2.endLineNumber;
        endColumn = Math.max(b2.endColumn, a2.endColumn);
      } else {
        endLineNumber = a2.endLineNumber;
        endColumn = a2.endColumn;
      }
      return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
      return _Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a2, b2) {
      let resultStartLineNumber = a2.startLineNumber;
      let resultStartColumn = a2.startColumn;
      let resultEndLineNumber = a2.endLineNumber;
      let resultEndColumn = a2.endColumn;
      const otherStartLineNumber = b2.startLineNumber;
      const otherStartColumn = b2.startColumn;
      const otherEndLineNumber = b2.endLineNumber;
      const otherEndColumn = b2.endColumn;
      if (resultStartLineNumber < otherStartLineNumber) {
        resultStartLineNumber = otherStartLineNumber;
        resultStartColumn = otherStartColumn;
      } else if (resultStartLineNumber === otherStartLineNumber) {
        resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
      }
      if (resultEndLineNumber > otherEndLineNumber) {
        resultEndLineNumber = otherEndLineNumber;
        resultEndColumn = otherEndColumn;
      } else if (resultEndLineNumber === otherEndLineNumber) {
        resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
      }
      if (resultStartLineNumber > resultEndLineNumber) {
        return null;
      }
      if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
        return null;
      }
      return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
      return _Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a2, b2) {
      if (!a2 && !b2) {
        return true;
      }
      return !!a2 && !!b2 && a2.startLineNumber === b2.startLineNumber && a2.startColumn === b2.startColumn && a2.endLineNumber === b2.endLineNumber && a2.endColumn === b2.endColumn;
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
      return _Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
      return new Position2(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
      return _Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
      return new Position2(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
      return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
      return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
      return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
      return _Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
      return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd() {
      return _Range.collapseToEnd(this);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range) {
      return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount) {
      return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
    }
    // ---
    static fromPositions(start, end = start) {
      return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    static lift(range) {
      if (!range) {
        return null;
      }
      return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
      return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a2, b2) {
      if (a2.endLineNumber < b2.startLineNumber || a2.endLineNumber === b2.startLineNumber && a2.endColumn < b2.startColumn) {
        return false;
      }
      if (b2.endLineNumber < a2.startLineNumber || b2.endLineNumber === a2.startLineNumber && b2.endColumn < a2.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a2, b2) {
      if (a2.endLineNumber < b2.startLineNumber || a2.endLineNumber === b2.startLineNumber && a2.endColumn <= b2.startColumn) {
        return false;
      }
      if (b2.endLineNumber < a2.startLineNumber || b2.endLineNumber === a2.startLineNumber && b2.endColumn <= a2.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a2, b2) {
      if (a2 && b2) {
        const aStartLineNumber = a2.startLineNumber | 0;
        const bStartLineNumber = b2.startLineNumber | 0;
        if (aStartLineNumber === bStartLineNumber) {
          const aStartColumn = a2.startColumn | 0;
          const bStartColumn = b2.startColumn | 0;
          if (aStartColumn === bStartColumn) {
            const aEndLineNumber = a2.endLineNumber | 0;
            const bEndLineNumber = b2.endLineNumber | 0;
            if (aEndLineNumber === bEndLineNumber) {
              const aEndColumn = a2.endColumn | 0;
              const bEndColumn = b2.endColumn | 0;
              return aEndColumn - bEndColumn;
            }
            return aEndLineNumber - bEndLineNumber;
          }
          return aStartColumn - bStartColumn;
        }
        return aStartLineNumber - bStartLineNumber;
      }
      const aExists = a2 ? 1 : 0;
      const bExists = b2 ? 1 : 0;
      return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a2, b2) {
      if (a2.endLineNumber === b2.endLineNumber) {
        if (a2.endColumn === b2.endColumn) {
          if (a2.startLineNumber === b2.startLineNumber) {
            return a2.startColumn - b2.startColumn;
          }
          return a2.startLineNumber - b2.startLineNumber;
        }
        return a2.endColumn - b2.endColumn;
      }
      return a2.endLineNumber - b2.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
      return range.endLineNumber > range.startLineNumber;
    }
    toJSON() {
      return this;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js
  function equals(one, other, itemEquals = (a2, b2) => a2 === b2) {
    if (one === other) {
      return true;
    }
    if (!one || !other) {
      return false;
    }
    if (one.length !== other.length) {
      return false;
    }
    for (let i2 = 0, len = one.length; i2 < len; i2++) {
      if (!itemEquals(one[i2], other[i2])) {
        return false;
      }
    }
    return true;
  }
  function* groupAdjacentBy(items, shouldBeGrouped) {
    let currentGroup;
    let last;
    for (const item of items) {
      if (last !== void 0 && shouldBeGrouped(last, item)) {
        currentGroup.push(item);
      } else {
        if (currentGroup) {
          yield currentGroup;
        }
        currentGroup = [item];
      }
      last = item;
    }
    if (currentGroup) {
      yield currentGroup;
    }
  }
  function forEachAdjacent(arr, f5) {
    for (let i2 = 0; i2 <= arr.length; i2++) {
      f5(i2 === 0 ? void 0 : arr[i2 - 1], i2 === arr.length ? void 0 : arr[i2]);
    }
  }
  function forEachWithNeighbors(arr, f5) {
    for (let i2 = 0; i2 < arr.length; i2++) {
      f5(i2 === 0 ? void 0 : arr[i2 - 1], arr[i2], i2 + 1 === arr.length ? void 0 : arr[i2 + 1]);
    }
  }
  function pushMany(arr, items) {
    for (const item of items) {
      arr.push(item);
    }
  }
  var CompareResult;
  (function(CompareResult2) {
    function isLessThan(result) {
      return result < 0;
    }
    CompareResult2.isLessThan = isLessThan;
    function isLessThanOrEqual(result) {
      return result <= 0;
    }
    CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
    function isGreaterThan(result) {
      return result > 0;
    }
    CompareResult2.isGreaterThan = isGreaterThan;
    function isNeitherLessOrGreaterThan(result) {
      return result === 0;
    }
    CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
    CompareResult2.greaterThan = 1;
    CompareResult2.lessThan = -1;
    CompareResult2.neitherLessOrGreaterThan = 0;
  })(CompareResult || (CompareResult = {}));
  function compareBy(selector, comparator) {
    return (a2, b2) => comparator(selector(a2), selector(b2));
  }
  var numberComparator = (a2, b2) => a2 - b2;
  function reverseOrder(comparator) {
    return (a2, b2) => -comparator(a2, b2);
  }
  var CallbackIterable = class _CallbackIterable {
    constructor(iterate) {
      this.iterate = iterate;
    }
    toArray() {
      const result = [];
      this.iterate((item) => {
        result.push(item);
        return true;
      });
      return result;
    }
    filter(predicate) {
      return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
    }
    map(mapFn) {
      return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
    }
    findLast(predicate) {
      let result;
      this.iterate((item) => {
        if (predicate(item)) {
          result = item;
        }
        return true;
      });
      return result;
    }
    findLastMaxBy(comparator) {
      let result;
      let first = true;
      this.iterate((item) => {
        if (first || CompareResult.isGreaterThan(comparator(item, result))) {
          first = false;
          result = item;
        }
        return true;
      });
      return result;
    }
  };
  CallbackIterable.empty = new CallbackIterable((_callback) => {
  });

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/uint.js
  function toUint8(v2) {
    if (v2 < 0) {
      return 0;
    }
    if (v2 > 255) {
      return 255;
    }
    return v2 | 0;
  }
  function toUint32(v2) {
    if (v2 < 0) {
      return 0;
    }
    if (v2 > 4294967295) {
      return 4294967295;
    }
    return v2 | 0;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer = class {
    constructor(values) {
      this.values = values;
      this.prefixSum = new Uint32Array(values.length);
      this.prefixSumValidIndex = new Int32Array(1);
      this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
      insertIndex = toUint32(insertIndex);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      const insertValuesLen = insertValues.length;
      if (insertValuesLen === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length + insertValuesLen);
      this.values.set(oldValues.subarray(0, insertIndex), 0);
      this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
      this.values.set(insertValues, insertIndex);
      if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = insertIndex - 1;
      }
      this.prefixSum = new Uint32Array(this.values.length);
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    setValue(index2, value2) {
      index2 = toUint32(index2);
      value2 = toUint32(value2);
      if (this.values[index2] === value2) {
        return false;
      }
      this.values[index2] = value2;
      if (index2 - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = index2 - 1;
      }
      return true;
    }
    removeValues(startIndex, count) {
      startIndex = toUint32(startIndex);
      count = toUint32(count);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      if (startIndex >= oldValues.length) {
        return false;
      }
      const maxCount = oldValues.length - startIndex;
      if (count >= maxCount) {
        count = maxCount;
      }
      if (count === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length - count);
      this.values.set(oldValues.subarray(0, startIndex), 0);
      this.values.set(oldValues.subarray(startIndex + count), startIndex);
      this.prefixSum = new Uint32Array(this.values.length);
      if (startIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = startIndex - 1;
      }
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    getTotalSum() {
      if (this.values.length === 0) {
        return 0;
      }
      return this._getPrefixSum(this.values.length - 1);
    }
    /**
     * Returns the sum of the first `index + 1` many items.
     * @returns `SUM(0 <= j <= index, values[j])`.
     */
    getPrefixSum(index2) {
      if (index2 < 0) {
        return 0;
      }
      index2 = toUint32(index2);
      return this._getPrefixSum(index2);
    }
    _getPrefixSum(index2) {
      if (index2 <= this.prefixSumValidIndex[0]) {
        return this.prefixSum[index2];
      }
      let startIndex = this.prefixSumValidIndex[0] + 1;
      if (startIndex === 0) {
        this.prefixSum[0] = this.values[0];
        startIndex++;
      }
      if (index2 >= this.values.length) {
        index2 = this.values.length - 1;
      }
      for (let i2 = startIndex; i2 <= index2; i2++) {
        this.prefixSum[i2] = this.prefixSum[i2 - 1] + this.values[i2];
      }
      this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index2);
      return this.prefixSum[index2];
    }
    getIndexOf(sum) {
      sum = Math.floor(sum);
      this.getTotalSum();
      let low = 0;
      let high = this.values.length - 1;
      let mid = 0;
      let midStop = 0;
      let midStart = 0;
      while (low <= high) {
        mid = low + (high - low) / 2 | 0;
        midStop = this.prefixSum[mid];
        midStart = midStop - this.values[mid];
        if (sum < midStart) {
          high = mid - 1;
        } else if (sum >= midStop) {
          low = mid + 1;
        } else {
          break;
        }
      }
      return new PrefixSumIndexOfResult(mid, sum - midStart);
    }
  };
  var PrefixSumIndexOfResult = class {
    constructor(index2, remainder) {
      this.index = index2;
      this.remainder = remainder;
      this._prefixSumIndexOfResultBrand = void 0;
      this.index = index2;
      this.remainder = remainder;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel = class {
    constructor(uri, lines, eol, versionId) {
      this._uri = uri;
      this._lines = lines;
      this._eol = eol;
      this._versionId = versionId;
      this._lineStarts = null;
      this._cachedTextValue = null;
    }
    dispose() {
      this._lines.length = 0;
    }
    get version() {
      return this._versionId;
    }
    getText() {
      if (this._cachedTextValue === null) {
        this._cachedTextValue = this._lines.join(this._eol);
      }
      return this._cachedTextValue;
    }
    onEvents(e5) {
      if (e5.eol && e5.eol !== this._eol) {
        this._eol = e5.eol;
        this._lineStarts = null;
      }
      const changes = e5.changes;
      for (const change of changes) {
        this._acceptDeleteRange(change.range);
        this._acceptInsertText(new Position2(change.range.startLineNumber, change.range.startColumn), change.text);
      }
      this._versionId = e5.versionId;
      this._cachedTextValue = null;
    }
    _ensureLineStarts() {
      if (!this._lineStarts) {
        const eolLength = this._eol.length;
        const linesLength = this._lines.length;
        const lineStartValues = new Uint32Array(linesLength);
        for (let i2 = 0; i2 < linesLength; i2++) {
          lineStartValues[i2] = this._lines[i2].length + eolLength;
        }
        this._lineStarts = new PrefixSumComputer(lineStartValues);
      }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
      this._lines[lineIndex] = newValue;
      if (this._lineStarts) {
        this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
      }
    }
    _acceptDeleteRange(range) {
      if (range.startLineNumber === range.endLineNumber) {
        if (range.startColumn === range.endColumn) {
          return;
        }
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
        return;
      }
      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
      this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      if (this._lineStarts) {
        this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      }
    }
    _acceptInsertText(position2, insertText) {
      if (insertText.length === 0) {
        return;
      }
      const insertLines = splitLines(insertText);
      if (insertLines.length === 1) {
        this._setLineText(position2.lineNumber - 1, this._lines[position2.lineNumber - 1].substring(0, position2.column - 1) + insertLines[0] + this._lines[position2.lineNumber - 1].substring(position2.column - 1));
        return;
      }
      insertLines[insertLines.length - 1] += this._lines[position2.lineNumber - 1].substring(position2.column - 1);
      this._setLineText(position2.lineNumber - 1, this._lines[position2.lineNumber - 1].substring(0, position2.column - 1) + insertLines[0]);
      const newLengths = new Uint32Array(insertLines.length - 1);
      for (let i2 = 1; i2 < insertLines.length; i2++) {
        this._lines.splice(position2.lineNumber + i2 - 1, 0, insertLines[i2]);
        newLengths[i2 - 1] = insertLines[i2].length + this._eol.length;
      }
      if (this._lineStarts) {
        this._lineStarts.insertValues(position2.lineNumber, newLengths);
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  var DEFAULT_WORD_REGEXP = createWordRegExp();
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  var _defaultConfig = new LinkedList();
  _defaultConfig.unshift({
    maxLen: 1e3,
    windowSize: 15,
    timeBudget: 150
  });
  function getWordAtText(column, wordDefinition, text2, textOffset, config) {
    wordDefinition = ensureValidWordDefinition(wordDefinition);
    if (!config) {
      config = Iterable.first(_defaultConfig);
    }
    if (text2.length > config.maxLen) {
      let start = column - config.maxLen / 2;
      if (start < 0) {
        start = 0;
      } else {
        textOffset += start;
      }
      text2 = text2.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text2, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i2 = 1; ; i2++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i2;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text2, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text2, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text2)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier = class _CharacterClassifier {
    constructor(_defaultValue) {
      const defaultValue = toUint8(_defaultValue);
      this._defaultValue = defaultValue;
      this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
      this._map = /* @__PURE__ */ new Map();
    }
    static _createAsciiMap(defaultValue) {
      const asciiMap = new Uint8Array(256);
      asciiMap.fill(defaultValue);
      return asciiMap;
    }
    set(charCode, _value) {
      const value2 = toUint8(_value);
      if (charCode >= 0 && charCode < 256) {
        this._asciiMap[charCode] = value2;
      } else {
        this._map.set(charCode, value2);
      }
    }
    get(charCode) {
      if (charCode >= 0 && charCode < 256) {
        return this._asciiMap[charCode];
      } else {
        return this._map.get(charCode) || this._defaultValue;
      }
    }
    clear() {
      this._asciiMap.fill(this._defaultValue);
      this._map.clear();
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
  var Uint8Matrix = class {
    constructor(rows, cols, defaultValue) {
      const data = new Uint8Array(rows * cols);
      for (let i2 = 0, len = rows * cols; i2 < len; i2++) {
        data[i2] = defaultValue;
      }
      this._data = data;
      this.rows = rows;
      this.cols = cols;
    }
    get(row, col) {
      return this._data[row * this.cols + col];
    }
    set(row, col, value2) {
      this._data[row * this.cols + col] = value2;
    }
  };
  var StateMachine = class {
    constructor(edges) {
      let maxCharCode = 0;
      let maxState = 0;
      for (let i2 = 0, len = edges.length; i2 < len; i2++) {
        const [from, chCode, to] = edges[i2];
        if (chCode > maxCharCode) {
          maxCharCode = chCode;
        }
        if (from > maxState) {
          maxState = from;
        }
        if (to > maxState) {
          maxState = to;
        }
      }
      maxCharCode++;
      maxState++;
      const states2 = new Uint8Matrix(
        maxState,
        maxCharCode,
        0
        /* State.Invalid */
      );
      for (let i2 = 0, len = edges.length; i2 < len; i2++) {
        const [from, chCode, to] = edges[i2];
        states2.set(from, chCode, to);
      }
      this._states = states2;
      this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
      if (chCode < 0 || chCode >= this._maxCharCode) {
        return 0;
      }
      return this._states.get(currentState, chCode);
    }
  };
  var _stateMachine = null;
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [
          1,
          104,
          2
          /* State.H */
        ],
        [
          1,
          72,
          2
          /* State.H */
        ],
        [
          1,
          102,
          6
          /* State.F */
        ],
        [
          1,
          70,
          6
          /* State.F */
        ],
        [
          2,
          116,
          3
          /* State.HT */
        ],
        [
          2,
          84,
          3
          /* State.HT */
        ],
        [
          3,
          116,
          4
          /* State.HTT */
        ],
        [
          3,
          84,
          4
          /* State.HTT */
        ],
        [
          4,
          112,
          5
          /* State.HTTP */
        ],
        [
          4,
          80,
          5
          /* State.HTTP */
        ],
        [
          5,
          115,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          83,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          58,
          10
          /* State.AfterColon */
        ],
        [
          6,
          105,
          7
          /* State.FI */
        ],
        [
          6,
          73,
          7
          /* State.FI */
        ],
        [
          7,
          108,
          8
          /* State.FIL */
        ],
        [
          7,
          76,
          8
          /* State.FIL */
        ],
        [
          8,
          101,
          9
          /* State.BeforeColon */
        ],
        [
          8,
          69,
          9
          /* State.BeforeColon */
        ],
        [
          9,
          58,
          10
          /* State.AfterColon */
        ],
        [
          10,
          47,
          11
          /* State.AlmostThere */
        ],
        [
          11,
          47,
          12
          /* State.End */
        ]
      ]);
    }
    return _stateMachine;
  }
  var _classifier = null;
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(
        0
        /* CharacterClass.None */
      );
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i2 = 0; i2 < FORCE_TERMINATION_CHARACTERS.length; i2++) {
        _classifier.set(
          FORCE_TERMINATION_CHARACTERS.charCodeAt(i2),
          1
          /* CharacterClass.ForceTermination */
        );
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;:";
      for (let i2 = 0; i2 < CANNOT_END_WITH_CHARACTERS.length; i2++) {
        _classifier.set(
          CANNOT_END_WITH_CHARACTERS.charCodeAt(i2),
          2
          /* CharacterClass.CannotEndIn */
        );
      }
    }
    return _classifier;
  }
  var LinkComputer = class _LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
      let lastIncludedCharIndex = linkEndIndex - 1;
      do {
        const chCode = line.charCodeAt(lastIncludedCharIndex);
        const chClass = classifier.get(chCode);
        if (chClass !== 2) {
          break;
        }
        lastIncludedCharIndex--;
      } while (lastIncludedCharIndex > linkBeginIndex);
      if (linkBeginIndex > 0) {
        const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
        const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
        if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
          lastIncludedCharIndex--;
        }
      }
      return {
        range: {
          startLineNumber: lineNumber,
          startColumn: linkBeginIndex + 1,
          endLineNumber: lineNumber,
          endColumn: lastIncludedCharIndex + 2
        },
        url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
      };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
      const classifier = getClassifier();
      const result = [];
      for (let i2 = 1, lineCount = model.getLineCount(); i2 <= lineCount; i2++) {
        const line = model.getLineContent(i2);
        const len = line.length;
        let j2 = 0;
        let linkBeginIndex = 0;
        let linkBeginChCode = 0;
        let state = 1;
        let hasOpenParens = false;
        let hasOpenSquareBracket = false;
        let inSquareBrackets = false;
        let hasOpenCurlyBracket = false;
        while (j2 < len) {
          let resetStateMachine = false;
          const chCode = line.charCodeAt(j2);
          if (state === 13) {
            let chClass;
            switch (chCode) {
              case 40:
                hasOpenParens = true;
                chClass = 0;
                break;
              case 41:
                chClass = hasOpenParens ? 0 : 1;
                break;
              case 91:
                inSquareBrackets = true;
                hasOpenSquareBracket = true;
                chClass = 0;
                break;
              case 93:
                inSquareBrackets = false;
                chClass = hasOpenSquareBracket ? 0 : 1;
                break;
              case 123:
                hasOpenCurlyBracket = true;
                chClass = 0;
                break;
              case 125:
                chClass = hasOpenCurlyBracket ? 0 : 1;
                break;
              case 39:
              case 34:
              case 96:
                if (linkBeginChCode === chCode) {
                  chClass = 1;
                } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                  chClass = 0;
                } else {
                  chClass = 1;
                }
                break;
              case 42:
                chClass = linkBeginChCode === 42 ? 1 : 0;
                break;
              case 124:
                chClass = linkBeginChCode === 124 ? 1 : 0;
                break;
              case 32:
                chClass = inSquareBrackets ? 0 : 1;
                break;
              default:
                chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              result.push(_LinkComputer._createLink(classifier, line, i2, linkBeginIndex, j2));
              resetStateMachine = true;
            }
          } else if (state === 12) {
            let chClass;
            if (chCode === 91) {
              hasOpenSquareBracket = true;
              chClass = 0;
            } else {
              chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              resetStateMachine = true;
            } else {
              state = 13;
            }
          } else {
            state = stateMachine.nextState(state, chCode);
            if (state === 0) {
              resetStateMachine = true;
            }
          }
          if (resetStateMachine) {
            state = 1;
            hasOpenParens = false;
            hasOpenSquareBracket = false;
            hasOpenCurlyBracket = false;
            linkBeginIndex = j2 + 1;
            linkBeginChCode = chCode;
          }
          j2++;
        }
        if (state === 13) {
          result.push(_LinkComputer._createLink(classifier, line, i2, linkBeginIndex, len));
        }
      }
      return result;
    }
  };
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace = class {
    constructor() {
      this._defaultValueSet = [
        ["true", "false"],
        ["True", "False"],
        ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
        ["public", "protected", "private"]
      ];
    }
    navigateValueSet(range1, text1, range2, text2, up) {
      if (range1 && text1) {
        const result = this.doNavigateValueSet(text1, up);
        if (result) {
          return {
            range: range1,
            value: result
          };
        }
      }
      if (range2 && text2) {
        const result = this.doNavigateValueSet(text2, up);
        if (result) {
          return {
            range: range2,
            value: result
          };
        }
      }
      return null;
    }
    doNavigateValueSet(text2, up) {
      const numberResult = this.numberReplace(text2, up);
      if (numberResult !== null) {
        return numberResult;
      }
      return this.textReplace(text2, up);
    }
    numberReplace(value2, up) {
      const precision = Math.pow(10, value2.length - (value2.lastIndexOf(".") + 1));
      let n1 = Number(value2);
      const n2 = parseFloat(value2);
      if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
        if (n1 === 0 && !up) {
          return null;
        } else {
          n1 = Math.floor(n1 * precision);
          n1 += up ? precision : -precision;
          return String(n1 / precision);
        }
      }
      return null;
    }
    textReplace(value2, up) {
      return this.valueSetsReplace(this._defaultValueSet, value2, up);
    }
    valueSetsReplace(valueSets, value2, up) {
      let result = null;
      for (let i2 = 0, len = valueSets.length; result === null && i2 < len; i2++) {
        result = this.valueSetReplace(valueSets[i2], value2, up);
      }
      return result;
    }
    valueSetReplace(valueSet, value2, up) {
      let idx = valueSet.indexOf(value2);
      if (idx >= 0) {
        idx += up ? 1 : -1;
        if (idx < 0) {
          idx = valueSet.length - 1;
        } else {
          idx %= valueSet.length;
        }
        return valueSet[idx];
      }
      return null;
    }
  };
  BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle = setTimeout(callback.bind(context), 0);
    return { dispose() {
      clearTimeout(handle);
    } };
  });
  var CancellationToken;
  (function(CancellationToken2) {
    function isCancellationToken(thing) {
      if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
        return true;
      }
      if (thing instanceof MutableToken) {
        return true;
      }
      if (!thing || typeof thing !== "object") {
        return false;
      }
      return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
    }
    CancellationToken2.isCancellationToken = isCancellationToken;
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: shortcutEvent
    });
  })(CancellationToken || (CancellationToken = {}));
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
      this._emitter = null;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = null;
      }
    }
  };
  var CancellationTokenSource = class {
    constructor(parent) {
      this._token = void 0;
      this._parentListener = void 0;
      this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else if (this._token instanceof MutableToken) {
        this._token.cancel();
      }
    }
    dispose(cancel = false) {
      var _a4;
      if (cancel) {
        this.cancel();
      }
      (_a4 = this._parentListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
  var KeyCodeStrMap = class {
    constructor() {
      this._keyCodeToStr = [];
      this._strToKeyCode = /* @__PURE__ */ Object.create(null);
    }
    define(keyCode, str) {
      this._keyCodeToStr[keyCode] = str;
      this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
      return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
      return this._strToKeyCode[str.toLowerCase()] || 0;
    }
  };
  var uiMap = new KeyCodeStrMap();
  var userSettingsUSMap = new KeyCodeStrMap();
  var userSettingsGeneralMap = new KeyCodeStrMap();
  var EVENT_KEY_CODE_MAP = new Array(230);
  var NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
  var scanCodeIntToStr = [];
  var scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
  var scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
  var IMMUTABLE_CODE_TO_KEY_CODE = [];
  var IMMUTABLE_KEY_CODE_TO_CODE = [];
  for (let i2 = 0; i2 <= 193; i2++) {
    IMMUTABLE_CODE_TO_KEY_CODE[i2] = -1;
  }
  for (let i2 = 0; i2 <= 132; i2++) {
    IMMUTABLE_KEY_CODE_TO_CODE[i2] = -1;
  }
  (function() {
    const empty = "";
    const mappings = [
      // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
      [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
      [1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
      [1, 2, "Super", 0, empty, 0, empty, empty, empty],
      [1, 3, "Fn", 0, empty, 0, empty, empty, empty],
      [1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
      [1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
      [1, 6, "Resume", 0, empty, 0, empty, empty, empty],
      [1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
      [1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
      [1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
      [0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
      [0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
      [0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
      [0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
      [0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
      [0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
      [0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
      [0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
      [0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
      [0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
      [0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
      [0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
      [0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
      [0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
      [0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
      [0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
      [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
      [0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
      [0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
      [0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
      [0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
      [0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
      [0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
      [0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
      [0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
      [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
      [0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
      [0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
      [0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
      [0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
      [0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
      [0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
      [0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
      [0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
      [0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
      [0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
      [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
      [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
      [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
      [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
      [1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
      [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
      [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
      [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
      [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
      [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
      [0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
      // has been dropped from the w3c spec
      [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
      [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
      [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
      [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
      [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
      [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
      [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
      [1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
      [1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
      [1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
      [1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
      [1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
      [1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
      [1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
      [1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
      [1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
      [1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
      [1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
      [1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
      [1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
      [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", empty, empty],
      [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
      [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
      [1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
      [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
      [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
      [1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
      [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
      [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
      [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
      [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
      [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
      [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", empty, empty],
      [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
      [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
      [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
      [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", empty, empty],
      [1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
      [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
      [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
      [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
      [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
      [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
      [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
      [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
      [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
      [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
      [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
      [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
      [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", empty, empty],
      [1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
      [1, 108, "Power", 0, empty, 0, empty, empty, empty],
      [1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
      [1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
      [1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
      [1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
      [1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
      [1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
      [1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
      [1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
      [1, 117, "F20", 78, "F20", 131, "VK_F20", empty, empty],
      [1, 118, "F21", 79, "F21", 132, "VK_F21", empty, empty],
      [1, 119, "F22", 80, "F22", 133, "VK_F22", empty, empty],
      [1, 120, "F23", 81, "F23", 134, "VK_F23", empty, empty],
      [1, 121, "F24", 82, "F24", 135, "VK_F24", empty, empty],
      [1, 122, "Open", 0, empty, 0, empty, empty, empty],
      [1, 123, "Help", 0, empty, 0, empty, empty, empty],
      [1, 124, "Select", 0, empty, 0, empty, empty, empty],
      [1, 125, "Again", 0, empty, 0, empty, empty, empty],
      [1, 126, "Undo", 0, empty, 0, empty, empty, empty],
      [1, 127, "Cut", 0, empty, 0, empty, empty, empty],
      [1, 128, "Copy", 0, empty, 0, empty, empty, empty],
      [1, 129, "Paste", 0, empty, 0, empty, empty, empty],
      [1, 130, "Find", 0, empty, 0, empty, empty, empty],
      [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
      [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
      [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
      [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
      [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
      [1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
      [0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
      [1, 138, "Convert", 0, empty, 0, empty, empty, empty],
      [1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
      [1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
      [1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
      [1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
      [1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
      [1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
      [1, 145, "Abort", 0, empty, 0, empty, empty, empty],
      [1, 146, "Props", 0, empty, 0, empty, empty, empty],
      [1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
      [1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
      [1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
      [1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
      [1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
      [1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
      [1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
      [1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
      [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", empty, empty],
      [1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
      [1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
      [1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
      [1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
      [1, 0, empty, 57, "Meta", 91, "VK_COMMAND", empty, empty],
      [1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
      [1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
      [1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
      [1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
      [1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
      [1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
      [1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
      [1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
      [1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
      [1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
      [1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
      [1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
      [1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
      [1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
      [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
      [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
      [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
      [1, 174, "Eject", 0, empty, 0, empty, empty, empty],
      [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
      [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
      [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
      [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
      [1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
      [1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
      [1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
      [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
      [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
      [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
      [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
      [1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
      [1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
      [1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
      [1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
      [1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
      [1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
      [1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
      // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
      // If an Input Method Editor is processing key input and the event is keydown, return 229.
      [1, 0, empty, 114, "KeyInComposition", 229, empty, empty, empty],
      [1, 0, empty, 116, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
      [1, 0, empty, 96, "OEM_8", 223, "VK_OEM_8", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
    ];
    const seenKeyCode = [];
    const seenScanCode = [];
    for (const mapping of mappings) {
      const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
      if (!seenScanCode[scanCode]) {
        seenScanCode[scanCode] = true;
        scanCodeIntToStr[scanCode] = scanCodeStr;
        scanCodeStrToInt[scanCodeStr] = scanCode;
        scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
        if (immutable) {
          IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
          if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
            IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
          }
        }
      }
      if (!seenKeyCode[keyCode]) {
        seenKeyCode[keyCode] = true;
        if (!keyCodeStr) {
          throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
        }
        uiMap.define(keyCode, keyCodeStr);
        userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
      }
      if (eventKeyCode) {
        EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
      }
      if (vkey) {
        NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
      }
    }
    IMMUTABLE_KEY_CODE_TO_CODE[
      3
      /* KeyCode.Enter */
    ] = 46;
  })();
  var KeyCodeUtils;
  (function(KeyCodeUtils2) {
    function toString2(keyCode) {
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toString = toString2;
    function fromString(key) {
      return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromString = fromString;
    function toUserSettingsUS(keyCode) {
      return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
      return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
      return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromUserSettings = fromUserSettings;
    function toElectronAccelerator(keyCode) {
      if (keyCode >= 98 && keyCode <= 113) {
        return null;
      }
      switch (keyCode) {
        case 16:
          return "Up";
        case 18:
          return "Down";
        case 15:
          return "Left";
        case 17:
          return "Right";
      }
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
  })(KeyCodeUtils || (KeyCodeUtils = {}));
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
  var Selection = class _Selection extends Range2 {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
      super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
      this.selectionStartLineNumber = selectionStartLineNumber;
      this.selectionStartColumn = selectionStartColumn;
      this.positionLineNumber = positionLineNumber;
      this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
      return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
      return _Selection.selectionsEqual(this, other);
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a2, b2) {
      return a2.selectionStartLineNumber === b2.selectionStartLineNumber && a2.selectionStartColumn === b2.selectionStartColumn && a2.positionLineNumber === b2.positionLineNumber && a2.positionColumn === b2.positionColumn;
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
      if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
        return 0;
      }
      return 1;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
      return new Position2(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart() {
      return new Position2(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start, end = start) {
      return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range, direction) {
      if (direction === 0) {
        return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      } else {
        return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
      }
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
      return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a2, b2) {
      if (a2 && !b2 || !a2 && b2) {
        return false;
      }
      if (!a2 && !b2) {
        return true;
      }
      if (a2.length !== b2.length) {
        return false;
      }
      for (let i2 = 0, len = a2.length; i2 < len; i2++) {
        if (!this.selectionsEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
      return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
      if (direction === 0) {
        return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js
  var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
  function register(id, fontCharacter) {
    if (isString(fontCharacter)) {
      const val = _codiconFontCharacters[fontCharacter];
      if (val === void 0) {
        throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
      }
      fontCharacter = val;
    }
    _codiconFontCharacters[id] = fontCharacter;
    return { id };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js
  var codiconsLibrary = {
    add: register("add", 6e4),
    plus: register("plus", 6e4),
    gistNew: register("gist-new", 6e4),
    repoCreate: register("repo-create", 6e4),
    lightbulb: register("lightbulb", 60001),
    lightBulb: register("light-bulb", 60001),
    repo: register("repo", 60002),
    repoDelete: register("repo-delete", 60002),
    gistFork: register("gist-fork", 60003),
    repoForked: register("repo-forked", 60003),
    gitPullRequest: register("git-pull-request", 60004),
    gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
    recordKeys: register("record-keys", 60005),
    keyboard: register("keyboard", 60005),
    tag: register("tag", 60006),
    gitPullRequestLabel: register("git-pull-request-label", 60006),
    tagAdd: register("tag-add", 60006),
    tagRemove: register("tag-remove", 60006),
    person: register("person", 60007),
    personFollow: register("person-follow", 60007),
    personOutline: register("person-outline", 60007),
    personFilled: register("person-filled", 60007),
    gitBranch: register("git-branch", 60008),
    gitBranchCreate: register("git-branch-create", 60008),
    gitBranchDelete: register("git-branch-delete", 60008),
    sourceControl: register("source-control", 60008),
    mirror: register("mirror", 60009),
    mirrorPublic: register("mirror-public", 60009),
    star: register("star", 60010),
    starAdd: register("star-add", 60010),
    starDelete: register("star-delete", 60010),
    starEmpty: register("star-empty", 60010),
    comment: register("comment", 60011),
    commentAdd: register("comment-add", 60011),
    alert: register("alert", 60012),
    warning: register("warning", 60012),
    search: register("search", 60013),
    searchSave: register("search-save", 60013),
    logOut: register("log-out", 60014),
    signOut: register("sign-out", 60014),
    logIn: register("log-in", 60015),
    signIn: register("sign-in", 60015),
    eye: register("eye", 60016),
    eyeUnwatch: register("eye-unwatch", 60016),
    eyeWatch: register("eye-watch", 60016),
    circleFilled: register("circle-filled", 60017),
    primitiveDot: register("primitive-dot", 60017),
    closeDirty: register("close-dirty", 60017),
    debugBreakpoint: register("debug-breakpoint", 60017),
    debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
    debugHint: register("debug-hint", 60017),
    terminalDecorationSuccess: register("terminal-decoration-success", 60017),
    primitiveSquare: register("primitive-square", 60018),
    edit: register("edit", 60019),
    pencil: register("pencil", 60019),
    info: register("info", 60020),
    issueOpened: register("issue-opened", 60020),
    gistPrivate: register("gist-private", 60021),
    gitForkPrivate: register("git-fork-private", 60021),
    lock: register("lock", 60021),
    mirrorPrivate: register("mirror-private", 60021),
    close: register("close", 60022),
    removeClose: register("remove-close", 60022),
    x: register("x", 60022),
    repoSync: register("repo-sync", 60023),
    sync: register("sync", 60023),
    clone: register("clone", 60024),
    desktopDownload: register("desktop-download", 60024),
    beaker: register("beaker", 60025),
    microscope: register("microscope", 60025),
    vm: register("vm", 60026),
    deviceDesktop: register("device-desktop", 60026),
    file: register("file", 60027),
    fileText: register("file-text", 60027),
    more: register("more", 60028),
    ellipsis: register("ellipsis", 60028),
    kebabHorizontal: register("kebab-horizontal", 60028),
    mailReply: register("mail-reply", 60029),
    reply: register("reply", 60029),
    organization: register("organization", 60030),
    organizationFilled: register("organization-filled", 60030),
    organizationOutline: register("organization-outline", 60030),
    newFile: register("new-file", 60031),
    fileAdd: register("file-add", 60031),
    newFolder: register("new-folder", 60032),
    fileDirectoryCreate: register("file-directory-create", 60032),
    trash: register("trash", 60033),
    trashcan: register("trashcan", 60033),
    history: register("history", 60034),
    clock: register("clock", 60034),
    folder: register("folder", 60035),
    fileDirectory: register("file-directory", 60035),
    symbolFolder: register("symbol-folder", 60035),
    logoGithub: register("logo-github", 60036),
    markGithub: register("mark-github", 60036),
    github: register("github", 60036),
    terminal: register("terminal", 60037),
    console: register("console", 60037),
    repl: register("repl", 60037),
    zap: register("zap", 60038),
    symbolEvent: register("symbol-event", 60038),
    error: register("error", 60039),
    stop: register("stop", 60039),
    variable: register("variable", 60040),
    symbolVariable: register("symbol-variable", 60040),
    array: register("array", 60042),
    symbolArray: register("symbol-array", 60042),
    symbolModule: register("symbol-module", 60043),
    symbolPackage: register("symbol-package", 60043),
    symbolNamespace: register("symbol-namespace", 60043),
    symbolObject: register("symbol-object", 60043),
    symbolMethod: register("symbol-method", 60044),
    symbolFunction: register("symbol-function", 60044),
    symbolConstructor: register("symbol-constructor", 60044),
    symbolBoolean: register("symbol-boolean", 60047),
    symbolNull: register("symbol-null", 60047),
    symbolNumeric: register("symbol-numeric", 60048),
    symbolNumber: register("symbol-number", 60048),
    symbolStructure: register("symbol-structure", 60049),
    symbolStruct: register("symbol-struct", 60049),
    symbolParameter: register("symbol-parameter", 60050),
    symbolTypeParameter: register("symbol-type-parameter", 60050),
    symbolKey: register("symbol-key", 60051),
    symbolText: register("symbol-text", 60051),
    symbolReference: register("symbol-reference", 60052),
    goToFile: register("go-to-file", 60052),
    symbolEnum: register("symbol-enum", 60053),
    symbolValue: register("symbol-value", 60053),
    symbolRuler: register("symbol-ruler", 60054),
    symbolUnit: register("symbol-unit", 60054),
    activateBreakpoints: register("activate-breakpoints", 60055),
    archive: register("archive", 60056),
    arrowBoth: register("arrow-both", 60057),
    arrowDown: register("arrow-down", 60058),
    arrowLeft: register("arrow-left", 60059),
    arrowRight: register("arrow-right", 60060),
    arrowSmallDown: register("arrow-small-down", 60061),
    arrowSmallLeft: register("arrow-small-left", 60062),
    arrowSmallRight: register("arrow-small-right", 60063),
    arrowSmallUp: register("arrow-small-up", 60064),
    arrowUp: register("arrow-up", 60065),
    bell: register("bell", 60066),
    bold: register("bold", 60067),
    book: register("book", 60068),
    bookmark: register("bookmark", 60069),
    debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
    debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
    debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
    debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
    debugBreakpointData: register("debug-breakpoint-data", 60073),
    debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
    debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
    debugBreakpointLog: register("debug-breakpoint-log", 60075),
    debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
    briefcase: register("briefcase", 60076),
    broadcast: register("broadcast", 60077),
    browser: register("browser", 60078),
    bug: register("bug", 60079),
    calendar: register("calendar", 60080),
    caseSensitive: register("case-sensitive", 60081),
    check: register("check", 60082),
    checklist: register("checklist", 60083),
    chevronDown: register("chevron-down", 60084),
    chevronLeft: register("chevron-left", 60085),
    chevronRight: register("chevron-right", 60086),
    chevronUp: register("chevron-up", 60087),
    chromeClose: register("chrome-close", 60088),
    chromeMaximize: register("chrome-maximize", 60089),
    chromeMinimize: register("chrome-minimize", 60090),
    chromeRestore: register("chrome-restore", 60091),
    circleOutline: register("circle-outline", 60092),
    circle: register("circle", 60092),
    debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
    terminalDecorationIncomplete: register("terminal-decoration-incomplete", 60092),
    circleSlash: register("circle-slash", 60093),
    circuitBoard: register("circuit-board", 60094),
    clearAll: register("clear-all", 60095),
    clippy: register("clippy", 60096),
    closeAll: register("close-all", 60097),
    cloudDownload: register("cloud-download", 60098),
    cloudUpload: register("cloud-upload", 60099),
    code: register("code", 60100),
    collapseAll: register("collapse-all", 60101),
    colorMode: register("color-mode", 60102),
    commentDiscussion: register("comment-discussion", 60103),
    creditCard: register("credit-card", 60105),
    dash: register("dash", 60108),
    dashboard: register("dashboard", 60109),
    database: register("database", 60110),
    debugContinue: register("debug-continue", 60111),
    debugDisconnect: register("debug-disconnect", 60112),
    debugPause: register("debug-pause", 60113),
    debugRestart: register("debug-restart", 60114),
    debugStart: register("debug-start", 60115),
    debugStepInto: register("debug-step-into", 60116),
    debugStepOut: register("debug-step-out", 60117),
    debugStepOver: register("debug-step-over", 60118),
    debugStop: register("debug-stop", 60119),
    debug: register("debug", 60120),
    deviceCameraVideo: register("device-camera-video", 60121),
    deviceCamera: register("device-camera", 60122),
    deviceMobile: register("device-mobile", 60123),
    diffAdded: register("diff-added", 60124),
    diffIgnored: register("diff-ignored", 60125),
    diffModified: register("diff-modified", 60126),
    diffRemoved: register("diff-removed", 60127),
    diffRenamed: register("diff-renamed", 60128),
    diff: register("diff", 60129),
    diffSidebyside: register("diff-sidebyside", 60129),
    discard: register("discard", 60130),
    editorLayout: register("editor-layout", 60131),
    emptyWindow: register("empty-window", 60132),
    exclude: register("exclude", 60133),
    extensions: register("extensions", 60134),
    eyeClosed: register("eye-closed", 60135),
    fileBinary: register("file-binary", 60136),
    fileCode: register("file-code", 60137),
    fileMedia: register("file-media", 60138),
    filePdf: register("file-pdf", 60139),
    fileSubmodule: register("file-submodule", 60140),
    fileSymlinkDirectory: register("file-symlink-directory", 60141),
    fileSymlinkFile: register("file-symlink-file", 60142),
    fileZip: register("file-zip", 60143),
    files: register("files", 60144),
    filter: register("filter", 60145),
    flame: register("flame", 60146),
    foldDown: register("fold-down", 60147),
    foldUp: register("fold-up", 60148),
    fold: register("fold", 60149),
    folderActive: register("folder-active", 60150),
    folderOpened: register("folder-opened", 60151),
    gear: register("gear", 60152),
    gift: register("gift", 60153),
    gistSecret: register("gist-secret", 60154),
    gist: register("gist", 60155),
    gitCommit: register("git-commit", 60156),
    gitCompare: register("git-compare", 60157),
    compareChanges: register("compare-changes", 60157),
    gitMerge: register("git-merge", 60158),
    githubAction: register("github-action", 60159),
    githubAlt: register("github-alt", 60160),
    globe: register("globe", 60161),
    grabber: register("grabber", 60162),
    graph: register("graph", 60163),
    gripper: register("gripper", 60164),
    heart: register("heart", 60165),
    home: register("home", 60166),
    horizontalRule: register("horizontal-rule", 60167),
    hubot: register("hubot", 60168),
    inbox: register("inbox", 60169),
    issueReopened: register("issue-reopened", 60171),
    issues: register("issues", 60172),
    italic: register("italic", 60173),
    jersey: register("jersey", 60174),
    json: register("json", 60175),
    kebabVertical: register("kebab-vertical", 60176),
    key: register("key", 60177),
    law: register("law", 60178),
    lightbulbAutofix: register("lightbulb-autofix", 60179),
    linkExternal: register("link-external", 60180),
    link: register("link", 60181),
    listOrdered: register("list-ordered", 60182),
    listUnordered: register("list-unordered", 60183),
    liveShare: register("live-share", 60184),
    loading: register("loading", 60185),
    location: register("location", 60186),
    mailRead: register("mail-read", 60187),
    mail: register("mail", 60188),
    markdown: register("markdown", 60189),
    megaphone: register("megaphone", 60190),
    mention: register("mention", 60191),
    milestone: register("milestone", 60192),
    gitPullRequestMilestone: register("git-pull-request-milestone", 60192),
    mortarBoard: register("mortar-board", 60193),
    move: register("move", 60194),
    multipleWindows: register("multiple-windows", 60195),
    mute: register("mute", 60196),
    noNewline: register("no-newline", 60197),
    note: register("note", 60198),
    octoface: register("octoface", 60199),
    openPreview: register("open-preview", 60200),
    package: register("package", 60201),
    paintcan: register("paintcan", 60202),
    pin: register("pin", 60203),
    play: register("play", 60204),
    run: register("run", 60204),
    plug: register("plug", 60205),
    preserveCase: register("preserve-case", 60206),
    preview: register("preview", 60207),
    project: register("project", 60208),
    pulse: register("pulse", 60209),
    question: register("question", 60210),
    quote: register("quote", 60211),
    radioTower: register("radio-tower", 60212),
    reactions: register("reactions", 60213),
    references: register("references", 60214),
    refresh: register("refresh", 60215),
    regex: register("regex", 60216),
    remoteExplorer: register("remote-explorer", 60217),
    remote: register("remote", 60218),
    remove: register("remove", 60219),
    replaceAll: register("replace-all", 60220),
    replace: register("replace", 60221),
    repoClone: register("repo-clone", 60222),
    repoForcePush: register("repo-force-push", 60223),
    repoPull: register("repo-pull", 60224),
    repoPush: register("repo-push", 60225),
    report: register("report", 60226),
    requestChanges: register("request-changes", 60227),
    rocket: register("rocket", 60228),
    rootFolderOpened: register("root-folder-opened", 60229),
    rootFolder: register("root-folder", 60230),
    rss: register("rss", 60231),
    ruby: register("ruby", 60232),
    saveAll: register("save-all", 60233),
    saveAs: register("save-as", 60234),
    save: register("save", 60235),
    screenFull: register("screen-full", 60236),
    screenNormal: register("screen-normal", 60237),
    searchStop: register("search-stop", 60238),
    server: register("server", 60240),
    settingsGear: register("settings-gear", 60241),
    settings: register("settings", 60242),
    shield: register("shield", 60243),
    smiley: register("smiley", 60244),
    sortPrecedence: register("sort-precedence", 60245),
    splitHorizontal: register("split-horizontal", 60246),
    splitVertical: register("split-vertical", 60247),
    squirrel: register("squirrel", 60248),
    starFull: register("star-full", 60249),
    starHalf: register("star-half", 60250),
    symbolClass: register("symbol-class", 60251),
    symbolColor: register("symbol-color", 60252),
    symbolConstant: register("symbol-constant", 60253),
    symbolEnumMember: register("symbol-enum-member", 60254),
    symbolField: register("symbol-field", 60255),
    symbolFile: register("symbol-file", 60256),
    symbolInterface: register("symbol-interface", 60257),
    symbolKeyword: register("symbol-keyword", 60258),
    symbolMisc: register("symbol-misc", 60259),
    symbolOperator: register("symbol-operator", 60260),
    symbolProperty: register("symbol-property", 60261),
    wrench: register("wrench", 60261),
    wrenchSubaction: register("wrench-subaction", 60261),
    symbolSnippet: register("symbol-snippet", 60262),
    tasklist: register("tasklist", 60263),
    telescope: register("telescope", 60264),
    textSize: register("text-size", 60265),
    threeBars: register("three-bars", 60266),
    thumbsdown: register("thumbsdown", 60267),
    thumbsup: register("thumbsup", 60268),
    tools: register("tools", 60269),
    triangleDown: register("triangle-down", 60270),
    triangleLeft: register("triangle-left", 60271),
    triangleRight: register("triangle-right", 60272),
    triangleUp: register("triangle-up", 60273),
    twitter: register("twitter", 60274),
    unfold: register("unfold", 60275),
    unlock: register("unlock", 60276),
    unmute: register("unmute", 60277),
    unverified: register("unverified", 60278),
    verified: register("verified", 60279),
    versions: register("versions", 60280),
    vmActive: register("vm-active", 60281),
    vmOutline: register("vm-outline", 60282),
    vmRunning: register("vm-running", 60283),
    watch: register("watch", 60284),
    whitespace: register("whitespace", 60285),
    wholeWord: register("whole-word", 60286),
    window: register("window", 60287),
    wordWrap: register("word-wrap", 60288),
    zoomIn: register("zoom-in", 60289),
    zoomOut: register("zoom-out", 60290),
    listFilter: register("list-filter", 60291),
    listFlat: register("list-flat", 60292),
    listSelection: register("list-selection", 60293),
    selection: register("selection", 60293),
    listTree: register("list-tree", 60294),
    debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
    debugBreakpointFunction: register("debug-breakpoint-function", 60296),
    debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
    debugStackframeActive: register("debug-stackframe-active", 60297),
    circleSmallFilled: register("circle-small-filled", 60298),
    debugStackframeDot: register("debug-stackframe-dot", 60298),
    terminalDecorationMark: register("terminal-decoration-mark", 60298),
    debugStackframe: register("debug-stackframe", 60299),
    debugStackframeFocused: register("debug-stackframe-focused", 60299),
    debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
    symbolString: register("symbol-string", 60301),
    debugReverseContinue: register("debug-reverse-continue", 60302),
    debugStepBack: register("debug-step-back", 60303),
    debugRestartFrame: register("debug-restart-frame", 60304),
    debugAlt: register("debug-alt", 60305),
    callIncoming: register("call-incoming", 60306),
    callOutgoing: register("call-outgoing", 60307),
    menu: register("menu", 60308),
    expandAll: register("expand-all", 60309),
    feedback: register("feedback", 60310),
    gitPullRequestReviewer: register("git-pull-request-reviewer", 60310),
    groupByRefType: register("group-by-ref-type", 60311),
    ungroupByRefType: register("ungroup-by-ref-type", 60312),
    account: register("account", 60313),
    gitPullRequestAssignee: register("git-pull-request-assignee", 60313),
    bellDot: register("bell-dot", 60314),
    debugConsole: register("debug-console", 60315),
    library: register("library", 60316),
    output: register("output", 60317),
    runAll: register("run-all", 60318),
    syncIgnored: register("sync-ignored", 60319),
    pinned: register("pinned", 60320),
    githubInverted: register("github-inverted", 60321),
    serverProcess: register("server-process", 60322),
    serverEnvironment: register("server-environment", 60323),
    pass: register("pass", 60324),
    issueClosed: register("issue-closed", 60324),
    stopCircle: register("stop-circle", 60325),
    playCircle: register("play-circle", 60326),
    record: register("record", 60327),
    debugAltSmall: register("debug-alt-small", 60328),
    vmConnect: register("vm-connect", 60329),
    cloud: register("cloud", 60330),
    merge: register("merge", 60331),
    export: register("export", 60332),
    graphLeft: register("graph-left", 60333),
    magnet: register("magnet", 60334),
    notebook: register("notebook", 60335),
    redo: register("redo", 60336),
    checkAll: register("check-all", 60337),
    pinnedDirty: register("pinned-dirty", 60338),
    passFilled: register("pass-filled", 60339),
    circleLargeFilled: register("circle-large-filled", 60340),
    circleLarge: register("circle-large", 60341),
    circleLargeOutline: register("circle-large-outline", 60341),
    combine: register("combine", 60342),
    gather: register("gather", 60342),
    table: register("table", 60343),
    variableGroup: register("variable-group", 60344),
    typeHierarchy: register("type-hierarchy", 60345),
    typeHierarchySub: register("type-hierarchy-sub", 60346),
    typeHierarchySuper: register("type-hierarchy-super", 60347),
    gitPullRequestCreate: register("git-pull-request-create", 60348),
    runAbove: register("run-above", 60349),
    runBelow: register("run-below", 60350),
    notebookTemplate: register("notebook-template", 60351),
    debugRerun: register("debug-rerun", 60352),
    workspaceTrusted: register("workspace-trusted", 60353),
    workspaceUntrusted: register("workspace-untrusted", 60354),
    workspaceUnknown: register("workspace-unknown", 60355),
    terminalCmd: register("terminal-cmd", 60356),
    terminalDebian: register("terminal-debian", 60357),
    terminalLinux: register("terminal-linux", 60358),
    terminalPowershell: register("terminal-powershell", 60359),
    terminalTmux: register("terminal-tmux", 60360),
    terminalUbuntu: register("terminal-ubuntu", 60361),
    terminalBash: register("terminal-bash", 60362),
    arrowSwap: register("arrow-swap", 60363),
    copy: register("copy", 60364),
    personAdd: register("person-add", 60365),
    filterFilled: register("filter-filled", 60366),
    wand: register("wand", 60367),
    debugLineByLine: register("debug-line-by-line", 60368),
    inspect: register("inspect", 60369),
    layers: register("layers", 60370),
    layersDot: register("layers-dot", 60371),
    layersActive: register("layers-active", 60372),
    compass: register("compass", 60373),
    compassDot: register("compass-dot", 60374),
    compassActive: register("compass-active", 60375),
    azure: register("azure", 60376),
    issueDraft: register("issue-draft", 60377),
    gitPullRequestClosed: register("git-pull-request-closed", 60378),
    gitPullRequestDraft: register("git-pull-request-draft", 60379),
    debugAll: register("debug-all", 60380),
    debugCoverage: register("debug-coverage", 60381),
    runErrors: register("run-errors", 60382),
    folderLibrary: register("folder-library", 60383),
    debugContinueSmall: register("debug-continue-small", 60384),
    beakerStop: register("beaker-stop", 60385),
    graphLine: register("graph-line", 60386),
    graphScatter: register("graph-scatter", 60387),
    pieChart: register("pie-chart", 60388),
    bracket: register("bracket", 60175),
    bracketDot: register("bracket-dot", 60389),
    bracketError: register("bracket-error", 60390),
    lockSmall: register("lock-small", 60391),
    azureDevops: register("azure-devops", 60392),
    verifiedFilled: register("verified-filled", 60393),
    newline: register("newline", 60394),
    layout: register("layout", 60395),
    layoutActivitybarLeft: register("layout-activitybar-left", 60396),
    layoutActivitybarRight: register("layout-activitybar-right", 60397),
    layoutPanelLeft: register("layout-panel-left", 60398),
    layoutPanelCenter: register("layout-panel-center", 60399),
    layoutPanelJustify: register("layout-panel-justify", 60400),
    layoutPanelRight: register("layout-panel-right", 60401),
    layoutPanel: register("layout-panel", 60402),
    layoutSidebarLeft: register("layout-sidebar-left", 60403),
    layoutSidebarRight: register("layout-sidebar-right", 60404),
    layoutStatusbar: register("layout-statusbar", 60405),
    layoutMenubar: register("layout-menubar", 60406),
    layoutCentered: register("layout-centered", 60407),
    target: register("target", 60408),
    indent: register("indent", 60409),
    recordSmall: register("record-small", 60410),
    errorSmall: register("error-small", 60411),
    terminalDecorationError: register("terminal-decoration-error", 60411),
    arrowCircleDown: register("arrow-circle-down", 60412),
    arrowCircleLeft: register("arrow-circle-left", 60413),
    arrowCircleRight: register("arrow-circle-right", 60414),
    arrowCircleUp: register("arrow-circle-up", 60415),
    layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
    layoutPanelOff: register("layout-panel-off", 60417),
    layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
    blank: register("blank", 60419),
    heartFilled: register("heart-filled", 60420),
    map: register("map", 60421),
    mapHorizontal: register("map-horizontal", 60421),
    foldHorizontal: register("fold-horizontal", 60421),
    mapFilled: register("map-filled", 60422),
    mapHorizontalFilled: register("map-horizontal-filled", 60422),
    foldHorizontalFilled: register("fold-horizontal-filled", 60422),
    circleSmall: register("circle-small", 60423),
    bellSlash: register("bell-slash", 60424),
    bellSlashDot: register("bell-slash-dot", 60425),
    commentUnresolved: register("comment-unresolved", 60426),
    gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
    gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
    searchFuzzy: register("search-fuzzy", 60429),
    commentDraft: register("comment-draft", 60430),
    send: register("send", 60431),
    sparkle: register("sparkle", 60432),
    insert: register("insert", 60433),
    mic: register("mic", 60434),
    thumbsdownFilled: register("thumbsdown-filled", 60435),
    thumbsupFilled: register("thumbsup-filled", 60436),
    coffee: register("coffee", 60437),
    snake: register("snake", 60438),
    game: register("game", 60439),
    vr: register("vr", 60440),
    chip: register("chip", 60441),
    piano: register("piano", 60442),
    music: register("music", 60443),
    micFilled: register("mic-filled", 60444),
    repoFetch: register("repo-fetch", 60445),
    copilot: register("copilot", 60446),
    lightbulbSparkle: register("lightbulb-sparkle", 60447),
    robot: register("robot", 60448),
    sparkleFilled: register("sparkle-filled", 60449),
    diffSingle: register("diff-single", 60450),
    diffMultiple: register("diff-multiple", 60451),
    surroundWith: register("surround-with", 60452),
    share: register("share", 60453),
    gitStash: register("git-stash", 60454),
    gitStashApply: register("git-stash-apply", 60455),
    gitStashPop: register("git-stash-pop", 60456),
    vscode: register("vscode", 60457),
    vscodeInsiders: register("vscode-insiders", 60458),
    codeOss: register("code-oss", 60459),
    runCoverage: register("run-coverage", 60460),
    runAllCoverage: register("run-all-coverage", 60461),
    coverage: register("coverage", 60462),
    githubProject: register("github-project", 60463),
    mapVertical: register("map-vertical", 60464),
    foldVertical: register("fold-vertical", 60464),
    mapVerticalFilled: register("map-vertical-filled", 60465),
    foldVerticalFilled: register("fold-vertical-filled", 60465),
    goToSearch: register("go-to-search", 60466),
    percentage: register("percentage", 60467),
    sortPercentage: register("sort-percentage", 60467)
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js
  var codiconsDerived = {
    dialogError: register("dialog-error", "error"),
    dialogWarning: register("dialog-warning", "warning"),
    dialogInfo: register("dialog-info", "info"),
    dialogClose: register("dialog-close", "close"),
    treeItemExpanded: register("tree-item-expanded", "chevron-down"),
    // collapsed is done with rotation
    treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
    treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
    treeFilterClear: register("tree-filter-clear", "close"),
    treeItemLoading: register("tree-item-loading", "loading"),
    menuSelection: register("menu-selection", "check"),
    menuSubmenu: register("menu-submenu", "chevron-right"),
    menuBarMore: register("menubar-more", "more"),
    scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
    scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
    scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
    scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
    toolBarMore: register("toolbar-more", "more"),
    quickInputBack: register("quick-input-back", "arrow-left"),
    dropDownButton: register("drop-down-button", 60084),
    symbolCustomColor: register("symbol-customcolor", 60252),
    exportIcon: register("export", 60332),
    workspaceUnspecified: register("workspace-unspecified", 60355),
    newLine: register("newline", 60394),
    thumbsDownFilled: register("thumbsdown-filled", 60435),
    thumbsUpFilled: register("thumbsup-filled", 60436),
    gitFetch: register("git-fetch", 60445),
    lightbulbSparkleAutofix: register("lightbulb-sparkle-autofix", 60447),
    debugBreakpointPending: register("debug-breakpoint-pending", 60377)
  };
  var Codicon = {
    ...codiconsLibrary,
    ...codiconsDerived
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
  var TokenizationRegistry = class {
    constructor() {
      this._tokenizationSupports = /* @__PURE__ */ new Map();
      this._factories = /* @__PURE__ */ new Map();
      this._onDidChange = new Emitter();
      this.onDidChange = this._onDidChange.event;
      this._colorMap = null;
    }
    handleChange(languageIds) {
      this._onDidChange.fire({
        changedLanguages: languageIds,
        changedColorMap: false
      });
    }
    register(languageId, support) {
      this._tokenizationSupports.set(languageId, support);
      this.handleChange([languageId]);
      return toDisposable(() => {
        if (this._tokenizationSupports.get(languageId) !== support) {
          return;
        }
        this._tokenizationSupports.delete(languageId);
        this.handleChange([languageId]);
      });
    }
    get(languageId) {
      return this._tokenizationSupports.get(languageId) || null;
    }
    registerFactory(languageId, factory) {
      var _a4;
      (_a4 = this._factories.get(languageId)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      const myData = new TokenizationSupportFactoryData(this, languageId, factory);
      this._factories.set(languageId, myData);
      return toDisposable(() => {
        const v2 = this._factories.get(languageId);
        if (!v2 || v2 !== myData) {
          return;
        }
        this._factories.delete(languageId);
        v2.dispose();
      });
    }
    async getOrCreate(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return tokenizationSupport;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return null;
      }
      await factory.resolve();
      return this.get(languageId);
    }
    isResolved(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return true;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return true;
      }
      return false;
    }
    setColorMap(colorMap) {
      this._colorMap = colorMap;
      this._onDidChange.fire({
        changedLanguages: Array.from(this._tokenizationSupports.keys()),
        changedColorMap: true
      });
    }
    getColorMap() {
      return this._colorMap;
    }
    getDefaultBackground() {
      if (this._colorMap && this._colorMap.length > 2) {
        return this._colorMap[
          2
          /* ColorId.DefaultBackground */
        ];
      }
      return null;
    }
  };
  var TokenizationSupportFactoryData = class extends Disposable {
    get isResolved() {
      return this._isResolved;
    }
    constructor(_registry, _languageId, _factory) {
      super();
      this._registry = _registry;
      this._languageId = _languageId;
      this._factory = _factory;
      this._isDisposed = false;
      this._resolvePromise = null;
      this._isResolved = false;
    }
    dispose() {
      this._isDisposed = true;
      super.dispose();
    }
    async resolve() {
      if (!this._resolvePromise) {
        this._resolvePromise = this._create();
      }
      return this._resolvePromise;
    }
    async _create() {
      const value2 = await this._factory.tokenizationSupport;
      this._isResolved = true;
      if (value2 && !this._isDisposed) {
        this._register(this._registry.register(this._languageId, value2));
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js
  var Token = class {
    constructor(offset, type, language) {
      this.offset = offset;
      this.type = type;
      this.language = language;
      this._tokenBrand = void 0;
    }
    toString() {
      return "(" + this.offset + ", " + this.type + ")";
    }
  };
  var HoverVerbosityAction;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction || (HoverVerbosityAction = {}));
  var CompletionItemKinds;
  (function(CompletionItemKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolMethod);
    byKind.set(1, Codicon.symbolFunction);
    byKind.set(2, Codicon.symbolConstructor);
    byKind.set(3, Codicon.symbolField);
    byKind.set(4, Codicon.symbolVariable);
    byKind.set(5, Codicon.symbolClass);
    byKind.set(6, Codicon.symbolStruct);
    byKind.set(7, Codicon.symbolInterface);
    byKind.set(8, Codicon.symbolModule);
    byKind.set(9, Codicon.symbolProperty);
    byKind.set(10, Codicon.symbolEvent);
    byKind.set(11, Codicon.symbolOperator);
    byKind.set(12, Codicon.symbolUnit);
    byKind.set(13, Codicon.symbolValue);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(14, Codicon.symbolConstant);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(16, Codicon.symbolEnumMember);
    byKind.set(17, Codicon.symbolKeyword);
    byKind.set(27, Codicon.symbolSnippet);
    byKind.set(18, Codicon.symbolText);
    byKind.set(19, Codicon.symbolColor);
    byKind.set(20, Codicon.symbolFile);
    byKind.set(21, Codicon.symbolReference);
    byKind.set(22, Codicon.symbolCustomColor);
    byKind.set(23, Codicon.symbolFolder);
    byKind.set(24, Codicon.symbolTypeParameter);
    byKind.set(25, Codicon.account);
    byKind.set(26, Codicon.issues);
    function toIcon(kind) {
      let codicon = byKind.get(kind);
      if (!codicon) {
        console.info("No codicon found for CompletionItemKind " + kind);
        codicon = Codicon.symbolProperty;
      }
      return codicon;
    }
    CompletionItemKinds2.toIcon = toIcon;
    const data = /* @__PURE__ */ new Map();
    data.set(
      "method",
      0
      /* CompletionItemKind.Method */
    );
    data.set(
      "function",
      1
      /* CompletionItemKind.Function */
    );
    data.set(
      "constructor",
      2
      /* CompletionItemKind.Constructor */
    );
    data.set(
      "field",
      3
      /* CompletionItemKind.Field */
    );
    data.set(
      "variable",
      4
      /* CompletionItemKind.Variable */
    );
    data.set(
      "class",
      5
      /* CompletionItemKind.Class */
    );
    data.set(
      "struct",
      6
      /* CompletionItemKind.Struct */
    );
    data.set(
      "interface",
      7
      /* CompletionItemKind.Interface */
    );
    data.set(
      "module",
      8
      /* CompletionItemKind.Module */
    );
    data.set(
      "property",
      9
      /* CompletionItemKind.Property */
    );
    data.set(
      "event",
      10
      /* CompletionItemKind.Event */
    );
    data.set(
      "operator",
      11
      /* CompletionItemKind.Operator */
    );
    data.set(
      "unit",
      12
      /* CompletionItemKind.Unit */
    );
    data.set(
      "value",
      13
      /* CompletionItemKind.Value */
    );
    data.set(
      "constant",
      14
      /* CompletionItemKind.Constant */
    );
    data.set(
      "enum",
      15
      /* CompletionItemKind.Enum */
    );
    data.set(
      "enum-member",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "enumMember",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "keyword",
      17
      /* CompletionItemKind.Keyword */
    );
    data.set(
      "snippet",
      27
      /* CompletionItemKind.Snippet */
    );
    data.set(
      "text",
      18
      /* CompletionItemKind.Text */
    );
    data.set(
      "color",
      19
      /* CompletionItemKind.Color */
    );
    data.set(
      "file",
      20
      /* CompletionItemKind.File */
    );
    data.set(
      "reference",
      21
      /* CompletionItemKind.Reference */
    );
    data.set(
      "customcolor",
      22
      /* CompletionItemKind.Customcolor */
    );
    data.set(
      "folder",
      23
      /* CompletionItemKind.Folder */
    );
    data.set(
      "type-parameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "typeParameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "account",
      25
      /* CompletionItemKind.User */
    );
    data.set(
      "issue",
      26
      /* CompletionItemKind.Issue */
    );
    function fromString(value2, strict) {
      let res = data.get(value2);
      if (typeof res === "undefined" && !strict) {
        res = 9;
      }
      return res;
    }
    CompletionItemKinds2.fromString = fromString;
  })(CompletionItemKinds || (CompletionItemKinds = {}));
  var InlineCompletionTriggerKind2;
  (function(InlineCompletionTriggerKind4) {
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
  var DocumentPasteTriggerKind;
  (function(DocumentPasteTriggerKind2) {
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["Automatic"] = 0] = "Automatic";
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["PasteAs"] = 1] = "PasteAs";
  })(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
  var DocumentHighlightKind2;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
    DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
    DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
  })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
  var symbolKindNames = {
    [
      17
      /* SymbolKind.Array */
    ]: localize("Array", "array"),
    [
      16
      /* SymbolKind.Boolean */
    ]: localize("Boolean", "boolean"),
    [
      4
      /* SymbolKind.Class */
    ]: localize("Class", "class"),
    [
      13
      /* SymbolKind.Constant */
    ]: localize("Constant", "constant"),
    [
      8
      /* SymbolKind.Constructor */
    ]: localize("Constructor", "constructor"),
    [
      9
      /* SymbolKind.Enum */
    ]: localize("Enum", "enumeration"),
    [
      21
      /* SymbolKind.EnumMember */
    ]: localize("EnumMember", "enumeration member"),
    [
      23
      /* SymbolKind.Event */
    ]: localize("Event", "event"),
    [
      7
      /* SymbolKind.Field */
    ]: localize("Field", "field"),
    [
      0
      /* SymbolKind.File */
    ]: localize("File", "file"),
    [
      11
      /* SymbolKind.Function */
    ]: localize("Function", "function"),
    [
      10
      /* SymbolKind.Interface */
    ]: localize("Interface", "interface"),
    [
      19
      /* SymbolKind.Key */
    ]: localize("Key", "key"),
    [
      5
      /* SymbolKind.Method */
    ]: localize("Method", "method"),
    [
      1
      /* SymbolKind.Module */
    ]: localize("Module", "module"),
    [
      2
      /* SymbolKind.Namespace */
    ]: localize("Namespace", "namespace"),
    [
      20
      /* SymbolKind.Null */
    ]: localize("Null", "null"),
    [
      15
      /* SymbolKind.Number */
    ]: localize("Number", "number"),
    [
      18
      /* SymbolKind.Object */
    ]: localize("Object", "object"),
    [
      24
      /* SymbolKind.Operator */
    ]: localize("Operator", "operator"),
    [
      3
      /* SymbolKind.Package */
    ]: localize("Package", "package"),
    [
      6
      /* SymbolKind.Property */
    ]: localize("Property", "property"),
    [
      14
      /* SymbolKind.String */
    ]: localize("String", "string"),
    [
      22
      /* SymbolKind.Struct */
    ]: localize("Struct", "struct"),
    [
      25
      /* SymbolKind.TypeParameter */
    ]: localize("TypeParameter", "type parameter"),
    [
      12
      /* SymbolKind.Variable */
    ]: localize("Variable", "variable")
  };
  var SymbolKinds;
  (function(SymbolKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolFile);
    byKind.set(1, Codicon.symbolModule);
    byKind.set(2, Codicon.symbolNamespace);
    byKind.set(3, Codicon.symbolPackage);
    byKind.set(4, Codicon.symbolClass);
    byKind.set(5, Codicon.symbolMethod);
    byKind.set(6, Codicon.symbolProperty);
    byKind.set(7, Codicon.symbolField);
    byKind.set(8, Codicon.symbolConstructor);
    byKind.set(9, Codicon.symbolEnum);
    byKind.set(10, Codicon.symbolInterface);
    byKind.set(11, Codicon.symbolFunction);
    byKind.set(12, Codicon.symbolVariable);
    byKind.set(13, Codicon.symbolConstant);
    byKind.set(14, Codicon.symbolString);
    byKind.set(15, Codicon.symbolNumber);
    byKind.set(16, Codicon.symbolBoolean);
    byKind.set(17, Codicon.symbolArray);
    byKind.set(18, Codicon.symbolObject);
    byKind.set(19, Codicon.symbolKey);
    byKind.set(20, Codicon.symbolNull);
    byKind.set(21, Codicon.symbolEnumMember);
    byKind.set(22, Codicon.symbolStruct);
    byKind.set(23, Codicon.symbolEvent);
    byKind.set(24, Codicon.symbolOperator);
    byKind.set(25, Codicon.symbolTypeParameter);
    function toIcon(kind) {
      let icon = byKind.get(kind);
      if (!icon) {
        console.info("No codicon found for SymbolKind " + kind);
        icon = Codicon.symbolProperty;
      }
      return icon;
    }
    SymbolKinds2.toIcon = toIcon;
  })(SymbolKinds || (SymbolKinds = {}));
  var FoldingRangeKind2 = class _FoldingRangeKind {
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value2) {
      switch (value2) {
        case "comment":
          return _FoldingRangeKind.Comment;
        case "imports":
          return _FoldingRangeKind.Imports;
        case "region":
          return _FoldingRangeKind.Region;
      }
      return new _FoldingRangeKind(value2);
    }
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value2) {
      this.value = value2;
    }
  };
  FoldingRangeKind2.Comment = new FoldingRangeKind2("comment");
  FoldingRangeKind2.Imports = new FoldingRangeKind2("imports");
  FoldingRangeKind2.Region = new FoldingRangeKind2("region");
  var NewSymbolNameTag;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag || (NewSymbolNameTag = {}));
  var NewSymbolNameTriggerKind;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));
  var Command2;
  (function(Command3) {
    function is(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return typeof obj.id === "string" && typeof obj.title === "string";
    }
    Command3.is = is;
  })(Command2 || (Command2 = {}));
  var InlayHintKind2;
  (function(InlayHintKind4) {
    InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
    InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
  })(InlayHintKind2 || (InlayHintKind2 = {}));
  var TokenizationRegistry2 = new TokenizationRegistry();
  var InlineEditTriggerKind;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind || (InlineEditTriggerKind = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport;
  (function(AccessibilitySupport2) {
    AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
    AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
    AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
  })(AccessibilitySupport || (AccessibilitySupport = {}));
  var CodeActionTriggerType;
  (function(CodeActionTriggerType2) {
    CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
    CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
  })(CodeActionTriggerType || (CodeActionTriggerType = {}));
  var CompletionItemInsertTextRule;
  (function(CompletionItemInsertTextRule2) {
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
  })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
  var CompletionItemKind2;
  (function(CompletionItemKind3) {
    CompletionItemKind3[CompletionItemKind3["Method"] = 0] = "Method";
    CompletionItemKind3[CompletionItemKind3["Function"] = 1] = "Function";
    CompletionItemKind3[CompletionItemKind3["Constructor"] = 2] = "Constructor";
    CompletionItemKind3[CompletionItemKind3["Field"] = 3] = "Field";
    CompletionItemKind3[CompletionItemKind3["Variable"] = 4] = "Variable";
    CompletionItemKind3[CompletionItemKind3["Class"] = 5] = "Class";
    CompletionItemKind3[CompletionItemKind3["Struct"] = 6] = "Struct";
    CompletionItemKind3[CompletionItemKind3["Interface"] = 7] = "Interface";
    CompletionItemKind3[CompletionItemKind3["Module"] = 8] = "Module";
    CompletionItemKind3[CompletionItemKind3["Property"] = 9] = "Property";
    CompletionItemKind3[CompletionItemKind3["Event"] = 10] = "Event";
    CompletionItemKind3[CompletionItemKind3["Operator"] = 11] = "Operator";
    CompletionItemKind3[CompletionItemKind3["Unit"] = 12] = "Unit";
    CompletionItemKind3[CompletionItemKind3["Value"] = 13] = "Value";
    CompletionItemKind3[CompletionItemKind3["Constant"] = 14] = "Constant";
    CompletionItemKind3[CompletionItemKind3["Enum"] = 15] = "Enum";
    CompletionItemKind3[CompletionItemKind3["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind3[CompletionItemKind3["Keyword"] = 17] = "Keyword";
    CompletionItemKind3[CompletionItemKind3["Text"] = 18] = "Text";
    CompletionItemKind3[CompletionItemKind3["Color"] = 19] = "Color";
    CompletionItemKind3[CompletionItemKind3["File"] = 20] = "File";
    CompletionItemKind3[CompletionItemKind3["Reference"] = 21] = "Reference";
    CompletionItemKind3[CompletionItemKind3["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind3[CompletionItemKind3["Folder"] = 23] = "Folder";
    CompletionItemKind3[CompletionItemKind3["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind3[CompletionItemKind3["User"] = 25] = "User";
    CompletionItemKind3[CompletionItemKind3["Issue"] = 26] = "Issue";
    CompletionItemKind3[CompletionItemKind3["Snippet"] = 27] = "Snippet";
  })(CompletionItemKind2 || (CompletionItemKind2 = {}));
  var CompletionItemTag2;
  (function(CompletionItemTag3) {
    CompletionItemTag3[CompletionItemTag3["Deprecated"] = 1] = "Deprecated";
  })(CompletionItemTag2 || (CompletionItemTag2 = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
  })(CompletionTriggerKind || (CompletionTriggerKind = {}));
  var ContentWidgetPositionPreference;
  (function(ContentWidgetPositionPreference2) {
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
  })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
  var CursorChangeReason;
  (function(CursorChangeReason2) {
    CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
    CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
    CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
    CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
    CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
    CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
  })(CursorChangeReason || (CursorChangeReason = {}));
  var DefaultEndOfLine;
  (function(DefaultEndOfLine2) {
    DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
    DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
  })(DefaultEndOfLine || (DefaultEndOfLine = {}));
  var DocumentHighlightKind3;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
    DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
    DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
  })(DocumentHighlightKind3 || (DocumentHighlightKind3 = {}));
  var EditorAutoIndentStrategy;
  (function(EditorAutoIndentStrategy2) {
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
  })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
  var EditorOption;
  (function(EditorOption2) {
    EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
    EditorOption2[EditorOption2["ariaRequired"] = 5] = "ariaRequired";
    EditorOption2[EditorOption2["autoClosingBrackets"] = 6] = "autoClosingBrackets";
    EditorOption2[EditorOption2["autoClosingComments"] = 7] = "autoClosingComments";
    EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
    EditorOption2[EditorOption2["autoClosingDelete"] = 9] = "autoClosingDelete";
    EditorOption2[EditorOption2["autoClosingOvertype"] = 10] = "autoClosingOvertype";
    EditorOption2[EditorOption2["autoClosingQuotes"] = 11] = "autoClosingQuotes";
    EditorOption2[EditorOption2["autoIndent"] = 12] = "autoIndent";
    EditorOption2[EditorOption2["automaticLayout"] = 13] = "automaticLayout";
    EditorOption2[EditorOption2["autoSurround"] = 14] = "autoSurround";
    EditorOption2[EditorOption2["bracketPairColorization"] = 15] = "bracketPairColorization";
    EditorOption2[EditorOption2["guides"] = 16] = "guides";
    EditorOption2[EditorOption2["codeLens"] = 17] = "codeLens";
    EditorOption2[EditorOption2["codeLensFontFamily"] = 18] = "codeLensFontFamily";
    EditorOption2[EditorOption2["codeLensFontSize"] = 19] = "codeLensFontSize";
    EditorOption2[EditorOption2["colorDecorators"] = 20] = "colorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
    EditorOption2[EditorOption2["columnSelection"] = 22] = "columnSelection";
    EditorOption2[EditorOption2["comments"] = 23] = "comments";
    EditorOption2[EditorOption2["contextmenu"] = 24] = "contextmenu";
    EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
    EditorOption2[EditorOption2["cursorBlinking"] = 26] = "cursorBlinking";
    EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
    EditorOption2[EditorOption2["cursorStyle"] = 28] = "cursorStyle";
    EditorOption2[EditorOption2["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
    EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
    EditorOption2[EditorOption2["cursorWidth"] = 31] = "cursorWidth";
    EditorOption2[EditorOption2["disableLayerHinting"] = 32] = "disableLayerHinting";
    EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
    EditorOption2[EditorOption2["domReadOnly"] = 34] = "domReadOnly";
    EditorOption2[EditorOption2["dragAndDrop"] = 35] = "dragAndDrop";
    EditorOption2[EditorOption2["dropIntoEditor"] = 36] = "dropIntoEditor";
    EditorOption2[EditorOption2["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
    EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
    EditorOption2[EditorOption2["extraEditorClassName"] = 39] = "extraEditorClassName";
    EditorOption2[EditorOption2["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
    EditorOption2[EditorOption2["find"] = 41] = "find";
    EditorOption2[EditorOption2["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
    EditorOption2[EditorOption2["folding"] = 43] = "folding";
    EditorOption2[EditorOption2["foldingStrategy"] = 44] = "foldingStrategy";
    EditorOption2[EditorOption2["foldingHighlight"] = 45] = "foldingHighlight";
    EditorOption2[EditorOption2["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
    EditorOption2[EditorOption2["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
    EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
    EditorOption2[EditorOption2["fontFamily"] = 49] = "fontFamily";
    EditorOption2[EditorOption2["fontInfo"] = 50] = "fontInfo";
    EditorOption2[EditorOption2["fontLigatures"] = 51] = "fontLigatures";
    EditorOption2[EditorOption2["fontSize"] = 52] = "fontSize";
    EditorOption2[EditorOption2["fontWeight"] = 53] = "fontWeight";
    EditorOption2[EditorOption2["fontVariations"] = 54] = "fontVariations";
    EditorOption2[EditorOption2["formatOnPaste"] = 55] = "formatOnPaste";
    EditorOption2[EditorOption2["formatOnType"] = 56] = "formatOnType";
    EditorOption2[EditorOption2["glyphMargin"] = 57] = "glyphMargin";
    EditorOption2[EditorOption2["gotoLocation"] = 58] = "gotoLocation";
    EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
    EditorOption2[EditorOption2["hover"] = 60] = "hover";
    EditorOption2[EditorOption2["inDiffEditor"] = 61] = "inDiffEditor";
    EditorOption2[EditorOption2["inlineSuggest"] = 62] = "inlineSuggest";
    EditorOption2[EditorOption2["inlineEdit"] = 63] = "inlineEdit";
    EditorOption2[EditorOption2["letterSpacing"] = 64] = "letterSpacing";
    EditorOption2[EditorOption2["lightbulb"] = 65] = "lightbulb";
    EditorOption2[EditorOption2["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
    EditorOption2[EditorOption2["lineHeight"] = 67] = "lineHeight";
    EditorOption2[EditorOption2["lineNumbers"] = 68] = "lineNumbers";
    EditorOption2[EditorOption2["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
    EditorOption2[EditorOption2["linkedEditing"] = 70] = "linkedEditing";
    EditorOption2[EditorOption2["links"] = 71] = "links";
    EditorOption2[EditorOption2["matchBrackets"] = 72] = "matchBrackets";
    EditorOption2[EditorOption2["minimap"] = 73] = "minimap";
    EditorOption2[EditorOption2["mouseStyle"] = 74] = "mouseStyle";
    EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
    EditorOption2[EditorOption2["mouseWheelZoom"] = 76] = "mouseWheelZoom";
    EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
    EditorOption2[EditorOption2["multiCursorModifier"] = 78] = "multiCursorModifier";
    EditorOption2[EditorOption2["multiCursorPaste"] = 79] = "multiCursorPaste";
    EditorOption2[EditorOption2["multiCursorLimit"] = 80] = "multiCursorLimit";
    EditorOption2[EditorOption2["occurrencesHighlight"] = 81] = "occurrencesHighlight";
    EditorOption2[EditorOption2["overviewRulerBorder"] = 82] = "overviewRulerBorder";
    EditorOption2[EditorOption2["overviewRulerLanes"] = 83] = "overviewRulerLanes";
    EditorOption2[EditorOption2["padding"] = 84] = "padding";
    EditorOption2[EditorOption2["pasteAs"] = 85] = "pasteAs";
    EditorOption2[EditorOption2["parameterHints"] = 86] = "parameterHints";
    EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
    EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 88] = "definitionLinkOpensInPeek";
    EditorOption2[EditorOption2["quickSuggestions"] = 89] = "quickSuggestions";
    EditorOption2[EditorOption2["quickSuggestionsDelay"] = 90] = "quickSuggestionsDelay";
    EditorOption2[EditorOption2["readOnly"] = 91] = "readOnly";
    EditorOption2[EditorOption2["readOnlyMessage"] = 92] = "readOnlyMessage";
    EditorOption2[EditorOption2["renameOnType"] = 93] = "renameOnType";
    EditorOption2[EditorOption2["renderControlCharacters"] = 94] = "renderControlCharacters";
    EditorOption2[EditorOption2["renderFinalNewline"] = 95] = "renderFinalNewline";
    EditorOption2[EditorOption2["renderLineHighlight"] = 96] = "renderLineHighlight";
    EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 97] = "renderLineHighlightOnlyWhenFocus";
    EditorOption2[EditorOption2["renderValidationDecorations"] = 98] = "renderValidationDecorations";
    EditorOption2[EditorOption2["renderWhitespace"] = 99] = "renderWhitespace";
    EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 100] = "revealHorizontalRightPadding";
    EditorOption2[EditorOption2["roundedSelection"] = 101] = "roundedSelection";
    EditorOption2[EditorOption2["rulers"] = 102] = "rulers";
    EditorOption2[EditorOption2["scrollbar"] = 103] = "scrollbar";
    EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 104] = "scrollBeyondLastColumn";
    EditorOption2[EditorOption2["scrollBeyondLastLine"] = 105] = "scrollBeyondLastLine";
    EditorOption2[EditorOption2["scrollPredominantAxis"] = 106] = "scrollPredominantAxis";
    EditorOption2[EditorOption2["selectionClipboard"] = 107] = "selectionClipboard";
    EditorOption2[EditorOption2["selectionHighlight"] = 108] = "selectionHighlight";
    EditorOption2[EditorOption2["selectOnLineNumbers"] = 109] = "selectOnLineNumbers";
    EditorOption2[EditorOption2["showFoldingControls"] = 110] = "showFoldingControls";
    EditorOption2[EditorOption2["showUnused"] = 111] = "showUnused";
    EditorOption2[EditorOption2["snippetSuggestions"] = 112] = "snippetSuggestions";
    EditorOption2[EditorOption2["smartSelect"] = 113] = "smartSelect";
    EditorOption2[EditorOption2["smoothScrolling"] = 114] = "smoothScrolling";
    EditorOption2[EditorOption2["stickyScroll"] = 115] = "stickyScroll";
    EditorOption2[EditorOption2["stickyTabStops"] = 116] = "stickyTabStops";
    EditorOption2[EditorOption2["stopRenderingLineAfter"] = 117] = "stopRenderingLineAfter";
    EditorOption2[EditorOption2["suggest"] = 118] = "suggest";
    EditorOption2[EditorOption2["suggestFontSize"] = 119] = "suggestFontSize";
    EditorOption2[EditorOption2["suggestLineHeight"] = 120] = "suggestLineHeight";
    EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 121] = "suggestOnTriggerCharacters";
    EditorOption2[EditorOption2["suggestSelection"] = 122] = "suggestSelection";
    EditorOption2[EditorOption2["tabCompletion"] = 123] = "tabCompletion";
    EditorOption2[EditorOption2["tabIndex"] = 124] = "tabIndex";
    EditorOption2[EditorOption2["unicodeHighlighting"] = 125] = "unicodeHighlighting";
    EditorOption2[EditorOption2["unusualLineTerminators"] = 126] = "unusualLineTerminators";
    EditorOption2[EditorOption2["useShadowDOM"] = 127] = "useShadowDOM";
    EditorOption2[EditorOption2["useTabStops"] = 128] = "useTabStops";
    EditorOption2[EditorOption2["wordBreak"] = 129] = "wordBreak";
    EditorOption2[EditorOption2["wordSegmenterLocales"] = 130] = "wordSegmenterLocales";
    EditorOption2[EditorOption2["wordSeparators"] = 131] = "wordSeparators";
    EditorOption2[EditorOption2["wordWrap"] = 132] = "wordWrap";
    EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 133] = "wordWrapBreakAfterCharacters";
    EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 134] = "wordWrapBreakBeforeCharacters";
    EditorOption2[EditorOption2["wordWrapColumn"] = 135] = "wordWrapColumn";
    EditorOption2[EditorOption2["wordWrapOverride1"] = 136] = "wordWrapOverride1";
    EditorOption2[EditorOption2["wordWrapOverride2"] = 137] = "wordWrapOverride2";
    EditorOption2[EditorOption2["wrappingIndent"] = 138] = "wrappingIndent";
    EditorOption2[EditorOption2["wrappingStrategy"] = 139] = "wrappingStrategy";
    EditorOption2[EditorOption2["showDeprecated"] = 140] = "showDeprecated";
    EditorOption2[EditorOption2["inlayHints"] = 141] = "inlayHints";
    EditorOption2[EditorOption2["editorClassName"] = 142] = "editorClassName";
    EditorOption2[EditorOption2["pixelRatio"] = 143] = "pixelRatio";
    EditorOption2[EditorOption2["tabFocusMode"] = 144] = "tabFocusMode";
    EditorOption2[EditorOption2["layoutInfo"] = 145] = "layoutInfo";
    EditorOption2[EditorOption2["wrappingInfo"] = 146] = "wrappingInfo";
    EditorOption2[EditorOption2["defaultColorDecorators"] = 147] = "defaultColorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 148] = "colorDecoratorsActivatedOn";
    EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 149] = "inlineCompletionsAccessibilityVerbose";
  })(EditorOption || (EditorOption = {}));
  var EndOfLinePreference;
  (function(EndOfLinePreference2) {
    EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
    EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
    EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
  })(EndOfLinePreference || (EndOfLinePreference = {}));
  var EndOfLineSequence;
  (function(EndOfLineSequence2) {
    EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
    EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
  })(EndOfLineSequence || (EndOfLineSequence = {}));
  var GlyphMarginLane;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane || (GlyphMarginLane = {}));
  var HoverVerbosityAction2;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction2 || (HoverVerbosityAction2 = {}));
  var IndentAction;
  (function(IndentAction2) {
    IndentAction2[IndentAction2["None"] = 0] = "None";
    IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
    IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
    IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
  })(IndentAction || (IndentAction = {}));
  var InjectedTextCursorStops;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
  var InlayHintKind3;
  (function(InlayHintKind4) {
    InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
    InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
  })(InlayHintKind3 || (InlayHintKind3 = {}));
  var InlineCompletionTriggerKind3;
  (function(InlineCompletionTriggerKind4) {
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind3 || (InlineCompletionTriggerKind3 = {}));
  var InlineEditTriggerKind2;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind2 || (InlineEditTriggerKind2 = {}));
  var KeyCode;
  (function(KeyCode2) {
    KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
    KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
    KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
    KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
    KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
    KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
    KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
    KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
    KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
    KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
    KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
    KeyCode2[KeyCode2["Space"] = 10] = "Space";
    KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
    KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
    KeyCode2[KeyCode2["End"] = 13] = "End";
    KeyCode2[KeyCode2["Home"] = 14] = "Home";
    KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
    KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
    KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
    KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
    KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
    KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
    KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
    KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
    KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
    KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
    KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
    KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
    KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
    KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
    KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
    KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
    KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
    KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
    KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
    KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
    KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
    KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
    KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
    KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
    KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
    KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
    KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
    KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
    KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
    KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
    KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
    KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
    KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
    KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
    KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
    KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
    KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
    KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
    KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
    KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
    KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
    KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
    KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
    KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
    KeyCode2[KeyCode2["F1"] = 59] = "F1";
    KeyCode2[KeyCode2["F2"] = 60] = "F2";
    KeyCode2[KeyCode2["F3"] = 61] = "F3";
    KeyCode2[KeyCode2["F4"] = 62] = "F4";
    KeyCode2[KeyCode2["F5"] = 63] = "F5";
    KeyCode2[KeyCode2["F6"] = 64] = "F6";
    KeyCode2[KeyCode2["F7"] = 65] = "F7";
    KeyCode2[KeyCode2["F8"] = 66] = "F8";
    KeyCode2[KeyCode2["F9"] = 67] = "F9";
    KeyCode2[KeyCode2["F10"] = 68] = "F10";
    KeyCode2[KeyCode2["F11"] = 69] = "F11";
    KeyCode2[KeyCode2["F12"] = 70] = "F12";
    KeyCode2[KeyCode2["F13"] = 71] = "F13";
    KeyCode2[KeyCode2["F14"] = 72] = "F14";
    KeyCode2[KeyCode2["F15"] = 73] = "F15";
    KeyCode2[KeyCode2["F16"] = 74] = "F16";
    KeyCode2[KeyCode2["F17"] = 75] = "F17";
    KeyCode2[KeyCode2["F18"] = 76] = "F18";
    KeyCode2[KeyCode2["F19"] = 77] = "F19";
    KeyCode2[KeyCode2["F20"] = 78] = "F20";
    KeyCode2[KeyCode2["F21"] = 79] = "F21";
    KeyCode2[KeyCode2["F22"] = 80] = "F22";
    KeyCode2[KeyCode2["F23"] = 81] = "F23";
    KeyCode2[KeyCode2["F24"] = 82] = "F24";
    KeyCode2[KeyCode2["NumLock"] = 83] = "NumLock";
    KeyCode2[KeyCode2["ScrollLock"] = 84] = "ScrollLock";
    KeyCode2[KeyCode2["Semicolon"] = 85] = "Semicolon";
    KeyCode2[KeyCode2["Equal"] = 86] = "Equal";
    KeyCode2[KeyCode2["Comma"] = 87] = "Comma";
    KeyCode2[KeyCode2["Minus"] = 88] = "Minus";
    KeyCode2[KeyCode2["Period"] = 89] = "Period";
    KeyCode2[KeyCode2["Slash"] = 90] = "Slash";
    KeyCode2[KeyCode2["Backquote"] = 91] = "Backquote";
    KeyCode2[KeyCode2["BracketLeft"] = 92] = "BracketLeft";
    KeyCode2[KeyCode2["Backslash"] = 93] = "Backslash";
    KeyCode2[KeyCode2["BracketRight"] = 94] = "BracketRight";
    KeyCode2[KeyCode2["Quote"] = 95] = "Quote";
    KeyCode2[KeyCode2["OEM_8"] = 96] = "OEM_8";
    KeyCode2[KeyCode2["IntlBackslash"] = 97] = "IntlBackslash";
    KeyCode2[KeyCode2["Numpad0"] = 98] = "Numpad0";
    KeyCode2[KeyCode2["Numpad1"] = 99] = "Numpad1";
    KeyCode2[KeyCode2["Numpad2"] = 100] = "Numpad2";
    KeyCode2[KeyCode2["Numpad3"] = 101] = "Numpad3";
    KeyCode2[KeyCode2["Numpad4"] = 102] = "Numpad4";
    KeyCode2[KeyCode2["Numpad5"] = 103] = "Numpad5";
    KeyCode2[KeyCode2["Numpad6"] = 104] = "Numpad6";
    KeyCode2[KeyCode2["Numpad7"] = 105] = "Numpad7";
    KeyCode2[KeyCode2["Numpad8"] = 106] = "Numpad8";
    KeyCode2[KeyCode2["Numpad9"] = 107] = "Numpad9";
    KeyCode2[KeyCode2["NumpadMultiply"] = 108] = "NumpadMultiply";
    KeyCode2[KeyCode2["NumpadAdd"] = 109] = "NumpadAdd";
    KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
    KeyCode2[KeyCode2["NumpadSubtract"] = 111] = "NumpadSubtract";
    KeyCode2[KeyCode2["NumpadDecimal"] = 112] = "NumpadDecimal";
    KeyCode2[KeyCode2["NumpadDivide"] = 113] = "NumpadDivide";
    KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
    KeyCode2[KeyCode2["ABNT_C1"] = 115] = "ABNT_C1";
    KeyCode2[KeyCode2["ABNT_C2"] = 116] = "ABNT_C2";
    KeyCode2[KeyCode2["AudioVolumeMute"] = 117] = "AudioVolumeMute";
    KeyCode2[KeyCode2["AudioVolumeUp"] = 118] = "AudioVolumeUp";
    KeyCode2[KeyCode2["AudioVolumeDown"] = 119] = "AudioVolumeDown";
    KeyCode2[KeyCode2["BrowserSearch"] = 120] = "BrowserSearch";
    KeyCode2[KeyCode2["BrowserHome"] = 121] = "BrowserHome";
    KeyCode2[KeyCode2["BrowserBack"] = 122] = "BrowserBack";
    KeyCode2[KeyCode2["BrowserForward"] = 123] = "BrowserForward";
    KeyCode2[KeyCode2["MediaTrackNext"] = 124] = "MediaTrackNext";
    KeyCode2[KeyCode2["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
    KeyCode2[KeyCode2["MediaStop"] = 126] = "MediaStop";
    KeyCode2[KeyCode2["MediaPlayPause"] = 127] = "MediaPlayPause";
    KeyCode2[KeyCode2["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
    KeyCode2[KeyCode2["LaunchMail"] = 129] = "LaunchMail";
    KeyCode2[KeyCode2["LaunchApp2"] = 130] = "LaunchApp2";
    KeyCode2[KeyCode2["Clear"] = 131] = "Clear";
    KeyCode2[KeyCode2["MAX_VALUE"] = 132] = "MAX_VALUE";
  })(KeyCode || (KeyCode = {}));
  var MarkerSeverity;
  (function(MarkerSeverity2) {
    MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
    MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
    MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
    MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
  })(MarkerSeverity || (MarkerSeverity = {}));
  var MarkerTag;
  (function(MarkerTag2) {
    MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
  })(MarkerTag || (MarkerTag = {}));
  var MinimapPosition;
  (function(MinimapPosition2) {
    MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
    MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
  })(MinimapPosition || (MinimapPosition = {}));
  var MinimapSectionHeaderStyle;
  (function(MinimapSectionHeaderStyle2) {
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Normal"] = 1] = "Normal";
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Underlined"] = 2] = "Underlined";
  })(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));
  var MouseTargetType;
  (function(MouseTargetType2) {
    MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
    MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
    MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
    MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
  })(MouseTargetType || (MouseTargetType = {}));
  var NewSymbolNameTag2;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));
  var NewSymbolNameTriggerKind2;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind2 || (NewSymbolNameTriggerKind2 = {}));
  var OverlayWidgetPositionPreference;
  (function(OverlayWidgetPositionPreference2) {
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
  })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
  var OverviewRulerLane;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane || (OverviewRulerLane = {}));
  var PartialAcceptTriggerKind;
  (function(PartialAcceptTriggerKind2) {
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Word"] = 0] = "Word";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Line"] = 1] = "Line";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Suggest"] = 2] = "Suggest";
  })(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));
  var PositionAffinity;
  (function(PositionAffinity2) {
    PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
    PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
    PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
    PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
    PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
  })(PositionAffinity || (PositionAffinity = {}));
  var RenderLineNumbersType;
  (function(RenderLineNumbersType2) {
    RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
    RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
    RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
    RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
    RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
  })(RenderLineNumbersType || (RenderLineNumbersType = {}));
  var RenderMinimap;
  (function(RenderMinimap2) {
    RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
    RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
    RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
  })(RenderMinimap || (RenderMinimap = {}));
  var ScrollType;
  (function(ScrollType2) {
    ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
    ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
  })(ScrollType || (ScrollType = {}));
  var ScrollbarVisibility;
  (function(ScrollbarVisibility2) {
    ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
    ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
  })(ScrollbarVisibility || (ScrollbarVisibility = {}));
  var SelectionDirection;
  (function(SelectionDirection2) {
    SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
    SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
  })(SelectionDirection || (SelectionDirection = {}));
  var ShowLightbulbIconMode;
  (function(ShowLightbulbIconMode2) {
    ShowLightbulbIconMode2["Off"] = "off";
    ShowLightbulbIconMode2["OnCode"] = "onCode";
    ShowLightbulbIconMode2["On"] = "on";
  })(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
  var SignatureHelpTriggerKind2;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
  var SymbolKind2;
  (function(SymbolKind3) {
    SymbolKind3[SymbolKind3["File"] = 0] = "File";
    SymbolKind3[SymbolKind3["Module"] = 1] = "Module";
    SymbolKind3[SymbolKind3["Namespace"] = 2] = "Namespace";
    SymbolKind3[SymbolKind3["Package"] = 3] = "Package";
    SymbolKind3[SymbolKind3["Class"] = 4] = "Class";
    SymbolKind3[SymbolKind3["Method"] = 5] = "Method";
    SymbolKind3[SymbolKind3["Property"] = 6] = "Property";
    SymbolKind3[SymbolKind3["Field"] = 7] = "Field";
    SymbolKind3[SymbolKind3["Constructor"] = 8] = "Constructor";
    SymbolKind3[SymbolKind3["Enum"] = 9] = "Enum";
    SymbolKind3[SymbolKind3["Interface"] = 10] = "Interface";
    SymbolKind3[SymbolKind3["Function"] = 11] = "Function";
    SymbolKind3[SymbolKind3["Variable"] = 12] = "Variable";
    SymbolKind3[SymbolKind3["Constant"] = 13] = "Constant";
    SymbolKind3[SymbolKind3["String"] = 14] = "String";
    SymbolKind3[SymbolKind3["Number"] = 15] = "Number";
    SymbolKind3[SymbolKind3["Boolean"] = 16] = "Boolean";
    SymbolKind3[SymbolKind3["Array"] = 17] = "Array";
    SymbolKind3[SymbolKind3["Object"] = 18] = "Object";
    SymbolKind3[SymbolKind3["Key"] = 19] = "Key";
    SymbolKind3[SymbolKind3["Null"] = 20] = "Null";
    SymbolKind3[SymbolKind3["EnumMember"] = 21] = "EnumMember";
    SymbolKind3[SymbolKind3["Struct"] = 22] = "Struct";
    SymbolKind3[SymbolKind3["Event"] = 23] = "Event";
    SymbolKind3[SymbolKind3["Operator"] = 24] = "Operator";
    SymbolKind3[SymbolKind3["TypeParameter"] = 25] = "TypeParameter";
  })(SymbolKind2 || (SymbolKind2 = {}));
  var SymbolTag2;
  (function(SymbolTag3) {
    SymbolTag3[SymbolTag3["Deprecated"] = 1] = "Deprecated";
  })(SymbolTag2 || (SymbolTag2 = {}));
  var TextEditorCursorBlinkingStyle;
  (function(TextEditorCursorBlinkingStyle2) {
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
  })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
  var TextEditorCursorStyle;
  (function(TextEditorCursorStyle2) {
    TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
    TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
  })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
  var TrackedRangeStickiness;
  (function(TrackedRangeStickiness2) {
    TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
  })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
  var WrappingIndent;
  (function(WrappingIndent2) {
    WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
    WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
    WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
    WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
  })(WrappingIndent || (WrappingIndent = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
  var KeyMod = class {
    static chord(firstPart, secondPart) {
      return KeyChord(firstPart, secondPart);
    }
  };
  KeyMod.CtrlCmd = 2048;
  KeyMod.Shift = 1024;
  KeyMod.Alt = 512;
  KeyMod.WinCtrl = 256;
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      // undefined override expected here
      languages: void 0,
      // undefined override expected here
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position: Position2,
      Range: Range2,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI2,
      Token
    };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/map.js
  var _a3;
  var _b2;
  var ResourceMapEntry = class {
    constructor(uri, value2) {
      this.uri = uri;
      this.value = value2;
    }
  };
  function isEntries(arg) {
    return Array.isArray(arg);
  }
  var ResourceMap = class _ResourceMap {
    constructor(arg, toKey) {
      this[_a3] = "ResourceMap";
      if (arg instanceof _ResourceMap) {
        this.map = new Map(arg.map);
        this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
      } else if (isEntries(arg)) {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
        for (const [resource, value2] of arg) {
          this.set(resource, value2);
        }
      } else {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = arg !== null && arg !== void 0 ? arg : _ResourceMap.defaultToKey;
      }
    }
    set(resource, value2) {
      this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value2));
      return this;
    }
    get(resource) {
      var _c;
      return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(resource) {
      return this.map.has(this.toKey(resource));
    }
    get size() {
      return this.map.size;
    }
    clear() {
      this.map.clear();
    }
    delete(resource) {
      return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
      if (typeof thisArg !== "undefined") {
        clb = clb.bind(thisArg);
      }
      for (const [_2, entry] of this.map) {
        clb(entry.value, entry.uri, this);
      }
    }
    *values() {
      for (const entry of this.map.values()) {
        yield entry.value;
      }
    }
    *keys() {
      for (const entry of this.map.values()) {
        yield entry.uri;
      }
    }
    *entries() {
      for (const entry of this.map.values()) {
        yield [entry.uri, entry.value];
      }
    }
    *[(_a3 = Symbol.toStringTag, Symbol.iterator)]() {
      for (const [, entry] of this.map) {
        yield [entry.uri, entry.value];
      }
    }
  };
  ResourceMap.defaultToKey = (resource) => resource.toString();
  var LinkedMap = class {
    constructor() {
      this[_b2] = "LinkedMap";
      this._map = /* @__PURE__ */ new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var _c;
      return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
    }
    get last() {
      var _c;
      return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = 0) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      if (touch !== 0) {
        this.touch(item, touch);
      }
      return item.value;
    }
    set(key, value2, touch = 0) {
      let item = this._map.get(key);
      if (item) {
        item.value = value2;
        if (touch !== 0) {
          this.touch(item, touch);
        }
      } else {
        item = { key, value: value2, next: void 0, previous: void 0 };
        switch (touch) {
          case 0:
            this.addItemLast(item);
            break;
          case 1:
            this.addItemFirst(item);
            break;
          case 2:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        if (this._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        current = current.next;
      }
    }
    keys() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.key, done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    values() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.value, done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    entries() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: [current.key, current.value], done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    [(_b2 = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._head;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.next;
        currentSize--;
      }
      this._head = current;
      this._size = currentSize;
      if (current) {
        current.previous = void 0;
      }
      this._state++;
    }
    trimNew(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._tail;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.previous;
        currentSize--;
      }
      this._tail = current;
      this._size = currentSize;
      if (current) {
        current.next = void 0;
      }
      this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        if (!item.next) {
          throw new Error("Invalid list");
        }
        item.next.previous = void 0;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw new Error("Invalid list");
        }
        item.previous.next = void 0;
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = void 0;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== 1 && touch !== 2) {
        return;
      }
      if (touch === 1) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
        this._state++;
      } else if (touch === 2) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
        this._state++;
      }
    }
    toJSON() {
      const data = [];
      this.forEach((value2, key) => {
        data.push([key, value2]);
      });
      return data;
    }
    fromJSON(data) {
      this.clear();
      for (const [key, value2] of data) {
        this.set(key, value2);
      }
    }
  };
  var Cache = class extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get(key, touch = 2) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(
        key,
        0
        /* Touch.None */
      );
    }
    set(key, value2) {
      super.set(
        key,
        value2,
        2
        /* Touch.AsNew */
      );
      return this;
    }
    checkTrim() {
      if (this.size > this._limit) {
        this.trim(Math.round(this._limit * this._ratio));
      }
    }
  };
  var LRUCache = class extends Cache {
    constructor(limit, ratio = 1) {
      super(limit, ratio);
    }
    trim(newSize) {
      this.trimOld(newSize);
    }
    set(key, value2) {
      super.set(key, value2);
      this.checkTrim();
      return this;
    }
  };
  var SetMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    add(key, value2) {
      let values = this.map.get(key);
      if (!values) {
        values = /* @__PURE__ */ new Set();
        this.map.set(key, values);
      }
      values.add(value2);
    }
    delete(key, value2) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.delete(value2);
      if (values.size === 0) {
        this.map.delete(key);
      }
    }
    forEach(key, fn5) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.forEach(fn5);
    }
    get(key) {
      const values = this.map.get(key);
      if (!values) {
        return /* @__PURE__ */ new Set();
      }
      return values;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
  var wordClassifierCache = new LRUCache(10);

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane2;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
  var GlyphMarginLane2;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
  var InjectedTextCursorStops2;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text2.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text2.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text2.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text2.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text2, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength);
  }
  var Searcher = class {
    constructor(wordSeparators, searchRegex) {
      this._wordSeparators = wordSeparators;
      this._searchRegex = searchRegex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    reset(lastIndex) {
      this._searchRegex.lastIndex = lastIndex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    next(text2) {
      const textLength = text2.length;
      let m2;
      do {
        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
          return null;
        }
        m2 = this._searchRegex.exec(text2);
        if (!m2) {
          return null;
        }
        const matchStartIndex = m2.index;
        const matchLength = m2[0].length;
        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
          if (matchLength === 0) {
            if (getNextCodePoint(text2, textLength, this._searchRegex.lastIndex) > 65535) {
              this._searchRegex.lastIndex += 2;
            } else {
              this._searchRegex.lastIndex += 1;
            }
            continue;
          }
          return null;
        }
        this._prevMatchStartIndex = matchStartIndex;
        this._prevMatchLength = matchLength;
        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text2, textLength, matchStartIndex, matchLength)) {
          return m2;
        }
      } while (m2);
      return null;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/assert.js
  function assertNever(value2, message = "Unreachable") {
    throw new Error(message);
  }
  function assertFn(condition) {
    if (!condition()) {
      debugger;
      condition();
      onUnexpectedError(new BugIndicatingError("Assertion Failed"));
    }
  }
  function checkAdjacentItems(items, predicate) {
    let i2 = 0;
    while (i2 < items.length - 1) {
      const a2 = items[i2];
      const b2 = items[i2 + 1];
      if (!predicate(a2, b2)) {
        return false;
      }
      i2++;
    }
    return true;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  var UnicodeTextModelHighlighter = class {
    static computeUnicodeHighlights(model, options, range) {
      const startLine = range ? range.startLineNumber : 1;
      const endLine = range ? range.endLineNumber : model.getLineCount();
      const codePointHighlighter = new CodePointHighlighter(options);
      const candidates = codePointHighlighter.getCandidateCodePoints();
      let regex;
      if (candidates === "allNonBasicAscii") {
        regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
      } else {
        regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
      }
      const searcher = new Searcher(null, regex);
      const ranges = [];
      let hasMore = false;
      let m2;
      let ambiguousCharacterCount = 0;
      let invisibleCharacterCount = 0;
      let nonBasicAsciiCharacterCount = 0;
      forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
        const lineContent = model.getLineContent(lineNumber);
        const lineLength = lineContent.length;
        searcher.reset(0);
        do {
          m2 = searcher.next(lineContent);
          if (m2) {
            let startIndex = m2.index;
            let endIndex = m2.index + m2[0].length;
            if (startIndex > 0) {
              const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                startIndex--;
              }
            }
            if (endIndex + 1 < lineLength) {
              const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                endIndex++;
              }
            }
            const str = lineContent.substring(startIndex, endIndex);
            let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
            if (word && word.endColumn <= startIndex + 1) {
              word = null;
            }
            const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
            if (highlightReason !== 0) {
              if (highlightReason === 3) {
                ambiguousCharacterCount++;
              } else if (highlightReason === 2) {
                invisibleCharacterCount++;
              } else if (highlightReason === 1) {
                nonBasicAsciiCharacterCount++;
              } else {
                assertNever(highlightReason);
              }
              const MAX_RESULT_LENGTH = 1e3;
              if (ranges.length >= MAX_RESULT_LENGTH) {
                hasMore = true;
                break forLoop;
              }
              ranges.push(new Range2(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
            }
          }
        } while (m2);
      }
      return {
        ranges,
        hasMore,
        ambiguousCharacterCount,
        invisibleCharacterCount,
        nonBasicAsciiCharacterCount
      };
    }
    static computeUnicodeHighlightReason(char, options) {
      const codePointHighlighter = new CodePointHighlighter(options);
      const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
      switch (reason) {
        case 0:
          return null;
        case 2:
          return {
            kind: 1
            /* UnicodeHighlighterReasonKind.Invisible */
          };
        case 3: {
          const codePoint = char.codePointAt(0);
          const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
          const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l2) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l2])).isAmbiguous(codePoint));
          return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
        }
        case 1:
          return {
            kind: 2
            /* UnicodeHighlighterReasonKind.NonBasicAscii */
          };
      }
    }
  };
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i2) => String.fromCodePoint(i2)).join(""))}]`;
    return src;
  }
  var CodePointHighlighter = class {
    constructor(options) {
      this.options = options;
      this.allowedCodePoints = new Set(options.allowedCodePoints);
      this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
      if (this.options.nonBasicASCII) {
        return "allNonBasicAscii";
      }
      const set = /* @__PURE__ */ new Set();
      if (this.options.invisibleCharacters) {
        for (const cp of InvisibleCharacters.codePoints) {
          if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
            set.add(cp);
          }
        }
      }
      if (this.options.ambiguousCharacters) {
        for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
          set.add(cp);
        }
      }
      for (const cp of this.allowedCodePoints) {
        set.delete(cp);
      }
      return set;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
      const codePoint = character.codePointAt(0);
      if (this.allowedCodePoints.has(codePoint)) {
        return 0;
      }
      if (this.options.nonBasicASCII) {
        return 1;
      }
      let hasBasicASCIICharacters = false;
      let hasNonConfusableNonBasicAsciiCharacter = false;
      if (wordContext) {
        for (const char of wordContext) {
          const codePoint2 = char.codePointAt(0);
          const isBasicASCII2 = isBasicASCII(char);
          hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
          if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
            hasNonConfusableNonBasicAsciiCharacter = true;
          }
        }
      }
      if (
        /* Don't allow mixing weird looking characters with ASCII */
        !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
        hasNonConfusableNonBasicAsciiCharacter
      ) {
        return 0;
      }
      if (this.options.invisibleCharacters) {
        if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
          return 2;
        }
      }
      if (this.options.ambiguousCharacters) {
        if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
          return 3;
        }
      }
      return 0;
    }
  };
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
  var LinesDiff = class {
    constructor(changes, moves, hitTimeout) {
      this.changes = changes;
      this.moves = moves;
      this.hitTimeout = hitTimeout;
    }
  };
  var MovedText = class {
    constructor(lineRangeMapping, changes) {
      this.lineRangeMapping = lineRangeMapping;
      this.changes = changes;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js
  var OffsetRange = class _OffsetRange {
    static addRange(range, sortedRanges) {
      let i2 = 0;
      while (i2 < sortedRanges.length && sortedRanges[i2].endExclusive < range.start) {
        i2++;
      }
      let j2 = i2;
      while (j2 < sortedRanges.length && sortedRanges[j2].start <= range.endExclusive) {
        j2++;
      }
      if (i2 === j2) {
        sortedRanges.splice(i2, 0, range);
      } else {
        const start = Math.min(range.start, sortedRanges[i2].start);
        const end = Math.max(range.endExclusive, sortedRanges[j2 - 1].endExclusive);
        sortedRanges.splice(i2, j2 - i2, new _OffsetRange(start, end));
      }
    }
    static tryCreate(start, endExclusive) {
      if (start > endExclusive) {
        return void 0;
      }
      return new _OffsetRange(start, endExclusive);
    }
    static ofLength(length2) {
      return new _OffsetRange(0, length2);
    }
    static ofStartAndLength(start, length2) {
      return new _OffsetRange(start, start + length2);
    }
    constructor(start, endExclusive) {
      this.start = start;
      this.endExclusive = endExclusive;
      if (start > endExclusive) {
        throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
      }
    }
    get isEmpty() {
      return this.start === this.endExclusive;
    }
    delta(offset) {
      return new _OffsetRange(this.start + offset, this.endExclusive + offset);
    }
    deltaStart(offset) {
      return new _OffsetRange(this.start + offset, this.endExclusive);
    }
    deltaEnd(offset) {
      return new _OffsetRange(this.start, this.endExclusive + offset);
    }
    get length() {
      return this.endExclusive - this.start;
    }
    toString() {
      return `[${this.start}, ${this.endExclusive})`;
    }
    contains(offset) {
      return this.start <= offset && offset < this.endExclusive;
    }
    /**
     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
     * The joined range is the smallest range that contains both ranges.
     */
    join(other) {
      return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
    }
    /**
     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
     *
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const start = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      if (start <= end) {
        return new _OffsetRange(start, end);
      }
      return void 0;
    }
    intersects(other) {
      const start = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      return start < end;
    }
    isBefore(other) {
      return this.endExclusive <= other.start;
    }
    isAfter(other) {
      return this.start >= other.endExclusive;
    }
    slice(arr) {
      return arr.slice(this.start, this.endExclusive);
    }
    substring(str) {
      return str.substring(this.start, this.endExclusive);
    }
    /**
     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
     * The range must not be empty.
     */
    clip(value2) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      return Math.max(this.start, Math.min(this.endExclusive - 1, value2));
    }
    /**
     * Returns `r := value + k * length` such that `r` is contained in this range.
     * The range must not be empty.
     *
     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
     */
    clipCyclic(value2) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      if (value2 < this.start) {
        return this.endExclusive - (this.start - value2) % this.length;
      }
      if (value2 >= this.endExclusive) {
        return this.start + (value2 - this.start) % this.length;
      }
      return value2;
    }
    forEach(f5) {
      for (let i2 = this.start; i2 < this.endExclusive; i2++) {
        f5(i2);
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js
  function findLastMonotonous(array, predicate) {
    const idx = findLastIdxMonotonous(array, predicate);
    return idx === -1 ? void 0 : array[idx];
  }
  function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i2 = startIdx;
    let j2 = endIdxEx;
    while (i2 < j2) {
      const k5 = Math.floor((i2 + j2) / 2);
      if (predicate(array[k5])) {
        i2 = k5 + 1;
      } else {
        j2 = k5;
      }
    }
    return i2 - 1;
  }
  function findFirstMonotonous(array, predicate) {
    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
    return idx === array.length ? void 0 : array[idx];
  }
  function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i2 = startIdx;
    let j2 = endIdxEx;
    while (i2 < j2) {
      const k5 = Math.floor((i2 + j2) / 2);
      if (predicate(array[k5])) {
        j2 = k5;
      } else {
        i2 = k5 + 1;
      }
    }
    return i2;
  }
  var MonotonousArray = class _MonotonousArray {
    constructor(_array) {
      this._array = _array;
      this._findLastMonotonousLastIdx = 0;
    }
    /**
     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
     */
    findLastMonotonous(predicate) {
      if (_MonotonousArray.assertInvariants) {
        if (this._prevFindLastPredicate) {
          for (const item of this._array) {
            if (this._prevFindLastPredicate(item) && !predicate(item)) {
              throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
            }
          }
        }
        this._prevFindLastPredicate = predicate;
      }
      const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
      this._findLastMonotonousLastIdx = idx + 1;
      return idx === -1 ? void 0 : this._array[idx];
    }
  };
  MonotonousArray.assertInvariants = false;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js
  var LineRange = class _LineRange {
    static fromRangeInclusive(range) {
      return new _LineRange(range.startLineNumber, range.endLineNumber + 1);
    }
    /**
     * @param lineRanges An array of sorted line ranges.
     */
    static joinMany(lineRanges) {
      if (lineRanges.length === 0) {
        return [];
      }
      let result = new LineRangeSet(lineRanges[0].slice());
      for (let i2 = 1; i2 < lineRanges.length; i2++) {
        result = result.getUnion(new LineRangeSet(lineRanges[i2].slice()));
      }
      return result.ranges;
    }
    static join(lineRanges) {
      if (lineRanges.length === 0) {
        throw new BugIndicatingError("lineRanges cannot be empty");
      }
      let startLineNumber = lineRanges[0].startLineNumber;
      let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;
      for (let i2 = 1; i2 < lineRanges.length; i2++) {
        startLineNumber = Math.min(startLineNumber, lineRanges[i2].startLineNumber);
        endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i2].endLineNumberExclusive);
      }
      return new _LineRange(startLineNumber, endLineNumberExclusive);
    }
    static ofLength(startLineNumber, length2) {
      return new _LineRange(startLineNumber, startLineNumber + length2);
    }
    /**
     * @internal
     */
    static deserialize(lineRange) {
      return new _LineRange(lineRange[0], lineRange[1]);
    }
    constructor(startLineNumber, endLineNumberExclusive) {
      if (startLineNumber > endLineNumberExclusive) {
        throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
      }
      this.startLineNumber = startLineNumber;
      this.endLineNumberExclusive = endLineNumberExclusive;
    }
    /**
     * Indicates if this line range contains the given line number.
     */
    contains(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty() {
      return this.startLineNumber === this.endLineNumberExclusive;
    }
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset) {
      return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
    }
    deltaLength(offset) {
      return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
    }
    /**
     * The number of lines this line range spans.
     */
    get length() {
      return this.endLineNumberExclusive - this.startLineNumber;
    }
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other) {
      return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    toString() {
      return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    /**
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
      const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
      if (startLineNumber <= endLineNumberExclusive) {
        return new _LineRange(startLineNumber, endLineNumberExclusive);
      }
      return void 0;
    }
    intersectsStrict(other) {
      return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
    }
    overlapOrTouch(other) {
      return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    equals(b2) {
      return this.startLineNumber === b2.startLineNumber && this.endLineNumberExclusive === b2.endLineNumberExclusive;
    }
    toInclusiveRange() {
      if (this.isEmpty) {
        return null;
      }
      return new Range2(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
    }
    /**
     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
    */
    toExclusiveRange() {
      return new Range2(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
    }
    mapToLineArray(f5) {
      const result = [];
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        result.push(f5(lineNumber));
      }
      return result;
    }
    forEach(f5) {
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        f5(lineNumber);
      }
    }
    /**
     * @internal
     */
    serialize() {
      return [this.startLineNumber, this.endLineNumberExclusive];
    }
    includes(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
     * @internal
     */
    toOffsetRange() {
      return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
    }
  };
  var LineRangeSet = class _LineRangeSet {
    constructor(_normalizedRanges = []) {
      this._normalizedRanges = _normalizedRanges;
    }
    get ranges() {
      return this._normalizedRanges;
    }
    addRange(range) {
      if (range.length === 0) {
        return;
      }
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r3) => r3.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r3) => r3.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
      } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
        const joinRange = this._normalizedRanges[joinRangeStartIdx];
        this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
      } else {
        const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
        this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
      }
    }
    contains(lineNumber) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r3) => r3.startLineNumber <= lineNumber);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
    }
    intersects(range) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r3) => r3.startLineNumber < range.endLineNumberExclusive);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
    }
    getUnion(other) {
      if (this._normalizedRanges.length === 0) {
        return other;
      }
      if (other._normalizedRanges.length === 0) {
        return this;
      }
      const result = [];
      let i1 = 0;
      let i2 = 0;
      let current = null;
      while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
        let next = null;
        if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
          const lineRange1 = this._normalizedRanges[i1];
          const lineRange2 = other._normalizedRanges[i2];
          if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
            next = lineRange1;
            i1++;
          } else {
            next = lineRange2;
            i2++;
          }
        } else if (i1 < this._normalizedRanges.length) {
          next = this._normalizedRanges[i1];
          i1++;
        } else {
          next = other._normalizedRanges[i2];
          i2++;
        }
        if (current === null) {
          current = next;
        } else {
          if (current.endLineNumberExclusive >= next.startLineNumber) {
            current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
          } else {
            result.push(current);
            current = next;
          }
        }
      }
      if (current !== null) {
        result.push(current);
      }
      return new _LineRangeSet(result);
    }
    /**
     * Subtracts all ranges in this set from `range` and returns the result.
     */
    subtractFrom(range) {
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r3) => r3.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r3) => r3.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        return new _LineRangeSet([range]);
      }
      const result = [];
      let startLineNumber = range.startLineNumber;
      for (let i2 = joinRangeStartIdx; i2 < joinRangeEndIdxExclusive; i2++) {
        const r3 = this._normalizedRanges[i2];
        if (r3.startLineNumber > startLineNumber) {
          result.push(new LineRange(startLineNumber, r3.startLineNumber));
        }
        startLineNumber = r3.endLineNumberExclusive;
      }
      if (startLineNumber < range.endLineNumberExclusive) {
        result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
      }
      return new _LineRangeSet(result);
    }
    toString() {
      return this._normalizedRanges.map((r3) => r3.toString()).join(", ");
    }
    getIntersection(other) {
      const result = [];
      let i1 = 0;
      let i2 = 0;
      while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
        const r1 = this._normalizedRanges[i1];
        const r22 = other._normalizedRanges[i2];
        const i3 = r1.intersect(r22);
        if (i3 && !i3.isEmpty) {
          result.push(i3);
        }
        if (r1.endLineNumberExclusive < r22.endLineNumberExclusive) {
          i1++;
        } else {
          i2++;
        }
      }
      return new _LineRangeSet(result);
    }
    getWithDelta(value2) {
      return new _LineRangeSet(this._normalizedRanges.map((r3) => r3.delta(value2)));
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js
  var TextLength = class _TextLength {
    static betweenPositions(position1, position2) {
      if (position1.lineNumber === position2.lineNumber) {
        return new _TextLength(0, position2.column - position1.column);
      } else {
        return new _TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);
      }
    }
    static ofRange(range) {
      return _TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());
    }
    static ofText(text2) {
      let line = 0;
      let column = 0;
      for (const c3 of text2) {
        if (c3 === "\n") {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      return new _TextLength(line, column);
    }
    constructor(lineCount, columnCount) {
      this.lineCount = lineCount;
      this.columnCount = columnCount;
    }
    isGreaterThanOrEqualTo(other) {
      if (this.lineCount !== other.lineCount) {
        return this.lineCount > other.lineCount;
      }
      return this.columnCount >= other.columnCount;
    }
    createRange(startPosition) {
      if (this.lineCount === 0) {
        return new Range2(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);
      } else {
        return new Range2(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    addToPosition(position2) {
      if (this.lineCount === 0) {
        return new Position2(position2.lineNumber, position2.column + this.columnCount);
      } else {
        return new Position2(position2.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    toString() {
      return `${this.lineCount},${this.columnCount}`;
    }
  };
  TextLength.zero = new TextLength(0, 0);

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js
  var SingleTextEdit = class {
    constructor(range, text2) {
      this.range = range;
      this.text = text2;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js
  var LineRangeMapping = class _LineRangeMapping {
    static inverse(mapping, originalLineCount, modifiedLineCount) {
      const result = [];
      let lastOriginalEndLineNumber = 1;
      let lastModifiedEndLineNumber = 1;
      for (const m2 of mapping) {
        const r4 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m2.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m2.modified.startLineNumber));
        if (!r4.modified.isEmpty) {
          result.push(r4);
        }
        lastOriginalEndLineNumber = m2.original.endLineNumberExclusive;
        lastModifiedEndLineNumber = m2.modified.endLineNumberExclusive;
      }
      const r3 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));
      if (!r3.modified.isEmpty) {
        result.push(r3);
      }
      return result;
    }
    static clip(mapping, originalRange, modifiedRange) {
      const result = [];
      for (const m2 of mapping) {
        const original = m2.original.intersect(originalRange);
        const modified = m2.modified.intersect(modifiedRange);
        if (original && !original.isEmpty && modified && !modified.isEmpty) {
          result.push(new _LineRangeMapping(original, modified));
        }
      }
      return result;
    }
    constructor(originalRange, modifiedRange) {
      this.original = originalRange;
      this.modified = modifiedRange;
    }
    toString() {
      return `{${this.original.toString()}->${this.modified.toString()}}`;
    }
    flip() {
      return new _LineRangeMapping(this.modified, this.original);
    }
    join(other) {
      return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
    }
    /**
     * This method assumes that the LineRangeMapping describes a valid diff!
     * I.e. if one range is empty, the other range cannot be the entire document.
     * It avoids various problems when the line range points to non-existing line-numbers.
    */
    toRangeMapping() {
      const origInclusiveRange = this.original.toInclusiveRange();
      const modInclusiveRange = this.modified.toInclusiveRange();
      if (origInclusiveRange && modInclusiveRange) {
        return new RangeMapping(origInclusiveRange, modInclusiveRange);
      } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
        if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {
          throw new BugIndicatingError("not a valid diff");
        }
        return new RangeMapping(new Range2(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range2(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
      } else {
        return new RangeMapping(new Range2(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range2(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
      }
    }
  };
  var DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {
    static fromRangeMappings(rangeMappings) {
      const originalRange = LineRange.join(rangeMappings.map((r3) => LineRange.fromRangeInclusive(r3.originalRange)));
      const modifiedRange = LineRange.join(rangeMappings.map((r3) => LineRange.fromRangeInclusive(r3.modifiedRange)));
      return new _DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);
    }
    constructor(originalRange, modifiedRange, innerChanges) {
      super(originalRange, modifiedRange);
      this.innerChanges = innerChanges;
    }
    flip() {
      var _a4;
      return new _DetailedLineRangeMapping(this.modified, this.original, (_a4 = this.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c3) => c3.flip()));
    }
    withInnerChangesFromLineRanges() {
      return new _DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);
    }
  };
  var RangeMapping = class _RangeMapping {
    constructor(originalRange, modifiedRange) {
      this.originalRange = originalRange;
      this.modifiedRange = modifiedRange;
    }
    toString() {
      return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    flip() {
      return new _RangeMapping(this.modifiedRange, this.originalRange);
    }
    /**
     * Creates a single text edit that describes the change from the original to the modified text.
    */
    toTextEdit(modified) {
      const newText = modified.getValueOfRange(this.modifiedRange);
      return new SingleTextEdit(this.originalRange, newText);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js
  var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
  var LegacyLinesDiffComputer = class {
    computeDiff(originalLines, modifiedLines, options) {
      var _a4;
      const diffComputer = new DiffComputer(originalLines, modifiedLines, {
        maxComputationTime: options.maxComputationTimeMs,
        shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
        shouldComputeCharChanges: true,
        shouldMakePrettyDiff: true,
        shouldPostProcessCharChanges: true
      });
      const result = diffComputer.computeDiff();
      const changes = [];
      let lastChange = null;
      for (const c3 of result.changes) {
        let originalRange;
        if (c3.originalEndLineNumber === 0) {
          originalRange = new LineRange(c3.originalStartLineNumber + 1, c3.originalStartLineNumber + 1);
        } else {
          originalRange = new LineRange(c3.originalStartLineNumber, c3.originalEndLineNumber + 1);
        }
        let modifiedRange;
        if (c3.modifiedEndLineNumber === 0) {
          modifiedRange = new LineRange(c3.modifiedStartLineNumber + 1, c3.modifiedStartLineNumber + 1);
        } else {
          modifiedRange = new LineRange(c3.modifiedStartLineNumber, c3.modifiedEndLineNumber + 1);
        }
        let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a4 = c3.charChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c4) => new RangeMapping(new Range2(c4.originalStartLineNumber, c4.originalStartColumn, c4.originalEndLineNumber, c4.originalEndColumn), new Range2(c4.modifiedStartLineNumber, c4.modifiedStartColumn, c4.modifiedEndLineNumber, c4.modifiedEndColumn))));
        if (lastChange) {
          if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
            change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
            changes.pop();
          }
        }
        changes.push(change);
        lastChange = change;
      }
      assertFn(() => {
        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
        m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
      });
      return new LinesDiff(changes, [], result.quitEarly);
    }
  };
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  var LineSequence = class {
    constructor(lines) {
      const startColumns = [];
      const endColumns = [];
      for (let i2 = 0, length2 = lines.length; i2 < length2; i2++) {
        startColumns[i2] = getFirstNonBlankColumn(lines[i2], 1);
        endColumns[i2] = getLastNonBlankColumn(lines[i2], 1);
      }
      this.lines = lines;
      this._startColumns = startColumns;
      this._endColumns = endColumns;
    }
    getElements() {
      const elements = [];
      for (let i2 = 0, len = this.lines.length; i2 < len; i2++) {
        elements[i2] = this.lines[i2].substring(this._startColumns[i2] - 1, this._endColumns[i2] - 1);
      }
      return elements;
    }
    getStrictElement(index2) {
      return this.lines[index2];
    }
    getStartLineNumber(i2) {
      return i2 + 1;
    }
    getEndLineNumber(i2) {
      return i2 + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
      const charCodes = [];
      const lineNumbers = [];
      const columns = [];
      let len = 0;
      for (let index2 = startIndex; index2 <= endIndex; index2++) {
        const lineContent = this.lines[index2];
        const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index2] : 1;
        const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index2] : lineContent.length + 1;
        for (let col = startColumn; col < endColumn; col++) {
          charCodes[len] = lineContent.charCodeAt(col - 1);
          lineNumbers[len] = index2 + 1;
          columns[len] = col;
          len++;
        }
        if (!shouldIgnoreTrimWhitespace && index2 < endIndex) {
          charCodes[len] = 10;
          lineNumbers[len] = index2 + 1;
          columns[len] = lineContent.length + 1;
          len++;
        }
      }
      return new CharSequence(charCodes, lineNumbers, columns);
    }
  };
  var CharSequence = class {
    constructor(charCodes, lineNumbers, columns) {
      this._charCodes = charCodes;
      this._lineNumbers = lineNumbers;
      this._columns = columns;
    }
    toString() {
      return "[" + this._charCodes.map((s2, idx) => (s2 === 10 ? "\\n" : String.fromCharCode(s2)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
    }
    _assertIndex(index2, arr) {
      if (index2 < 0 || index2 >= arr.length) {
        throw new Error(`Illegal index`);
      }
    }
    getElements() {
      return this._charCodes;
    }
    getStartLineNumber(i2) {
      if (i2 > 0 && i2 === this._lineNumbers.length) {
        return this.getEndLineNumber(i2 - 1);
      }
      this._assertIndex(i2, this._lineNumbers);
      return this._lineNumbers[i2];
    }
    getEndLineNumber(i2) {
      if (i2 === -1) {
        return this.getStartLineNumber(i2 + 1);
      }
      this._assertIndex(i2, this._lineNumbers);
      if (this._charCodes[i2] === 10) {
        return this._lineNumbers[i2] + 1;
      }
      return this._lineNumbers[i2];
    }
    getStartColumn(i2) {
      if (i2 > 0 && i2 === this._columns.length) {
        return this.getEndColumn(i2 - 1);
      }
      this._assertIndex(i2, this._columns);
      return this._columns[i2];
    }
    getEndColumn(i2) {
      if (i2 === -1) {
        return this.getStartColumn(i2 + 1);
      }
      this._assertIndex(i2, this._columns);
      if (this._charCodes[i2] === 10) {
        return 1;
      }
      return this._columns[i2] + 1;
    }
  };
  var CharChange = class _CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalStartColumn = originalStartColumn;
      this.originalEndLineNumber = originalEndLineNumber;
      this.originalEndColumn = originalEndColumn;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedStartColumn = modifiedStartColumn;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
      const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
      const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
      const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
      const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
      const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
  };
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i2 = 1, len = rawChanges.length; i2 < len; i2++) {
      const currChange = rawChanges[i2];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  var LineChange = class _LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalEndLineNumber = originalEndLineNumber;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
      let originalStartLineNumber;
      let originalEndLineNumber;
      let modifiedStartLineNumber;
      let modifiedEndLineNumber;
      let charChanges = void 0;
      if (diffChange.originalLength === 0) {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
        originalEndLineNumber = 0;
      } else {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
        originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      }
      if (diffChange.modifiedLength === 0) {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
        modifiedEndLineNumber = 0;
      } else {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
        modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      }
      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
        const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
        if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
          let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
          if (shouldPostProcessCharChanges) {
            rawChanges = postProcessCharChanges(rawChanges);
          }
          charChanges = [];
          for (let i2 = 0, length2 = rawChanges.length; i2 < length2; i2++) {
            charChanges.push(CharChange.createFromDiffChange(rawChanges[i2], originalCharSequence, modifiedCharSequence));
          }
        }
      }
      return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
  };
  var DiffComputer = class {
    constructor(originalLines, modifiedLines, opts) {
      this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
      this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
      this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
      this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
      this.originalLines = originalLines;
      this.modifiedLines = modifiedLines;
      this.original = new LineSequence(originalLines);
      this.modified = new LineSequence(modifiedLines);
      this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
      this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
    }
    computeDiff() {
      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
          return {
            quitEarly: false,
            changes: []
          };
        }
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: 1,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: this.modified.lines.length,
            charChanges: void 0
          }]
        };
      }
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: this.original.lines.length,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: 1,
            charChanges: void 0
          }]
        };
      }
      const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
      const rawChanges = diffResult.changes;
      const quitEarly = diffResult.quitEarly;
      if (this.shouldIgnoreTrimWhitespace) {
        const lineChanges = [];
        for (let i2 = 0, length2 = rawChanges.length; i2 < length2; i2++) {
          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i2], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        }
        return {
          quitEarly,
          changes: lineChanges
        };
      }
      const result = [];
      let originalLineIndex = 0;
      let modifiedLineIndex = 0;
      for (let i2 = -1, len = rawChanges.length; i2 < len; i2++) {
        const nextChange = i2 + 1 < len ? rawChanges[i2 + 1] : null;
        const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
        const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
        while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
          const originalLine = this.originalLines[originalLineIndex];
          const modifiedLine = this.modifiedLines[modifiedLineIndex];
          if (originalLine !== modifiedLine) {
            {
              let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
              let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
              while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalStartColumn--;
                modifiedStartColumn--;
              }
              if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
              }
            }
            {
              let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
              let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
              const originalMaxColumn = originalLine.length + 1;
              const modifiedMaxColumn = modifiedLine.length + 1;
              while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalEndColumn++;
                modifiedEndColumn++;
              }
              if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
              }
            }
          }
          originalLineIndex++;
          modifiedLineIndex++;
        }
        if (nextChange) {
          result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
          originalLineIndex += nextChange.originalLength;
          modifiedLineIndex += nextChange.modifiedLength;
        }
      }
      return {
        quitEarly,
        changes: result
      };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
        return;
      }
      let charChanges = void 0;
      if (this.shouldComputeCharChanges) {
        charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
      }
      result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      const len = result.length;
      if (len === 0) {
        return false;
      }
      const prevChange = result[len - 1];
      if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
        return false;
      }
      if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
        prevChange.originalEndLineNumber = originalLineNumber;
        prevChange.modifiedEndLineNumber = modifiedLineNumber;
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      return false;
    }
  };
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r3 = firstNonWhitespaceIndex(txt);
    if (r3 === -1) {
      return defaultValue;
    }
    return r3 + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r3 = lastNonWhitespaceIndex(txt);
    if (r3 === -1) {
      return defaultValue;
    }
    return r3 + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
  var DiffAlgorithmResult = class _DiffAlgorithmResult {
    static trivial(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);
    }
    static trivialTimedOut(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);
    }
    constructor(diffs, hitTimeout) {
      this.diffs = diffs;
      this.hitTimeout = hitTimeout;
    }
  };
  var SequenceDiff = class _SequenceDiff {
    static invert(sequenceDiffs, doc1Length) {
      const result = [];
      forEachAdjacent(sequenceDiffs, (a2, b2) => {
        result.push(_SequenceDiff.fromOffsetPairs(a2 ? a2.getEndExclusives() : OffsetPair.zero, b2 ? b2.getStarts() : new OffsetPair(doc1Length, (a2 ? a2.seq2Range.endExclusive - a2.seq1Range.endExclusive : 0) + doc1Length)));
      });
      return result;
    }
    static fromOffsetPairs(start, endExclusive) {
      return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));
    }
    constructor(seq1Range, seq2Range) {
      this.seq1Range = seq1Range;
      this.seq2Range = seq2Range;
    }
    swap() {
      return new _SequenceDiff(this.seq2Range, this.seq1Range);
    }
    toString() {
      return `${this.seq1Range} <-> ${this.seq2Range}`;
    }
    join(other) {
      return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
    }
    delta(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
    }
    deltaStart(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));
    }
    deltaEnd(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
    }
    intersect(other) {
      const i1 = this.seq1Range.intersect(other.seq1Range);
      const i2 = this.seq2Range.intersect(other.seq2Range);
      if (!i1 || !i2) {
        return void 0;
      }
      return new _SequenceDiff(i1, i2);
    }
    getStarts() {
      return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
    }
    getEndExclusives() {
      return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
    }
  };
  var OffsetPair = class _OffsetPair {
    constructor(offset1, offset2) {
      this.offset1 = offset1;
      this.offset2 = offset2;
    }
    toString() {
      return `${this.offset1} <-> ${this.offset2}`;
    }
    delta(offset) {
      if (offset === 0) {
        return this;
      }
      return new _OffsetPair(this.offset1 + offset, this.offset2 + offset);
    }
    equals(other) {
      return this.offset1 === other.offset1 && this.offset2 === other.offset2;
    }
  };
  OffsetPair.zero = new OffsetPair(0, 0);
  OffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  var InfiniteTimeout = class {
    isValid() {
      return true;
    }
  };
  InfiniteTimeout.instance = new InfiniteTimeout();
  var DateTimeout = class {
    constructor(timeout) {
      this.timeout = timeout;
      this.startTime = Date.now();
      this.valid = true;
      if (timeout <= 0) {
        throw new BugIndicatingError("timeout must be positive");
      }
    }
    // Recommendation: Set a log-point `{this.disable()}` in the body
    isValid() {
      const valid = Date.now() - this.startTime < this.timeout;
      if (!valid && this.valid) {
        this.valid = false;
        debugger;
      }
      return this.valid;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
  var Array2D = class {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.array = [];
      this.array = new Array(width * height);
    }
    get(x2, y2) {
      return this.array[x2 + y2 * this.width];
    }
    set(x2, y2, value2) {
      this.array[x2 + y2 * this.width] = value2;
    }
  };
  function isSpace(charCode) {
    return charCode === 32 || charCode === 9;
  }
  var LineRangeFragment = class _LineRangeFragment {
    static getKey(chr) {
      let key = this.chrKeys.get(chr);
      if (key === void 0) {
        key = this.chrKeys.size;
        this.chrKeys.set(chr, key);
      }
      return key;
    }
    constructor(range, lines, source) {
      this.range = range;
      this.lines = lines;
      this.source = source;
      this.histogram = [];
      let counter = 0;
      for (let i2 = range.startLineNumber - 1; i2 < range.endLineNumberExclusive - 1; i2++) {
        const line = lines[i2];
        for (let j2 = 0; j2 < line.length; j2++) {
          counter++;
          const chr = line[j2];
          const key2 = _LineRangeFragment.getKey(chr);
          this.histogram[key2] = (this.histogram[key2] || 0) + 1;
        }
        counter++;
        const key = _LineRangeFragment.getKey("\n");
        this.histogram[key] = (this.histogram[key] || 0) + 1;
      }
      this.totalCount = counter;
    }
    computeSimilarity(other) {
      var _a4, _b3;
      let sumDifferences = 0;
      const maxLength = Math.max(this.histogram.length, other.histogram.length);
      for (let i2 = 0; i2 < maxLength; i2++) {
        sumDifferences += Math.abs(((_a4 = this.histogram[i2]) !== null && _a4 !== void 0 ? _a4 : 0) - ((_b3 = other.histogram[i2]) !== null && _b3 !== void 0 ? _b3 : 0));
      }
      return 1 - sumDifferences / (this.totalCount + other.totalCount);
    }
  };
  LineRangeFragment.chrKeys = /* @__PURE__ */ new Map();

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
  var DynamicProgrammingDiffing = class {
    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {
      if (sequence1.length === 0 || sequence2.length === 0) {
        return DiffAlgorithmResult.trivial(sequence1, sequence2);
      }
      const lcsLengths = new Array2D(sequence1.length, sequence2.length);
      const directions = new Array2D(sequence1.length, sequence2.length);
      const lengths = new Array2D(sequence1.length, sequence2.length);
      for (let s12 = 0; s12 < sequence1.length; s12++) {
        for (let s22 = 0; s22 < sequence2.length; s22++) {
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
          }
          const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
          const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
          let extendedSeqScore;
          if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
            if (s12 === 0 || s22 === 0) {
              extendedSeqScore = 0;
            } else {
              extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
            }
            if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
              extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
            }
            extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
          } else {
            extendedSeqScore = -1;
          }
          const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
          if (newValue === extendedSeqScore) {
            const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
            lengths.set(s12, s22, prevLen + 1);
            directions.set(s12, s22, 3);
          } else if (newValue === horizontalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 1);
          } else if (newValue === verticalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 2);
          }
          lcsLengths.set(s12, s22, newValue);
        }
      }
      const result = [];
      let lastAligningPosS1 = sequence1.length;
      let lastAligningPosS2 = sequence2.length;
      function reportDecreasingAligningPositions(s12, s22) {
        if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
        }
        lastAligningPosS1 = s12;
        lastAligningPosS2 = s22;
      }
      let s1 = sequence1.length - 1;
      let s2 = sequence2.length - 1;
      while (s1 >= 0 && s2 >= 0) {
        if (directions.get(s1, s2) === 3) {
          reportDecreasingAligningPositions(s1, s2);
          s1--;
          s2--;
        } else {
          if (directions.get(s1, s2) === 1) {
            s1--;
          } else {
            s2--;
          }
        }
      }
      reportDecreasingAligningPositions(-1, -1);
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js
  var MyersDiffAlgorithm = class {
    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {
      if (seq1.length === 0 || seq2.length === 0) {
        return DiffAlgorithmResult.trivial(seq1, seq2);
      }
      const seqX = seq1;
      const seqY = seq2;
      function getXAfterSnake(x2, y2) {
        while (x2 < seqX.length && y2 < seqY.length && seqX.getElement(x2) === seqY.getElement(y2)) {
          x2++;
          y2++;
        }
        return x2;
      }
      let d2 = 0;
      const V3 = new FastInt32Array();
      V3.set(0, getXAfterSnake(0, 0));
      const paths = new FastArrayNegativeIndices();
      paths.set(0, V3.get(0) === 0 ? null : new SnakePath(null, 0, 0, V3.get(0)));
      let k5 = 0;
      loop: while (true) {
        d2++;
        if (!timeout.isValid()) {
          return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
        }
        const lowerBound = -Math.min(d2, seqY.length + d2 % 2);
        const upperBound = Math.min(d2, seqX.length + d2 % 2);
        for (k5 = lowerBound; k5 <= upperBound; k5 += 2) {
          let step = 0;
          const maxXofDLineTop = k5 === upperBound ? -1 : V3.get(k5 + 1);
          const maxXofDLineLeft = k5 === lowerBound ? -1 : V3.get(k5 - 1) + 1;
          step++;
          const x2 = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
          const y2 = x2 - k5;
          step++;
          if (x2 > seqX.length || y2 > seqY.length) {
            continue;
          }
          const newMaxX = getXAfterSnake(x2, y2);
          V3.set(k5, newMaxX);
          const lastPath = x2 === maxXofDLineTop ? paths.get(k5 + 1) : paths.get(k5 - 1);
          paths.set(k5, newMaxX !== x2 ? new SnakePath(lastPath, x2, y2, newMaxX - x2) : lastPath);
          if (V3.get(k5) === seqX.length && V3.get(k5) - k5 === seqY.length) {
            break loop;
          }
        }
      }
      let path = paths.get(k5);
      const result = [];
      let lastAligningPosS1 = seqX.length;
      let lastAligningPosS2 = seqY.length;
      while (true) {
        const endX = path ? path.x + path.length : 0;
        const endY = path ? path.y + path.length : 0;
        if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
        }
        if (!path) {
          break;
        }
        lastAligningPosS1 = path.x;
        lastAligningPosS2 = path.y;
        path = path.prev;
      }
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };
  var SnakePath = class {
    constructor(prev, x2, y2, length2) {
      this.prev = prev;
      this.x = x2;
      this.y = y2;
      this.length = length2;
    }
  };
  var FastInt32Array = class {
    constructor() {
      this.positiveArr = new Int32Array(10);
      this.negativeArr = new Int32Array(10);
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value2) {
      if (idx < 0) {
        idx = -idx - 1;
        if (idx >= this.negativeArr.length) {
          const arr = this.negativeArr;
          this.negativeArr = new Int32Array(arr.length * 2);
          this.negativeArr.set(arr);
        }
        this.negativeArr[idx] = value2;
      } else {
        if (idx >= this.positiveArr.length) {
          const arr = this.positiveArr;
          this.positiveArr = new Int32Array(arr.length * 2);
          this.positiveArr.set(arr);
        }
        this.positiveArr[idx] = value2;
      }
    }
  };
  var FastArrayNegativeIndices = class {
    constructor() {
      this.positiveArr = [];
      this.negativeArr = [];
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value2) {
      if (idx < 0) {
        idx = -idx - 1;
        this.negativeArr[idx] = value2;
      } else {
        this.positiveArr[idx] = value2;
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
  var LinesSliceCharSequence = class {
    constructor(lines, lineRange, considerWhitespaceChanges) {
      this.lines = lines;
      this.considerWhitespaceChanges = considerWhitespaceChanges;
      this.elements = [];
      this.firstCharOffsetByLine = [];
      this.additionalOffsetByLine = [];
      let trimFirstLineFully = false;
      if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
        lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);
        trimFirstLineFully = true;
      }
      this.lineRange = lineRange;
      this.firstCharOffsetByLine[0] = 0;
      for (let i2 = this.lineRange.start; i2 < this.lineRange.endExclusive; i2++) {
        let line = lines[i2];
        let offset = 0;
        if (trimFirstLineFully) {
          offset = line.length;
          line = "";
          trimFirstLineFully = false;
        } else if (!considerWhitespaceChanges) {
          const trimmedStartLine = line.trimStart();
          offset = line.length - trimmedStartLine.length;
          line = trimmedStartLine.trimEnd();
        }
        this.additionalOffsetByLine.push(offset);
        for (let i3 = 0; i3 < line.length; i3++) {
          this.elements.push(line.charCodeAt(i3));
        }
        if (i2 < lines.length - 1) {
          this.elements.push("\n".charCodeAt(0));
          this.firstCharOffsetByLine[i2 - this.lineRange.start + 1] = this.elements.length;
        }
      }
      this.additionalOffsetByLine.push(0);
    }
    toString() {
      return `Slice: "${this.text}"`;
    }
    get text() {
      return this.getText(new OffsetRange(0, this.length));
    }
    getText(range) {
      return this.elements.slice(range.start, range.endExclusive).map((e5) => String.fromCharCode(e5)).join("");
    }
    getElement(offset) {
      return this.elements[offset];
    }
    get length() {
      return this.elements.length;
    }
    getBoundaryScore(length2) {
      const prevCategory = getCategory(length2 > 0 ? this.elements[length2 - 1] : -1);
      const nextCategory = getCategory(length2 < this.elements.length ? this.elements[length2] : -1);
      if (prevCategory === 7 && nextCategory === 8) {
        return 0;
      }
      if (prevCategory === 8) {
        return 150;
      }
      let score2 = 0;
      if (prevCategory !== nextCategory) {
        score2 += 10;
        if (prevCategory === 0 && nextCategory === 1) {
          score2 += 1;
        }
      }
      score2 += getCategoryBoundaryScore(prevCategory);
      score2 += getCategoryBoundaryScore(nextCategory);
      return score2;
    }
    translateOffset(offset) {
      if (this.lineRange.isEmpty) {
        return new Position2(this.lineRange.start + 1, 1);
      }
      const i2 = findLastIdxMonotonous(this.firstCharOffsetByLine, (value2) => value2 <= offset);
      return new Position2(this.lineRange.start + i2 + 1, offset - this.firstCharOffsetByLine[i2] + this.additionalOffsetByLine[i2] + 1);
    }
    translateRange(range) {
      return Range2.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
    }
    /**
     * Finds the word that contains the character at the given offset
     */
    findWordContaining(offset) {
      if (offset < 0 || offset >= this.elements.length) {
        return void 0;
      }
      if (!isWordChar(this.elements[offset])) {
        return void 0;
      }
      let start = offset;
      while (start > 0 && isWordChar(this.elements[start - 1])) {
        start--;
      }
      let end = offset;
      while (end < this.elements.length && isWordChar(this.elements[end])) {
        end++;
      }
      return new OffsetRange(start, end);
    }
    countLinesIn(range) {
      return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
    }
    isStronglyEqual(offset1, offset2) {
      return this.elements[offset1] === this.elements[offset2];
    }
    extendToFullLines(range) {
      var _a4, _b3;
      const start = (_a4 = findLastMonotonous(this.firstCharOffsetByLine, (x2) => x2 <= range.start)) !== null && _a4 !== void 0 ? _a4 : 0;
      const end = (_b3 = findFirstMonotonous(this.firstCharOffsetByLine, (x2) => range.endExclusive <= x2)) !== null && _b3 !== void 0 ? _b3 : this.elements.length;
      return new OffsetRange(start, end);
    }
  };
  function isWordChar(charCode) {
    return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
  }
  var score = {
    [
      0
      /* CharBoundaryCategory.WordLower */
    ]: 0,
    [
      1
      /* CharBoundaryCategory.WordUpper */
    ]: 0,
    [
      2
      /* CharBoundaryCategory.WordNumber */
    ]: 0,
    [
      3
      /* CharBoundaryCategory.End */
    ]: 10,
    [
      4
      /* CharBoundaryCategory.Other */
    ]: 2,
    [
      5
      /* CharBoundaryCategory.Separator */
    ]: 30,
    [
      6
      /* CharBoundaryCategory.Space */
    ]: 3,
    [
      7
      /* CharBoundaryCategory.LineBreakCR */
    ]: 10,
    [
      8
      /* CharBoundaryCategory.LineBreakLF */
    ]: 10
  };
  function getCategoryBoundaryScore(category) {
    return score[category];
  }
  function getCategory(charCode) {
    if (charCode === 10) {
      return 8;
    } else if (charCode === 13) {
      return 7;
    } else if (isSpace(charCode)) {
      return 6;
    } else if (charCode >= 97 && charCode <= 122) {
      return 0;
    } else if (charCode >= 65 && charCode <= 90) {
      return 1;
    } else if (charCode >= 48 && charCode <= 57) {
      return 2;
    } else if (charCode === -1) {
      return 3;
    } else if (charCode === 44 || charCode === 59) {
      return 5;
    } else {
      return 4;
    }
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
  function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {
    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);
    if (!timeout.isValid()) {
      return [];
    }
    const filteredChanges = changes.filter((c3) => !excludedChanges.has(c3));
    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);
    pushMany(moves, unchangedMoves);
    moves = joinCloseConsecutiveMoves(moves);
    moves = moves.filter((current) => {
      const lines = current.original.toOffsetRange().slice(originalLines).map((l2) => l2.trim());
      const originalText = lines.join("\n");
      return originalText.length >= 15 && countWhere(lines, (l2) => l2.length >= 2) >= 2;
    });
    moves = removeMovesInSameDiff(changes, moves);
    return moves;
  }
  function countWhere(arr, predicate) {
    let count = 0;
    for (const t2 of arr) {
      if (predicate(t2)) {
        count++;
      }
    }
    return count;
  }
  function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {
    const moves = [];
    const deletions = changes.filter((c3) => c3.modified.isEmpty && c3.original.length >= 3).map((d2) => new LineRangeFragment(d2.original, originalLines, d2));
    const insertions = new Set(changes.filter((c3) => c3.original.isEmpty && c3.modified.length >= 3).map((d2) => new LineRangeFragment(d2.modified, modifiedLines, d2)));
    const excludedChanges = /* @__PURE__ */ new Set();
    for (const deletion of deletions) {
      let highestSimilarity = -1;
      let best;
      for (const insertion of insertions) {
        const similarity = deletion.computeSimilarity(insertion);
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          best = insertion;
        }
      }
      if (highestSimilarity > 0.9 && best) {
        insertions.delete(best);
        moves.push(new LineRangeMapping(deletion.range, best.range));
        excludedChanges.add(deletion.source);
        excludedChanges.add(best.source);
      }
      if (!timeout.isValid()) {
        return { moves, excludedChanges };
      }
    }
    return { moves, excludedChanges };
  }
  function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {
    const moves = [];
    const original3LineHashes = new SetMap();
    for (const change of changes) {
      for (let i2 = change.original.startLineNumber; i2 < change.original.endLineNumberExclusive - 2; i2++) {
        const key = `${hashedOriginalLines[i2 - 1]}:${hashedOriginalLines[i2 + 1 - 1]}:${hashedOriginalLines[i2 + 2 - 1]}`;
        original3LineHashes.add(key, { range: new LineRange(i2, i2 + 3) });
      }
    }
    const possibleMappings = [];
    changes.sort(compareBy((c3) => c3.modified.startLineNumber, numberComparator));
    for (const change of changes) {
      let lastMappings = [];
      for (let i2 = change.modified.startLineNumber; i2 < change.modified.endLineNumberExclusive - 2; i2++) {
        const key = `${hashedModifiedLines[i2 - 1]}:${hashedModifiedLines[i2 + 1 - 1]}:${hashedModifiedLines[i2 + 2 - 1]}`;
        const currentModifiedRange = new LineRange(i2, i2 + 3);
        const nextMappings = [];
        original3LineHashes.forEach(key, ({ range }) => {
          for (const lastMapping of lastMappings) {
            if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
              lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
              lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
              nextMappings.push(lastMapping);
              return;
            }
          }
          const mapping = {
            modifiedLineRange: currentModifiedRange,
            originalLineRange: range
          };
          possibleMappings.push(mapping);
          nextMappings.push(mapping);
        });
        lastMappings = nextMappings;
      }
      if (!timeout.isValid()) {
        return [];
      }
    }
    possibleMappings.sort(reverseOrder(compareBy((m2) => m2.modifiedLineRange.length, numberComparator)));
    const modifiedSet = new LineRangeSet();
    const originalSet = new LineRangeSet();
    for (const mapping of possibleMappings) {
      const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
      const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
      const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
      const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
      for (const s2 of modifiedIntersectedSections.ranges) {
        if (s2.length < 3) {
          continue;
        }
        const modifiedLineRange = s2;
        const originalLineRange = s2.delta(-diffOrigToMod);
        moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));
        modifiedSet.addRange(modifiedLineRange);
        originalSet.addRange(originalLineRange);
      }
    }
    moves.sort(compareBy((m2) => m2.original.startLineNumber, numberComparator));
    const monotonousChanges = new MonotonousArray(changes);
    for (let i2 = 0; i2 < moves.length; i2++) {
      const move = moves[i2];
      const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c3) => c3.original.startLineNumber <= move.original.startLineNumber);
      const firstTouchingChangeMod = findLastMonotonous(changes, (c3) => c3.modified.startLineNumber <= move.modified.startLineNumber);
      const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
      const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c3) => c3.original.startLineNumber < move.original.endLineNumberExclusive);
      const lastTouchingChangeMod = findLastMonotonous(changes, (c3) => c3.modified.startLineNumber < move.modified.endLineNumberExclusive);
      const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
      let extendToTop;
      for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
        const origLine = move.original.startLineNumber - extendToTop - 1;
        const modLine = move.modified.startLineNumber - extendToTop - 1;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToTop > 0) {
        originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
        modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
      }
      let extendToBottom;
      for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
        const origLine = move.original.endLineNumberExclusive + extendToBottom;
        const modLine = move.modified.endLineNumberExclusive + extendToBottom;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToBottom > 0) {
        originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
        modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
      }
      if (extendToTop > 0 || extendToBottom > 0) {
        moves[i2] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
      }
    }
    return moves;
  }
  function areLinesSimilar(line1, line2, timeout) {
    if (line1.trim() === line2.trim()) {
      return true;
    }
    if (line1.length > 300 && line2.length > 300) {
      return false;
    }
    const myersDiffingAlgorithm = new MyersDiffAlgorithm();
    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);
    let commonNonSpaceCharCount = 0;
    const inverted = SequenceDiff.invert(result.diffs, line1.length);
    for (const seq of inverted) {
      seq.seq1Range.forEach((idx) => {
        if (!isSpace(line1.charCodeAt(idx))) {
          commonNonSpaceCharCount++;
        }
      });
    }
    function countNonWsChars(str) {
      let count = 0;
      for (let i2 = 0; i2 < line1.length; i2++) {
        if (!isSpace(str.charCodeAt(i2))) {
          count++;
        }
      }
      return count;
    }
    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
    const r3 = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
    return r3;
  }
  function joinCloseConsecutiveMoves(moves) {
    if (moves.length === 0) {
      return moves;
    }
    moves.sort(compareBy((m2) => m2.original.startLineNumber, numberComparator));
    const result = [moves[0]];
    for (let i2 = 1; i2 < moves.length; i2++) {
      const last = result[result.length - 1];
      const current = moves[i2];
      const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
      const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
      const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
      if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
        result[result.length - 1] = last.join(current);
        continue;
      }
      result.push(current);
    }
    return result;
  }
  function removeMovesInSameDiff(changes, moves) {
    const changesMonotonous = new MonotonousArray(changes);
    moves = moves.filter((m2) => {
      const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c3) => c3.original.startLineNumber < m2.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));
      const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c3) => c3.modified.startLineNumber < m2.modified.endLineNumberExclusive);
      const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
      return differentDiffs;
    });
    return moves;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
  function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    let result = sequenceDiffs;
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = shiftSequenceDiffs(sequence1, sequence2, result);
    return result;
  }
  function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
    if (sequenceDiffs.length === 0) {
      return sequenceDiffs;
    }
    const result = [];
    result.push(sequenceDiffs[0]);
    for (let i2 = 1; i2 < sequenceDiffs.length; i2++) {
      const prevResult = result[result.length - 1];
      let cur = sequenceDiffs[i2];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length2 = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
        let d2;
        for (d2 = 1; d2 <= length2; d2++) {
          if (sequence1.getElement(cur.seq1Range.start - d2) !== sequence1.getElement(cur.seq1Range.endExclusive - d2) || sequence2.getElement(cur.seq2Range.start - d2) !== sequence2.getElement(cur.seq2Range.endExclusive - d2)) {
            break;
          }
        }
        d2--;
        if (d2 === length2) {
          result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length2), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length2));
          continue;
        }
        cur = cur.delta(-d2);
      }
      result.push(cur);
    }
    const result2 = [];
    for (let i2 = 0; i2 < result.length - 1; i2++) {
      const nextResult = result[i2 + 1];
      let cur = result[i2];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length2 = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
        let d2;
        for (d2 = 0; d2 < length2; d2++) {
          if (!sequence1.isStronglyEqual(cur.seq1Range.start + d2, cur.seq1Range.endExclusive + d2) || !sequence2.isStronglyEqual(cur.seq2Range.start + d2, cur.seq2Range.endExclusive + d2)) {
            break;
          }
        }
        if (d2 === length2) {
          result[i2 + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length2, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length2, nextResult.seq2Range.endExclusive));
          continue;
        }
        if (d2 > 0) {
          cur = cur.delta(d2);
        }
      }
      result2.push(cur);
    }
    if (result.length > 0) {
      result2.push(result[result.length - 1]);
    }
    return result2;
  }
  function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
      return sequenceDiffs;
    }
    for (let i2 = 0; i2 < sequenceDiffs.length; i2++) {
      const prevDiff = i2 > 0 ? sequenceDiffs[i2 - 1] : void 0;
      const diff = sequenceDiffs[i2];
      const nextDiff = i2 + 1 < sequenceDiffs.length ? sequenceDiffs[i2 + 1] : void 0;
      const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);
      const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);
      if (diff.seq1Range.isEmpty) {
        sequenceDiffs[i2] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
      } else if (diff.seq2Range.isEmpty) {
        sequenceDiffs[i2] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
      }
    }
    return sequenceDiffs;
  }
  function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
    const maxShiftLimit = 100;
    let deltaBefore = 1;
    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
      deltaBefore++;
    }
    deltaBefore--;
    let deltaAfter = 0;
    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
      deltaAfter++;
    }
    if (deltaBefore === 0 && deltaAfter === 0) {
      return diff;
    }
    let bestDelta = 0;
    let bestScore = -1;
    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
      const seq2OffsetStart = diff.seq2Range.start + delta;
      const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
      const seq1Offset = diff.seq1Range.start + delta;
      const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
      if (score2 > bestScore) {
        bestScore = score2;
        bestDelta = delta;
      }
    }
    return diff.delta(bestDelta);
  }
  function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    for (const s2 of sequenceDiffs) {
      const last = result[result.length - 1];
      if (!last) {
        result.push(s2);
        continue;
      }
      if (s2.seq1Range.start - last.seq1Range.endExclusive <= 2 || s2.seq2Range.start - last.seq2Range.endExclusive <= 2) {
        result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s2.seq1Range), last.seq2Range.join(s2.seq2Range));
      } else {
        result.push(s2);
      }
    }
    return result;
  }
  function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);
    const additional = [];
    let lastPoint = new OffsetPair(0, 0);
    function scanWord(pair, equalMapping) {
      if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {
        return;
      }
      const w1 = sequence1.findWordContaining(pair.offset1);
      const w2 = sequence2.findWordContaining(pair.offset2);
      if (!w1 || !w2) {
        return;
      }
      let w3 = new SequenceDiff(w1, w2);
      const equalPart = w3.intersect(equalMapping);
      let equalChars1 = equalPart.seq1Range.length;
      let equalChars2 = equalPart.seq2Range.length;
      while (equalMappings.length > 0) {
        const next = equalMappings[0];
        const intersects = next.seq1Range.intersects(w3.seq1Range) || next.seq2Range.intersects(w3.seq2Range);
        if (!intersects) {
          break;
        }
        const v1 = sequence1.findWordContaining(next.seq1Range.start);
        const v2 = sequence2.findWordContaining(next.seq2Range.start);
        const v3 = new SequenceDiff(v1, v2);
        const equalPart2 = v3.intersect(next);
        equalChars1 += equalPart2.seq1Range.length;
        equalChars2 += equalPart2.seq2Range.length;
        w3 = w3.join(v3);
        if (w3.seq1Range.endExclusive >= next.seq1Range.endExclusive) {
          equalMappings.shift();
        } else {
          break;
        }
      }
      if (equalChars1 + equalChars2 < (w3.seq1Range.length + w3.seq2Range.length) * 2 / 3) {
        additional.push(w3);
      }
      lastPoint = w3.getEndExclusives();
    }
    while (equalMappings.length > 0) {
      const next = equalMappings.shift();
      if (next.seq1Range.isEmpty) {
        continue;
      }
      scanWord(next.getStarts(), next);
      scanWord(next.getEndExclusives().delta(-1), next);
    }
    const merged = mergeSequenceDiffs(sequenceDiffs, additional);
    return merged;
  }
  function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
    const result = [];
    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
      const sd1 = sequenceDiffs1[0];
      const sd2 = sequenceDiffs2[0];
      let next;
      if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
        next = sequenceDiffs1.shift();
      } else {
        next = sequenceDiffs2.shift();
      }
      if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
        result[result.length - 1] = result[result.length - 1].join(next);
      } else {
        result.push(next);
      }
    }
    return result;
  }
  function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i2 = 1; i2 < diffs.length; i2++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedText = sequence1.getText(unchangedRange);
          const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
          if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
            return true;
          }
          return false;
        };
        const cur = diffs[i2];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    return diffs;
  }
  function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i2 = 1; i2 < diffs.length; i2++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
          if (unchangedLineCount > 5 || unchangedRange.length > 500) {
            return false;
          }
          const unchangedText = sequence1.getText(unchangedRange).trim();
          if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
            return false;
          }
          const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
          const beforeSeq1Length = before.seq1Range.length;
          const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
          const beforeSeq2Length = before.seq2Range.length;
          const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
          const afterSeq1Length = after.seq1Range.length;
          const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
          const afterSeq2Length = after.seq2Range.length;
          const max2 = 2 * 40 + 50;
          function cap(v2) {
            return Math.min(v2, max2);
          }
          if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max2 ** 1.5) ** 1.5 * 1.3) {
            return true;
          }
          return false;
        };
        const cur = diffs[i2];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    const newDiffs = [];
    forEachWithNeighbors(diffs, (prev, cur, next) => {
      let newDiff = cur;
      function shouldMarkAsChanged(text2) {
        return text2.length > 0 && text2.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
      }
      const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
      const prefix3 = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));
      if (shouldMarkAsChanged(prefix3)) {
        newDiff = newDiff.deltaStart(-prefix3.length);
      }
      const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
      if (shouldMarkAsChanged(suffix)) {
        newDiff = newDiff.deltaEnd(suffix.length);
      }
      const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);
      const result = newDiff.intersect(availableSpace);
      if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {
        newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);
      } else {
        newDiffs.push(result);
      }
    });
    return newDiffs;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js
  var LineSequence2 = class {
    constructor(trimmedHash, lines) {
      this.trimmedHash = trimmedHash;
      this.lines = lines;
    }
    getElement(offset) {
      return this.trimmedHash[offset];
    }
    get length() {
      return this.trimmedHash.length;
    }
    getBoundaryScore(length2) {
      const indentationBefore = length2 === 0 ? 0 : getIndentation(this.lines[length2 - 1]);
      const indentationAfter = length2 === this.lines.length ? 0 : getIndentation(this.lines[length2]);
      return 1e3 - (indentationBefore + indentationAfter);
    }
    getText(range) {
      return this.lines.slice(range.start, range.endExclusive).join("\n");
    }
    isStronglyEqual(offset1, offset2) {
      return this.lines[offset1] === this.lines[offset2];
    }
  };
  function getIndentation(str) {
    let i2 = 0;
    while (i2 < str.length && (str.charCodeAt(i2) === 32 || str.charCodeAt(i2) === 9)) {
      i2++;
    }
    return i2;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
  var DefaultLinesDiffComputer = class {
    constructor() {
      this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
      this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
    }
    computeDiff(originalLines, modifiedLines, options) {
      if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a2, b2) => a2 === b2)) {
        return new LinesDiff([], [], false);
      }
      if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
        return new LinesDiff([
          new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [
            new RangeMapping(new Range2(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range2(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))
          ])
        ], [], false);
      }
      const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);
      const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
      const perfectHashes = /* @__PURE__ */ new Map();
      function getOrCreateHash(text2) {
        let hash = perfectHashes.get(text2);
        if (hash === void 0) {
          hash = perfectHashes.size;
          perfectHashes.set(text2, hash);
        }
        return hash;
      }
      const originalLinesHashes = originalLines.map((l2) => getOrCreateHash(l2.trim()));
      const modifiedLinesHashes = modifiedLines.map((l2) => getOrCreateHash(l2.trim()));
      const sequence1 = new LineSequence2(originalLinesHashes, originalLines);
      const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);
      const lineAlignmentResult = (() => {
        if (sequence1.length + sequence2.length < 1700) {
          return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
        }
        return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
      })();
      let lineAlignments = lineAlignmentResult.diffs;
      let hitTimeout = lineAlignmentResult.hitTimeout;
      lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
      lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);
      const alignments = [];
      const scanForWhitespaceChanges = (equalLinesCount) => {
        if (!considerWhitespaceChanges) {
          return;
        }
        for (let i2 = 0; i2 < equalLinesCount; i2++) {
          const seq1Offset = seq1LastStart + i2;
          const seq2Offset = seq2LastStart + i2;
          if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
            const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
            for (const a2 of characterDiffs.mappings) {
              alignments.push(a2);
            }
            if (characterDiffs.hitTimeout) {
              hitTimeout = true;
            }
          }
        }
      };
      let seq1LastStart = 0;
      let seq2LastStart = 0;
      for (const diff of lineAlignments) {
        assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
        const equalLinesCount = diff.seq1Range.start - seq1LastStart;
        scanForWhitespaceChanges(equalLinesCount);
        seq1LastStart = diff.seq1Range.endExclusive;
        seq2LastStart = diff.seq2Range.endExclusive;
        const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
        if (characterDiffs.hitTimeout) {
          hitTimeout = true;
        }
        for (const a2 of characterDiffs.mappings) {
          alignments.push(a2);
        }
      }
      scanForWhitespaceChanges(originalLines.length - seq1LastStart);
      const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
      let moves = [];
      if (options.computeMoves) {
        moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);
      }
      assertFn(() => {
        function validatePosition(pos, lines) {
          if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
            return false;
          }
          const line = lines[pos.lineNumber - 1];
          if (pos.column < 1 || pos.column > line.length + 1) {
            return false;
          }
          return true;
        }
        function validateRange(range, lines) {
          if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
            return false;
          }
          if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
            return false;
          }
          return true;
        }
        for (const c3 of changes) {
          if (!c3.innerChanges) {
            return false;
          }
          for (const ic of c3.innerChanges) {
            const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
            if (!valid) {
              return false;
            }
          }
          if (!validateRange(c3.modified, modifiedLines) || !validateRange(c3.original, originalLines)) {
            return false;
          }
        }
        return true;
      });
      return new LinesDiff(changes, moves, hitTimeout);
    }
    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
      const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);
      const movesWithDiffs = moves.map((m2) => {
        const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m2.original.toOffsetRange(), m2.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
        const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
        return new MovedText(m2, mappings);
      });
      return movesWithDiffs;
    }
    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
      const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
      const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
      const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
      let diffs = diffResult.diffs;
      diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
      diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);
      diffs = removeShortMatches(slice1, slice2, diffs);
      diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);
      const result = diffs.map((d2) => new RangeMapping(slice1.translateRange(d2.seq1Range), slice2.translateRange(d2.seq2Range)));
      return {
        mappings: result,
        hitTimeout: diffResult.hitTimeout
      };
    }
  };
  function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
    const changes = [];
    for (const g2 of groupAdjacentBy(alignments.map((a2) => getLineRangeMapping(a2, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
      const first = g2[0];
      const last = g2[g2.length - 1];
      changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g2.map((a2) => a2.innerChanges[0])));
    }
    assertFn(() => {
      if (!dontAssertStartLine && changes.length > 0) {
        if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {
          return false;
        }
        if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {
          return false;
        }
      }
      return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return changes;
  }
  function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
    let lineStartDelta = 0;
    let lineEndDelta = 0;
    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
      lineEndDelta = -1;
    }
    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
      lineStartDelta = 1;
    }
    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
  var linesDiffComputers = {
    getLegacy: () => new LegacyLinesDiffComputer(),
    getDefault: () => new DefaultLinesDiffComputer()
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/color.js
  function roundFloat(number2, decimalPoints) {
    const decimal = Math.pow(10, decimalPoints);
    return Math.round(number2 * decimal) / decimal;
  }
  var RGBA = class {
    constructor(r3, g2, b2, a2 = 1) {
      this._rgbaBrand = void 0;
      this.r = Math.min(255, Math.max(0, r3)) | 0;
      this.g = Math.min(255, Math.max(0, g2)) | 0;
      this.b = Math.min(255, Math.max(0, b2)) | 0;
      this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
    }
    static equals(a2, b2) {
      return a2.r === b2.r && a2.g === b2.g && a2.b === b2.b && a2.a === b2.a;
    }
  };
  var HSLA = class _HSLA {
    constructor(h2, s2, l2, a2) {
      this._hslaBrand = void 0;
      this.h = Math.max(Math.min(360, h2), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s2), 0), 3);
      this.l = roundFloat(Math.max(Math.min(1, l2), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
    }
    static equals(a2, b2) {
      return a2.h === b2.h && a2.s === b2.s && a2.l === b2.l && a2.a === b2.a;
    }
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba) {
      const r3 = rgba.r / 255;
      const g2 = rgba.g / 255;
      const b2 = rgba.b / 255;
      const a2 = rgba.a;
      const max2 = Math.max(r3, g2, b2);
      const min = Math.min(r3, g2, b2);
      let h2 = 0;
      let s2 = 0;
      const l2 = (min + max2) / 2;
      const chroma = max2 - min;
      if (chroma > 0) {
        s2 = Math.min(l2 <= 0.5 ? chroma / (2 * l2) : chroma / (2 - 2 * l2), 1);
        switch (max2) {
          case r3:
            h2 = (g2 - b2) / chroma + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r3) / chroma + 2;
            break;
          case b2:
            h2 = (r3 - g2) / chroma + 4;
            break;
        }
        h2 *= 60;
        h2 = Math.round(h2);
      }
      return new _HSLA(h2, s2, l2, a2);
    }
    static _hue2rgb(p4, q2, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p4 + (q2 - p4) * 6 * t2;
      }
      if (t2 < 1 / 2) {
        return q2;
      }
      if (t2 < 2 / 3) {
        return p4 + (q2 - p4) * (2 / 3 - t2) * 6;
      }
      return p4;
    }
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla) {
      const h2 = hsla.h / 360;
      const { s: s2, l: l2, a: a2 } = hsla;
      let r3, g2, b2;
      if (s2 === 0) {
        r3 = g2 = b2 = l2;
      } else {
        const q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        const p4 = 2 * l2 - q2;
        r3 = _HSLA._hue2rgb(p4, q2, h2 + 1 / 3);
        g2 = _HSLA._hue2rgb(p4, q2, h2);
        b2 = _HSLA._hue2rgb(p4, q2, h2 - 1 / 3);
      }
      return new RGBA(Math.round(r3 * 255), Math.round(g2 * 255), Math.round(b2 * 255), a2);
    }
  };
  var HSVA = class _HSVA {
    constructor(h2, s2, v2, a2) {
      this._hsvaBrand = void 0;
      this.h = Math.max(Math.min(360, h2), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s2), 0), 3);
      this.v = roundFloat(Math.max(Math.min(1, v2), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
    }
    static equals(a2, b2) {
      return a2.h === b2.h && a2.s === b2.s && a2.v === b2.v && a2.a === b2.a;
    }
    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    static fromRGBA(rgba) {
      const r3 = rgba.r / 255;
      const g2 = rgba.g / 255;
      const b2 = rgba.b / 255;
      const cmax = Math.max(r3, g2, b2);
      const cmin = Math.min(r3, g2, b2);
      const delta = cmax - cmin;
      const s2 = cmax === 0 ? 0 : delta / cmax;
      let m2;
      if (delta === 0) {
        m2 = 0;
      } else if (cmax === r3) {
        m2 = ((g2 - b2) / delta % 6 + 6) % 6;
      } else if (cmax === g2) {
        m2 = (b2 - r3) / delta + 2;
      } else {
        m2 = (r3 - g2) / delta + 4;
      }
      return new _HSVA(Math.round(m2 * 60), s2, cmax, rgba.a);
    }
    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    static toRGBA(hsva) {
      const { h: h2, s: s2, v: v2, a: a2 } = hsva;
      const c3 = v2 * s2;
      const x2 = c3 * (1 - Math.abs(h2 / 60 % 2 - 1));
      const m2 = v2 - c3;
      let [r3, g2, b2] = [0, 0, 0];
      if (h2 < 60) {
        r3 = c3;
        g2 = x2;
      } else if (h2 < 120) {
        r3 = x2;
        g2 = c3;
      } else if (h2 < 180) {
        g2 = c3;
        b2 = x2;
      } else if (h2 < 240) {
        g2 = x2;
        b2 = c3;
      } else if (h2 < 300) {
        r3 = x2;
        b2 = c3;
      } else if (h2 <= 360) {
        r3 = c3;
        b2 = x2;
      }
      r3 = Math.round((r3 + m2) * 255);
      g2 = Math.round((g2 + m2) * 255);
      b2 = Math.round((b2 + m2) * 255);
      return new RGBA(r3, g2, b2, a2);
    }
  };
  var Color2 = class _Color {
    static fromHex(hex2) {
      return _Color.Format.CSS.parseHex(hex2) || _Color.red;
    }
    static equals(a2, b2) {
      if (!a2 && !b2) {
        return true;
      }
      if (!a2 || !b2) {
        return false;
      }
      return a2.equals(b2);
    }
    get hsla() {
      if (this._hsla) {
        return this._hsla;
      } else {
        return HSLA.fromRGBA(this.rgba);
      }
    }
    get hsva() {
      if (this._hsva) {
        return this._hsva;
      }
      return HSVA.fromRGBA(this.rgba);
    }
    constructor(arg) {
      if (!arg) {
        throw new Error("Color needs a value");
      } else if (arg instanceof RGBA) {
        this.rgba = arg;
      } else if (arg instanceof HSLA) {
        this._hsla = arg;
        this.rgba = HSLA.toRGBA(arg);
      } else if (arg instanceof HSVA) {
        this._hsva = arg;
        this.rgba = HSVA.toRGBA(arg);
      } else {
        throw new Error("Invalid color ctor argument");
      }
    }
    equals(other) {
      return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    }
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance() {
      const R3 = _Color._relativeLuminanceForComponent(this.rgba.r);
      const G2 = _Color._relativeLuminanceForComponent(this.rgba.g);
      const B2 = _Color._relativeLuminanceForComponent(this.rgba.b);
      const luminance = 0.2126 * R3 + 0.7152 * G2 + 0.0722 * B2;
      return roundFloat(luminance, 4);
    }
    static _relativeLuminanceForComponent(color2) {
      const c3 = color2 / 255;
      return c3 <= 0.03928 ? c3 / 12.92 : Math.pow((c3 + 0.055) / 1.055, 2.4);
    }
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter() {
      const yiq2 = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
      return yiq2 >= 128;
    }
    isLighterThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 > lum2;
    }
    isDarkerThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 < lum2;
    }
    lighten(factor2) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor2, this.hsla.a));
    }
    darken(factor2) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor2, this.hsla.a));
    }
    transparent(factor2) {
      const { r: r3, g: g2, b: b2, a: a2 } = this.rgba;
      return new _Color(new RGBA(r3, g2, b2, a2 * factor2));
    }
    isTransparent() {
      return this.rgba.a === 0;
    }
    isOpaque() {
      return this.rgba.a === 1;
    }
    opposite() {
      return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    makeOpaque(opaqueBackground) {
      if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
        return this;
      }
      const { r: r3, g: g2, b: b2, a: a2 } = this.rgba;
      return new _Color(new RGBA(opaqueBackground.rgba.r - a2 * (opaqueBackground.rgba.r - r3), opaqueBackground.rgba.g - a2 * (opaqueBackground.rgba.g - g2), opaqueBackground.rgba.b - a2 * (opaqueBackground.rgba.b - b2), 1));
    }
    toString() {
      if (!this._toString) {
        this._toString = _Color.Format.CSS.format(this);
      }
      return this._toString;
    }
    static getLighterColor(of, relative2, factor2) {
      if (of.isLighterThan(relative2)) {
        return of;
      }
      factor2 = factor2 ? factor2 : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor2 = factor2 * (lum2 - lum1) / lum2;
      return of.lighten(factor2);
    }
    static getDarkerColor(of, relative2, factor2) {
      if (of.isDarkerThan(relative2)) {
        return of;
      }
      factor2 = factor2 ? factor2 : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor2 = factor2 * (lum1 - lum2) / lum1;
      return of.darken(factor2);
    }
  };
  Color2.white = new Color2(new RGBA(255, 255, 255, 1));
  Color2.black = new Color2(new RGBA(0, 0, 0, 1));
  Color2.red = new Color2(new RGBA(255, 0, 0, 1));
  Color2.blue = new Color2(new RGBA(0, 0, 255, 1));
  Color2.green = new Color2(new RGBA(0, 255, 0, 1));
  Color2.cyan = new Color2(new RGBA(0, 255, 255, 1));
  Color2.lightgrey = new Color2(new RGBA(211, 211, 211, 1));
  Color2.transparent = new Color2(new RGBA(0, 0, 0, 0));
  (function(Color3) {
    let Format;
    (function(Format2) {
      let CSS;
      (function(CSS2) {
        function formatRGB(color2) {
          if (color2.rgba.a === 1) {
            return `rgb(${color2.rgba.r}, ${color2.rgba.g}, ${color2.rgba.b})`;
          }
          return Color3.Format.CSS.formatRGBA(color2);
        }
        CSS2.formatRGB = formatRGB;
        function formatRGBA(color2) {
          return `rgba(${color2.rgba.r}, ${color2.rgba.g}, ${color2.rgba.b}, ${+color2.rgba.a.toFixed(2)})`;
        }
        CSS2.formatRGBA = formatRGBA;
        function formatHSL(color2) {
          if (color2.hsla.a === 1) {
            return `hsl(${color2.hsla.h}, ${(color2.hsla.s * 100).toFixed(2)}%, ${(color2.hsla.l * 100).toFixed(2)}%)`;
          }
          return Color3.Format.CSS.formatHSLA(color2);
        }
        CSS2.formatHSL = formatHSL;
        function formatHSLA(color2) {
          return `hsla(${color2.hsla.h}, ${(color2.hsla.s * 100).toFixed(2)}%, ${(color2.hsla.l * 100).toFixed(2)}%, ${color2.hsla.a.toFixed(2)})`;
        }
        CSS2.formatHSLA = formatHSLA;
        function _toTwoDigitHex(n2) {
          const r3 = n2.toString(16);
          return r3.length !== 2 ? "0" + r3 : r3;
        }
        function formatHex2(color2) {
          return `#${_toTwoDigitHex(color2.rgba.r)}${_toTwoDigitHex(color2.rgba.g)}${_toTwoDigitHex(color2.rgba.b)}`;
        }
        CSS2.formatHex = formatHex2;
        function formatHexA(color2, compact = false) {
          if (compact && color2.rgba.a === 1) {
            return Color3.Format.CSS.formatHex(color2);
          }
          return `#${_toTwoDigitHex(color2.rgba.r)}${_toTwoDigitHex(color2.rgba.g)}${_toTwoDigitHex(color2.rgba.b)}${_toTwoDigitHex(Math.round(color2.rgba.a * 255))}`;
        }
        CSS2.formatHexA = formatHexA;
        function format(color2) {
          if (color2.isOpaque()) {
            return Color3.Format.CSS.formatHex(color2);
          }
          return Color3.Format.CSS.formatRGBA(color2);
        }
        CSS2.format = format;
        function parseHex2(hex2) {
          const length2 = hex2.length;
          if (length2 === 0) {
            return null;
          }
          if (hex2.charCodeAt(0) !== 35) {
            return null;
          }
          if (length2 === 7) {
            const r3 = 16 * _parseHexDigit(hex2.charCodeAt(1)) + _parseHexDigit(hex2.charCodeAt(2));
            const g2 = 16 * _parseHexDigit(hex2.charCodeAt(3)) + _parseHexDigit(hex2.charCodeAt(4));
            const b2 = 16 * _parseHexDigit(hex2.charCodeAt(5)) + _parseHexDigit(hex2.charCodeAt(6));
            return new Color3(new RGBA(r3, g2, b2, 1));
          }
          if (length2 === 9) {
            const r3 = 16 * _parseHexDigit(hex2.charCodeAt(1)) + _parseHexDigit(hex2.charCodeAt(2));
            const g2 = 16 * _parseHexDigit(hex2.charCodeAt(3)) + _parseHexDigit(hex2.charCodeAt(4));
            const b2 = 16 * _parseHexDigit(hex2.charCodeAt(5)) + _parseHexDigit(hex2.charCodeAt(6));
            const a2 = 16 * _parseHexDigit(hex2.charCodeAt(7)) + _parseHexDigit(hex2.charCodeAt(8));
            return new Color3(new RGBA(r3, g2, b2, a2 / 255));
          }
          if (length2 === 4) {
            const r3 = _parseHexDigit(hex2.charCodeAt(1));
            const g2 = _parseHexDigit(hex2.charCodeAt(2));
            const b2 = _parseHexDigit(hex2.charCodeAt(3));
            return new Color3(new RGBA(16 * r3 + r3, 16 * g2 + g2, 16 * b2 + b2));
          }
          if (length2 === 5) {
            const r3 = _parseHexDigit(hex2.charCodeAt(1));
            const g2 = _parseHexDigit(hex2.charCodeAt(2));
            const b2 = _parseHexDigit(hex2.charCodeAt(3));
            const a2 = _parseHexDigit(hex2.charCodeAt(4));
            return new Color3(new RGBA(16 * r3 + r3, 16 * g2 + g2, 16 * b2 + b2, (16 * a2 + a2) / 255));
          }
          return null;
        }
        CSS2.parseHex = parseHex2;
        function _parseHexDigit(charCode) {
          switch (charCode) {
            case 48:
              return 0;
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case 97:
              return 10;
            case 65:
              return 10;
            case 98:
              return 11;
            case 66:
              return 11;
            case 99:
              return 12;
            case 67:
              return 12;
            case 100:
              return 13;
            case 68:
              return 13;
            case 101:
              return 14;
            case 69:
              return 14;
            case 102:
              return 15;
            case 70:
              return 15;
          }
          return 0;
        }
      })(CSS = Format2.CSS || (Format2.CSS = {}));
    })(Format = Color3.Format || (Color3.Format = {}));
  })(Color2 || (Color2 = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
  function _parseCaptureGroups(captureGroups) {
    const values = [];
    for (const captureGroup of captureGroups) {
      const parsedNumber = Number(captureGroup);
      if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
        values.push(parsedNumber);
      }
    }
    return values;
  }
  function _toIColor(r3, g2, b2, a2) {
    return {
      red: r3 / 255,
      blue: b2 / 255,
      green: g2 / 255,
      alpha: a2
    };
  }
  function _findRange(model, match) {
    const index2 = match.index;
    const length2 = match[0].length;
    if (!index2) {
      return;
    }
    const startPosition = model.positionAt(index2);
    const range = {
      startLineNumber: startPosition.lineNumber,
      startColumn: startPosition.column,
      endLineNumber: startPosition.lineNumber,
      endColumn: startPosition.column + length2
    };
    return range;
  }
  function _findHexColorInformation(range, hexValue) {
    if (!range) {
      return;
    }
    const parsedHexColor = Color2.Format.CSS.parseHex(hexValue);
    if (!parsedHexColor) {
      return;
    }
    return {
      range,
      color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
    };
  }
  function _findRGBColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    return {
      range,
      color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
    };
  }
  function _findHSLColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    const colorEquivalent = new Color2(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
    return {
      range,
      color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
    };
  }
  function _findMatches(model, regex) {
    if (typeof model === "string") {
      return [...model.matchAll(regex)];
    } else {
      return model.findMatches(regex);
    }
  }
  function computeColors(model) {
    const result = [];
    const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
    const initialValidationMatches = _findMatches(model, initialValidationRegex);
    if (initialValidationMatches.length > 0) {
      for (const initialMatch of initialValidationMatches) {
        const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
        const colorScheme = initialCaptureGroups[1];
        const colorParameters = initialCaptureGroups[2];
        if (!colorParameters) {
          continue;
        }
        let colorInformation;
        if (colorScheme === "rgb") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "rgba") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "hsl") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "hsla") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "#") {
          colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
        }
        if (colorInformation) {
          result.push(colorInformation);
        }
      }
    }
    return result;
  }
  function computeDefaultDocumentColors(model) {
    if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
      return [];
    }
    return computeColors(model);
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js
  var markRegex = /\bMARK:\s*(.*)$/d;
  var trimDashesRegex = /^-+|-+$/g;
  function findSectionHeaders(model, options) {
    var _a4;
    let headers = [];
    if (options.findRegionSectionHeaders && ((_a4 = options.foldingRules) === null || _a4 === void 0 ? void 0 : _a4.markers)) {
      const regionHeaders = collectRegionHeaders(model, options);
      headers = headers.concat(regionHeaders);
    }
    if (options.findMarkSectionHeaders) {
      const markHeaders = collectMarkHeaders(model);
      headers = headers.concat(markHeaders);
    }
    return headers;
  }
  function collectRegionHeaders(model, options) {
    const regionHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      const match = lineContent.match(options.foldingRules.markers.start);
      if (match) {
        const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };
        if (range.endColumn > range.startColumn) {
          const sectionHeader = {
            range,
            ...getHeaderText(lineContent.substring(match[0].length)),
            shouldBeInComments: false
          };
          if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
            regionHeaders.push(sectionHeader);
          }
        }
      }
    }
    return regionHeaders;
  }
  function collectMarkHeaders(model) {
    const markHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);
    }
    return markHeaders;
  }
  function addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {
    markRegex.lastIndex = 0;
    const match = markRegex.exec(lineContent);
    if (match) {
      const column = match.indices[1][0] + 1;
      const endColumn = match.indices[1][1] + 1;
      const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn };
      if (range.endColumn > range.startColumn) {
        const sectionHeader = {
          range,
          ...getHeaderText(match[1]),
          shouldBeInComments: true
        };
        if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
          sectionHeaders.push(sectionHeader);
        }
      }
    }
  }
  function getHeaderText(text2) {
    text2 = text2.trim();
    const hasSeparatorLine = text2.startsWith("-");
    text2 = text2.replace(trimDashesRegex, "");
    return { text: text2, hasSeparatorLine };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
  var MirrorModel = class extends MirrorTextModel {
    get uri() {
      return this._uri;
    }
    get eol() {
      return this._eol;
    }
    getValue() {
      return this.getText();
    }
    findMatches(regex) {
      const matches = [];
      for (let i2 = 0; i2 < this._lines.length; i2++) {
        const line = this._lines[i2];
        const offsetToAdd = this.offsetAt(new Position2(i2 + 1, 1));
        const iteratorOverMatches = line.matchAll(regex);
        for (const match of iteratorOverMatches) {
          if (match.index || match.index === 0) {
            match.index = match.index + offsetToAdd;
          }
          matches.push(match);
        }
      }
      return matches;
    }
    getLinesContent() {
      return this._lines.slice(0);
    }
    getLineCount() {
      return this._lines.length;
    }
    getLineContent(lineNumber) {
      return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position2, wordDefinition) {
      const wordAtText = getWordAtText(position2.column, ensureValidWordDefinition(wordDefinition), this._lines[position2.lineNumber - 1], 0);
      if (wordAtText) {
        return new Range2(position2.lineNumber, wordAtText.startColumn, position2.lineNumber, wordAtText.endColumn);
      }
      return null;
    }
    words(wordDefinition) {
      const lines = this._lines;
      const wordenize = this._wordenize.bind(this);
      let lineNumber = 0;
      let lineText = "";
      let wordRangesIdx = 0;
      let wordRanges = [];
      return {
        *[Symbol.iterator]() {
          while (true) {
            if (wordRangesIdx < wordRanges.length) {
              const value2 = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
              wordRangesIdx += 1;
              yield value2;
            } else {
              if (lineNumber < lines.length) {
                lineText = lines[lineNumber];
                wordRanges = wordenize(lineText, wordDefinition);
                wordRangesIdx = 0;
                lineNumber += 1;
              } else {
                break;
              }
            }
          }
        }
      };
    }
    getLineWords(lineNumber, wordDefinition) {
      const content = this._lines[lineNumber - 1];
      const ranges = this._wordenize(content, wordDefinition);
      const words = [];
      for (const range of ranges) {
        words.push({
          word: content.substring(range.start, range.end),
          startColumn: range.start + 1,
          endColumn: range.end + 1
        });
      }
      return words;
    }
    _wordenize(content, wordDefinition) {
      const result = [];
      let match;
      wordDefinition.lastIndex = 0;
      while (match = wordDefinition.exec(content)) {
        if (match[0].length === 0) {
          break;
        }
        result.push({ start: match.index, end: match.index + match[0].length });
      }
      return result;
    }
    getValueInRange(range) {
      range = this._validateRange(range);
      if (range.startLineNumber === range.endLineNumber) {
        return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
      }
      const lineEnding = this._eol;
      const startLineIndex = range.startLineNumber - 1;
      const endLineIndex = range.endLineNumber - 1;
      const resultLines = [];
      resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
      for (let i2 = startLineIndex + 1; i2 < endLineIndex; i2++) {
        resultLines.push(this._lines[i2]);
      }
      resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
      return resultLines.join(lineEnding);
    }
    offsetAt(position2) {
      position2 = this._validatePosition(position2);
      this._ensureLineStarts();
      return this._lineStarts.getPrefixSum(position2.lineNumber - 2) + (position2.column - 1);
    }
    positionAt(offset) {
      offset = Math.floor(offset);
      offset = Math.max(0, offset);
      this._ensureLineStarts();
      const out = this._lineStarts.getIndexOf(offset);
      const lineLength = this._lines[out.index].length;
      return {
        lineNumber: 1 + out.index,
        column: 1 + Math.min(out.remainder, lineLength)
      };
    }
    _validateRange(range) {
      const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
      const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
      if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
        return {
          startLineNumber: start.lineNumber,
          startColumn: start.column,
          endLineNumber: end.lineNumber,
          endColumn: end.column
        };
      }
      return range;
    }
    _validatePosition(position2) {
      if (!Position2.isIPosition(position2)) {
        throw new Error("bad position");
      }
      let { lineNumber, column } = position2;
      let hasChanged = false;
      if (lineNumber < 1) {
        lineNumber = 1;
        column = 1;
        hasChanged = true;
      } else if (lineNumber > this._lines.length) {
        lineNumber = this._lines.length;
        column = this._lines[lineNumber - 1].length + 1;
        hasChanged = true;
      } else {
        const maxCharacter = this._lines[lineNumber - 1].length + 1;
        if (column < 1) {
          column = 1;
          hasChanged = true;
        } else if (column > maxCharacter) {
          column = maxCharacter;
          hasChanged = true;
        }
      }
      if (!hasChanged) {
        return position2;
      } else {
        return { lineNumber, column };
      }
    }
  };
  var EditorSimpleWorker = class _EditorSimpleWorker {
    constructor(host, foreignModuleFactory) {
      this._host = host;
      this._models = /* @__PURE__ */ Object.create(null);
      this._foreignModuleFactory = foreignModuleFactory;
      this._foreignModule = null;
    }
    dispose() {
      this._models = /* @__PURE__ */ Object.create(null);
    }
    _getModel(uri) {
      return this._models[uri];
    }
    _getModels() {
      const all = [];
      Object.keys(this._models).forEach((key) => all.push(this._models[key]));
      return all;
    }
    acceptNewModel(data) {
      this._models[data.url] = new MirrorModel(URI2.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    acceptModelChanged(strURL, e5) {
      if (!this._models[strURL]) {
        return;
      }
      const model = this._models[strURL];
      model.onEvents(e5);
    }
    acceptRemovedModel(strURL) {
      if (!this._models[strURL]) {
        return;
      }
      delete this._models[strURL];
    }
    async computeUnicodeHighlights(url2, options, range) {
      const model = this._getModel(url2);
      if (!model) {
        return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
      }
      return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
    }
    async findSectionHeaders(url2, options) {
      const model = this._getModel(url2);
      if (!model) {
        return [];
      }
      return findSectionHeaders(model, options);
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {
      const original = this._getModel(originalUrl);
      const modified = this._getModel(modifiedUrl);
      if (!original || !modified) {
        return null;
      }
      const result = _EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
      return result;
    }
    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
      const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
      const originalLines = originalTextModel.getLinesContent();
      const modifiedLines = modifiedTextModel.getLinesContent();
      const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
      const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
      function getLineChanges(changes) {
        return changes.map((m2) => {
          var _a4;
          return [m2.original.startLineNumber, m2.original.endLineNumberExclusive, m2.modified.startLineNumber, m2.modified.endLineNumberExclusive, (_a4 = m2.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((m3) => [
            m3.originalRange.startLineNumber,
            m3.originalRange.startColumn,
            m3.originalRange.endLineNumber,
            m3.originalRange.endColumn,
            m3.modifiedRange.startLineNumber,
            m3.modifiedRange.startColumn,
            m3.modifiedRange.endLineNumber,
            m3.modifiedRange.endColumn
          ])];
        });
      }
      return {
        identical,
        quitEarly: result.hitTimeout,
        changes: getLineChanges(result.changes),
        moves: result.moves.map((m2) => [
          m2.lineRangeMapping.original.startLineNumber,
          m2.lineRangeMapping.original.endLineNumberExclusive,
          m2.lineRangeMapping.modified.startLineNumber,
          m2.lineRangeMapping.modified.endLineNumberExclusive,
          getLineChanges(m2.changes)
        ])
      };
    }
    static _modelsAreIdentical(original, modified) {
      const originalLineCount = original.getLineCount();
      const modifiedLineCount = modified.getLineCount();
      if (originalLineCount !== modifiedLineCount) {
        return false;
      }
      for (let line = 1; line <= originalLineCount; line++) {
        const originalLine = original.getLineContent(line);
        const modifiedLine = modified.getLineContent(line);
        if (originalLine !== modifiedLine) {
          return false;
        }
      }
      return true;
    }
    async computeMoreMinimalEdits(modelUrl, edits, pretty) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return edits;
      }
      const result = [];
      let lastEol = void 0;
      edits = edits.slice(0).sort((a2, b2) => {
        if (a2.range && b2.range) {
          return Range2.compareRangesUsingStarts(a2.range, b2.range);
        }
        const aRng = a2.range ? 0 : 1;
        const bRng = b2.range ? 0 : 1;
        return aRng - bRng;
      });
      let writeIndex = 0;
      for (let readIndex = 1; readIndex < edits.length; readIndex++) {
        if (Range2.getEndPosition(edits[writeIndex].range).equals(Range2.getStartPosition(edits[readIndex].range))) {
          edits[writeIndex].range = Range2.fromPositions(Range2.getStartPosition(edits[writeIndex].range), Range2.getEndPosition(edits[readIndex].range));
          edits[writeIndex].text += edits[readIndex].text;
        } else {
          writeIndex++;
          edits[writeIndex] = edits[readIndex];
        }
      }
      edits.length = writeIndex + 1;
      for (let { range, text: text2, eol } of edits) {
        if (typeof eol === "number") {
          lastEol = eol;
        }
        if (Range2.isEmpty(range) && !text2) {
          continue;
        }
        const original = model.getValueInRange(range);
        text2 = text2.replace(/\r\n|\n|\r/g, model.eol);
        if (original === text2) {
          continue;
        }
        if (Math.max(text2.length, original.length) > _EditorSimpleWorker._diffLimit) {
          result.push({ range, text: text2 });
          continue;
        }
        const changes = stringDiff(original, text2, pretty);
        const editOffset = model.offsetAt(Range2.lift(range).getStartPosition());
        for (const change of changes) {
          const start = model.positionAt(editOffset + change.originalStart);
          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
          const newEdit = {
            text: text2.substr(change.modifiedStart, change.modifiedLength),
            range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
          };
          if (model.getValueInRange(newEdit.range) !== newEdit.text) {
            result.push(newEdit);
          }
        }
      }
      if (typeof lastEol === "number") {
        result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
      }
      return result;
    }
    // ---- END minimal edits ---------------------------------------------------------------
    async computeLinks(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeLinks(model);
    }
    // --- BEGIN default document colors -----------------------------------------------------------
    async computeDefaultDocumentColors(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeDefaultDocumentColors(model);
    }
    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
      const sw = new StopWatch();
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const seen = /* @__PURE__ */ new Set();
      outer: for (const url2 of modelUrls) {
        const model = this._getModel(url2);
        if (!model) {
          continue;
        }
        for (const word of model.words(wordDefRegExp)) {
          if (word === leadingWord || !isNaN(Number(word))) {
            continue;
          }
          seen.add(word);
          if (seen.size > _EditorSimpleWorker._suggestionsLimit) {
            break outer;
          }
        }
      }
      return { words: Array.from(seen), duration: sw.elapsed() };
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return /* @__PURE__ */ Object.create(null);
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const result = /* @__PURE__ */ Object.create(null);
      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
        const words = model.getLineWords(line, wordDefRegExp);
        for (const word of words) {
          if (!isNaN(Number(word.word))) {
            continue;
          }
          let array = result[word.word];
          if (!array) {
            array = [];
            result[word.word] = array;
          }
          array.push({
            startLineNumber: line,
            startColumn: word.startColumn,
            endLineNumber: line,
            endColumn: word.endColumn
          });
        }
      }
      return result;
    }
    //#endregion
    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      if (range.startColumn === range.endColumn) {
        range = {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn + 1
        };
      }
      const selectionText = model.getValueInRange(range);
      const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
      if (!wordRange) {
        return null;
      }
      const word = model.getValueInRange(wordRange);
      const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
      return result;
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    loadForeignModule(moduleId, createData, foreignHostMethods) {
      const proxyMethodRequest = (method, args) => {
        return this._host.fhr(method, args);
      };
      const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
      const ctx = {
        host: foreignHost,
        getMirrorModels: () => {
          return this._getModels();
        }
      };
      if (this._foreignModuleFactory) {
        this._foreignModule = this._foreignModuleFactory(ctx, createData);
        return Promise.resolve(getAllMethodNames(this._foreignModule));
      }
      return Promise.reject(new Error(`Unexpected usage`));
    }
    // foreign method request
    fmr(method, args) {
      if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
      } catch (e5) {
        return Promise.reject(e5);
      }
    }
  };
  EditorSimpleWorker._diffLimit = 1e5;
  EditorSimpleWorker._suggestionsLimit = 1e4;
  if (typeof importScripts === "function") {
    globalThis.monaco = createMonacoBaseAPI();
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js
  var initialized = false;
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      globalThis.postMessage(msg);
    }, (host) => new EditorSimpleWorker(host, foreignModule));
    globalThis.onmessage = (e5) => {
      simpleWorker.onmessage(e5.data);
    };
  }
  globalThis.onmessage = (e5) => {
    if (!initialized) {
      initialize(null);
    }
  };

  // node_modules/.pnpm/monaco-worker-manager@2.0.1_monaco-editor@0.49.0/node_modules/monaco-worker-manager/worker.js
  function initialize2(fn5) {
    self.onmessage = () => {
      initialize((ctx, createData) => Object.create(fn5(ctx, createData)));
    };
  }

  // node_modules/.pnpm/monaco-tailwindcss@0.6.1_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_postcss_selector_parser2 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser3 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser4 = __toESM(require_dist(), 1);
  var import_postcss_nested = __toESM(require_postcss_nested(), 1);

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.47/node_modules/postcss-js/index.mjs
  var import_index = __toESM(require_postcss_js(), 1);
  var postcss_js_default = import_index.default;
  var objectify = import_index.default.objectify;
  var parse4 = import_index.default.parse;
  var async = import_index.default.async;
  var sync = import_index.default.sync;

  // node_modules/.pnpm/monaco-tailwindcss@0.6.1_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_postcss_selector_parser5 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser6 = __toESM(require_dist(), 1);
  var import_unesc = __toESM(require_unesc(), 1);
  var import_postcss_selector_parser7 = __toESM(require_dist(), 1);
  var import_dlv12 = __toESM(require_dlv_umd(), 1);
  var import_postcss_selector_parser8 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser9 = __toESM(require_dist(), 1);
  var import_quick_lru = __toESM(require_quick_lru(), 1);
  var import_dlv13 = __toESM(require_dlv_umd(), 1);
  var import_didyoumean = __toESM(require_didYouMean_1_2_1(), 1);
  var import_postcss_selector_parser10 = __toESM(require_dist(), 1);

  // node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
  var FullTextDocument2 = class _FullTextDocument {
    constructor(uri, languageId, version2, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version2;
      this._content = content;
      this._lineOffsets = void 0;
    }
    get uri() {
      return this._uri;
    }
    get languageId() {
      return this._languageId;
    }
    get version() {
      return this._version;
    }
    getText(range) {
      if (range) {
        const start = this.offsetAt(range.start);
        const end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    }
    update(changes, version2) {
      for (const change of changes) {
        if (_FullTextDocument.isIncremental(change)) {
          const range = getWellformedRange(change.range);
          const startOffset = this.offsetAt(range.start);
          const endOffset = this.offsetAt(range.end);
          this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
          const startLine = Math.max(range.start.line, 0);
          const endLine = Math.max(range.end.line, 0);
          let lineOffsets = this._lineOffsets;
          const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
          if (endLine - startLine === addedLineOffsets.length) {
            for (let i2 = 0, len = addedLineOffsets.length; i2 < len; i2++) {
              lineOffsets[i2 + startLine + 1] = addedLineOffsets[i2];
            }
          } else {
            if (addedLineOffsets.length < 1e4) {
              lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
            } else {
              this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
            }
          }
          const diff = change.text.length - (endOffset - startOffset);
          if (diff !== 0) {
            for (let i2 = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i2 < len; i2++) {
              lineOffsets[i2] = lineOffsets[i2] + diff;
            }
          }
        } else if (_FullTextDocument.isFull(change)) {
          this._content = change.text;
          this._lineOffsets = void 0;
        } else {
          throw new Error("Unknown change event received");
        }
      }
      this._version = version2;
    }
    getLineOffsets() {
      if (this._lineOffsets === void 0) {
        this._lineOffsets = computeLineOffsets(this._content, true);
      }
      return this._lineOffsets;
    }
    positionAt(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      const lineOffsets = this.getLineOffsets();
      let low = 0, high = lineOffsets.length;
      if (high === 0) {
        return { line: 0, character: offset };
      }
      while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      const line = low - 1;
      offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
      return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position2) {
      const lineOffsets = this.getLineOffsets();
      if (position2.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position2.line < 0) {
        return 0;
      }
      const lineOffset = lineOffsets[position2.line];
      if (position2.character <= 0) {
        return lineOffset;
      }
      const nextLineOffset = position2.line + 1 < lineOffsets.length ? lineOffsets[position2.line + 1] : this._content.length;
      const offset = Math.min(lineOffset + position2.character, nextLineOffset);
      return this.ensureBeforeEOL(offset, lineOffset);
    }
    ensureBeforeEOL(offset, lineOffset) {
      while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
        offset--;
      }
      return offset;
    }
    get lineCount() {
      return this.getLineOffsets().length;
    }
    static isIncremental(event) {
      const candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
    }
    static isFull(event) {
      const candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
    }
  };
  var TextDocument2;
  (function(TextDocument3) {
    function create(uri, languageId, version2, content) {
      return new FullTextDocument2(uri, languageId, version2, content);
    }
    TextDocument3.create = create;
    function update(document3, changes, version2) {
      if (document3 instanceof FullTextDocument2) {
        document3.update(changes, version2);
        return document3;
      } else {
        throw new Error("TextDocument.update: document must be created by TextDocument.create");
      }
    }
    TextDocument3.update = update;
    function applyEdits(document3, edits) {
      const text2 = document3.getText();
      const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a2, b2) => {
        const diff = a2.range.start.line - b2.range.start.line;
        if (diff === 0) {
          return a2.range.start.character - b2.range.start.character;
        }
        return diff;
      });
      let lastModifiedOffset = 0;
      const spans = [];
      for (const e5 of sortedEdits) {
        const startOffset = document3.offsetAt(e5.range.start);
        if (startOffset < lastModifiedOffset) {
          throw new Error("Overlapping edit");
        } else if (startOffset > lastModifiedOffset) {
          spans.push(text2.substring(lastModifiedOffset, startOffset));
        }
        if (e5.newText.length) {
          spans.push(e5.newText);
        }
        lastModifiedOffset = document3.offsetAt(e5.range.end);
      }
      spans.push(text2.substr(lastModifiedOffset));
      return spans.join("");
    }
    TextDocument3.applyEdits = applyEdits;
  })(TextDocument2 || (TextDocument2 = {}));
  function mergeSort(data, compare) {
    if (data.length <= 1) {
      return data;
    }
    const p4 = data.length / 2 | 0;
    const left = data.slice(0, p4);
    const right = data.slice(p4);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i2 = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      const ret = compare(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i2++] = left[leftIdx++];
      } else {
        data[i2++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i2++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i2++] = right[rightIdx++];
    }
    return data;
  }
  function computeLineOffsets(text2, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i2 = 0; i2 < text2.length; i2++) {
      const ch = text2.charCodeAt(i2);
      if (isEOL(ch)) {
        if (ch === 13 && i2 + 1 < text2.length && text2.charCodeAt(i2 + 1) === 10) {
          i2++;
        }
        result.push(textOffset + i2 + 1);
      }
    }
    return result;
  }
  function isEOL(char) {
    return char === 13 || char === 10;
  }
  function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || start.line === end.line && start.character > end.character) {
      return { start: end, end: start };
    }
    return range;
  }
  function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
      return { newText: textEdit.newText, range };
    }
    return textEdit;
  }

  // node_modules/.pnpm/monaco-tailwindcss@0.6.1_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __commonJS2 = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps2 = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var require_parse2 = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/parse.js"(exports, module) {
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;
      module.exports = function(input) {
        var tokens = [];
        var value2 = input;
        var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
        var pos = 0;
        var code = value2.charCodeAt(pos);
        var max2 = value2.length;
        var stack = [{ nodes: tokens }];
        var balanced = 0;
        var parent;
        var name = "";
        var before = "";
        var after = "";
        while (pos < max2) {
          if (code <= 32) {
            next = pos;
            do {
              next += 1;
              code = value2.charCodeAt(next);
            } while (code <= 32);
            token = value2.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
              after = token;
            } else if (prev && prev.type === "div") {
              prev.after = token;
              prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && false)) {
              before = token;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            }
            pos = next;
          } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
              type: "string",
              sourceIndex: pos,
              quote
            };
            do {
              escape2 = false;
              next = value2.indexOf(quote, next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += quote;
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            token.value = value2.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value2.charCodeAt(pos);
          } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
            next = value2.indexOf("*/", pos);
            token = {
              type: "comment",
              sourceIndex: pos,
              sourceEndIndex: next + 2
            };
            if (next === -1) {
              token.unclosed = true;
              next = value2.length;
              token.sourceEndIndex = next;
            }
            token.value = value2.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code = value2.charCodeAt(pos);
          } else if ((code === slash || code === star) && parent && parent.type === "function" && true) {
            token = value2[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token
            });
            pos += 1;
            code = value2.charCodeAt(pos);
          } else if (code === slash || code === comma || code === colon) {
            token = value2[pos];
            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token,
              before,
              after: ""
            });
            before = "";
            pos += 1;
            code = value2.charCodeAt(pos);
          } else if (openParentheses === code) {
            next = pos;
            do {
              next += 1;
              code = value2.charCodeAt(next);
            } while (code <= 32);
            parenthesesOpenPos = pos;
            token = {
              type: "function",
              sourceIndex: pos - name.length,
              value: name,
              before: value2.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
              next -= 1;
              do {
                escape2 = false;
                next = value2.indexOf(")", next + 1);
                if (~next) {
                  escapePos = next;
                  while (value2.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape2 = !escape2;
                  }
                } else {
                  value2 += ")";
                  next = value2.length - 1;
                  token.unclosed = true;
                }
              } while (escape2);
              whitespacePos = next;
              do {
                whitespacePos -= 1;
                code = value2.charCodeAt(whitespacePos);
              } while (code <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token.nodes = [
                    {
                      type: "word",
                      sourceIndex: pos,
                      sourceEndIndex: whitespacePos + 1,
                      value: value2.slice(pos, whitespacePos + 1)
                    }
                  ];
                } else {
                  token.nodes = [];
                }
                if (token.unclosed && whitespacePos + 1 !== next) {
                  token.after = "";
                  token.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    sourceEndIndex: next,
                    value: value2.slice(whitespacePos + 1, next)
                  });
                } else {
                  token.after = value2.slice(whitespacePos + 1, next);
                  token.sourceEndIndex = next;
                }
              } else {
                token.after = "";
                token.nodes = [];
              }
              pos = next + 1;
              token.sourceEndIndex = token.unclosed ? next : pos;
              code = value2.charCodeAt(pos);
              tokens.push(token);
            } else {
              balanced += 1;
              token.after = "";
              token.sourceEndIndex = pos + 1;
              tokens.push(token);
              stack.push(token);
              tokens = token.nodes = [];
              parent = token;
            }
            name = "";
          } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value2.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
          } else {
            next = pos;
            do {
              if (code === backslash) {
                next += 1;
              }
              next += 1;
              code = value2.charCodeAt(next);
            } while (next < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && true || code === slash && parent.type === "function" && true || code === closeParentheses && balanced));
            token = value2.slice(pos, next);
            if (openParentheses === code) {
              name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            }
            pos = next;
          }
        }
        for (pos = stack.length - 1; pos; pos -= 1) {
          stack[pos].unclosed = true;
          stack[pos].sourceEndIndex = value2.length;
        }
        return stack[0].nodes;
      };
    }
  });
  var require_walk = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/walk.js"(exports, module) {
      module.exports = function walk(nodes, cb, bubble) {
        var i2, max2, node, result;
        for (i2 = 0, max2 = nodes.length; i2 < max2; i2 += 1) {
          node = nodes[i2];
          if (!bubble) {
            result = cb(node, i2, nodes);
          }
          if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
          }
          if (bubble) {
            cb(node, i2, nodes);
          }
        }
      };
    }
  });
  var require_stringify2 = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/stringify.js"(exports, module) {
      function stringifyNode(node, custom) {
        var type = node.type;
        var value2 = node.value;
        var buf;
        var customResult;
        if (custom && (customResult = custom(node)) !== void 0) {
          return customResult;
        } else if (type === "word" || type === "space") {
          return value2;
        } else if (type === "string") {
          buf = node.quote || "";
          return buf + value2 + (node.unclosed ? "" : buf);
        } else if (type === "comment") {
          return "/*" + value2 + (node.unclosed ? "" : "*/");
        } else if (type === "div") {
          return (node.before || "") + value2 + (node.after || "");
        } else if (Array.isArray(node.nodes)) {
          buf = stringify3(node.nodes, custom);
          if (type !== "function") {
            return buf;
          }
          return value2 + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
        }
        return value2;
      }
      function stringify3(nodes, custom) {
        var result, i2;
        if (Array.isArray(nodes)) {
          result = "";
          for (i2 = nodes.length - 1; ~i2; i2 -= 1) {
            result = stringifyNode(nodes[i2], custom) + result;
          }
          return result;
        }
        return stringifyNode(nodes, custom);
      }
      module.exports = stringify3;
    }
  });
  var require_unit = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/unit.js"(exports, module) {
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);
      function likeNumber(value2) {
        var code = value2.charCodeAt(0);
        var nextCode;
        if (code === plus || code === minus) {
          nextCode = value2.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          var nextNextCode = value2.charCodeAt(2);
          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code === dot) {
          nextCode = value2.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code >= 48 && code <= 57) {
          return true;
        }
        return false;
      }
      module.exports = function(value2) {
        var pos = 0;
        var length2 = value2.length;
        var code;
        var nextCode;
        var nextNextCode;
        if (length2 === 0 || !likeNumber(value2)) {
          return false;
        }
        code = value2.charCodeAt(pos);
        if (code === plus || code === minus) {
          pos++;
        }
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
        code = value2.charCodeAt(pos);
        nextCode = value2.charCodeAt(pos + 1);
        if (code === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;
          while (pos < length2) {
            code = value2.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        code = value2.charCodeAt(pos);
        nextCode = value2.charCodeAt(pos + 1);
        nextNextCode = value2.charCodeAt(pos + 2);
        if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;
          while (pos < length2) {
            code = value2.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        return {
          number: value2.slice(0, pos),
          unit: value2.slice(pos)
        };
      };
    }
  });
  var require_value_parser = __commonJS2({
    "node_modules/tailwindcss/src/value-parser/index.js"(exports, module) {
      var parse32 = require_parse2();
      var walk = require_walk();
      var stringify3 = require_stringify2();
      function ValueParser(value2) {
        if (this instanceof ValueParser) {
          this.nodes = parse32(value2);
          return this;
        }
        return new ValueParser(value2);
      }
      ValueParser.prototype.toString = function() {
        return Array.isArray(this.nodes) ? stringify3(this.nodes) : "";
      };
      ValueParser.prototype.walk = function(cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };
      ValueParser.unit = require_unit();
      ValueParser.walk = walk;
      ValueParser.stringify = stringify3;
      module.exports = ValueParser;
    }
  });
  var require_config_full = __commonJS2({
    "node_modules/tailwindcss/stubs/config.full.js"(exports, module) {
      module.exports = {
        content: [],
        presets: [],
        darkMode: "media",
        // or 'class'
        theme: {
          accentColor: ({ theme }) => ({
            ...theme("colors"),
            auto: "auto"
          }),
          animation: {
            none: "none",
            spin: "spin 1s linear infinite",
            ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
            pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
            bounce: "bounce 1s infinite"
          },
          aria: {
            busy: 'busy="true"',
            checked: 'checked="true"',
            disabled: 'disabled="true"',
            expanded: 'expanded="true"',
            hidden: 'hidden="true"',
            pressed: 'pressed="true"',
            readonly: 'readonly="true"',
            required: 'required="true"',
            selected: 'selected="true"'
          },
          aspectRatio: {
            auto: "auto",
            square: "1 / 1",
            video: "16 / 9"
          },
          backdropBlur: ({ theme }) => theme("blur"),
          backdropBrightness: ({ theme }) => theme("brightness"),
          backdropContrast: ({ theme }) => theme("contrast"),
          backdropGrayscale: ({ theme }) => theme("grayscale"),
          backdropHueRotate: ({ theme }) => theme("hueRotate"),
          backdropInvert: ({ theme }) => theme("invert"),
          backdropOpacity: ({ theme }) => theme("opacity"),
          backdropSaturate: ({ theme }) => theme("saturate"),
          backdropSepia: ({ theme }) => theme("sepia"),
          backgroundColor: ({ theme }) => theme("colors"),
          backgroundImage: {
            none: "none",
            "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
            "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
            "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
            "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
            "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
            "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
            "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
            "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
          },
          backgroundOpacity: ({ theme }) => theme("opacity"),
          backgroundPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
          },
          backgroundSize: {
            auto: "auto",
            cover: "cover",
            contain: "contain"
          },
          blur: {
            0: "0",
            none: "0",
            sm: "4px",
            DEFAULT: "8px",
            md: "12px",
            lg: "16px",
            xl: "24px",
            "2xl": "40px",
            "3xl": "64px"
          },
          borderColor: ({ theme }) => ({
            ...theme("colors"),
            DEFAULT: theme("colors.gray.200", "currentColor")
          }),
          borderOpacity: ({ theme }) => theme("opacity"),
          borderRadius: {
            none: "0px",
            sm: "0.125rem",
            DEFAULT: "0.25rem",
            md: "0.375rem",
            lg: "0.5rem",
            xl: "0.75rem",
            "2xl": "1rem",
            "3xl": "1.5rem",
            full: "9999px"
          },
          borderSpacing: ({ theme }) => ({
            ...theme("spacing")
          }),
          borderWidth: {
            DEFAULT: "1px",
            0: "0px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          boxShadow: {
            sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
            DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
            md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
            lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
            xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
            "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
            inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
            none: "none"
          },
          boxShadowColor: ({ theme }) => theme("colors"),
          brightness: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5",
            200: "2"
          },
          caretColor: ({ theme }) => theme("colors"),
          colors: ({ colors }) => ({
            inherit: colors.inherit,
            current: colors.current,
            transparent: colors.transparent,
            black: colors.black,
            white: colors.white,
            slate: colors.slate,
            gray: colors.gray,
            zinc: colors.zinc,
            neutral: colors.neutral,
            stone: colors.stone,
            red: colors.red,
            orange: colors.orange,
            amber: colors.amber,
            yellow: colors.yellow,
            lime: colors.lime,
            green: colors.green,
            emerald: colors.emerald,
            teal: colors.teal,
            cyan: colors.cyan,
            sky: colors.sky,
            blue: colors.blue,
            indigo: colors.indigo,
            violet: colors.violet,
            purple: colors.purple,
            fuchsia: colors.fuchsia,
            pink: colors.pink,
            rose: colors.rose
          }),
          columns: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            "3xs": "16rem",
            "2xs": "18rem",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem"
          },
          container: {},
          content: {
            none: "none"
          },
          contrast: {
            0: "0",
            50: ".5",
            75: ".75",
            100: "1",
            125: "1.25",
            150: "1.5",
            200: "2"
          },
          cursor: {
            auto: "auto",
            default: "default",
            pointer: "pointer",
            wait: "wait",
            text: "text",
            move: "move",
            help: "help",
            "not-allowed": "not-allowed",
            none: "none",
            "context-menu": "context-menu",
            progress: "progress",
            cell: "cell",
            crosshair: "crosshair",
            "vertical-text": "vertical-text",
            alias: "alias",
            copy: "copy",
            "no-drop": "no-drop",
            grab: "grab",
            grabbing: "grabbing",
            "all-scroll": "all-scroll",
            "col-resize": "col-resize",
            "row-resize": "row-resize",
            "n-resize": "n-resize",
            "e-resize": "e-resize",
            "s-resize": "s-resize",
            "w-resize": "w-resize",
            "ne-resize": "ne-resize",
            "nw-resize": "nw-resize",
            "se-resize": "se-resize",
            "sw-resize": "sw-resize",
            "ew-resize": "ew-resize",
            "ns-resize": "ns-resize",
            "nesw-resize": "nesw-resize",
            "nwse-resize": "nwse-resize",
            "zoom-in": "zoom-in",
            "zoom-out": "zoom-out"
          },
          divideColor: ({ theme }) => theme("borderColor"),
          divideOpacity: ({ theme }) => theme("borderOpacity"),
          divideWidth: ({ theme }) => theme("borderWidth"),
          dropShadow: {
            sm: "0 1px 1px rgb(0 0 0 / 0.05)",
            DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
            md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
            lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
            xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
            "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
            none: "0 0 #0000"
          },
          fill: ({ theme }) => ({
            none: "none",
            ...theme("colors")
          }),
          flex: {
            1: "1 1 0%",
            auto: "1 1 auto",
            initial: "0 1 auto",
            none: "none"
          },
          flexBasis: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%"
          }),
          flexGrow: {
            0: "0",
            DEFAULT: "1"
          },
          flexShrink: {
            0: "0",
            DEFAULT: "1"
          },
          fontFamily: {
            sans: [
              "ui-sans-serif",
              "system-ui",
              "-apple-system",
              "BlinkMacSystemFont",
              '"Segoe UI"',
              "Roboto",
              '"Helvetica Neue"',
              "Arial",
              '"Noto Sans"',
              "sans-serif",
              '"Apple Color Emoji"',
              '"Segoe UI Emoji"',
              '"Segoe UI Symbol"',
              '"Noto Color Emoji"'
            ],
            serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
            mono: [
              "ui-monospace",
              "SFMono-Regular",
              "Menlo",
              "Monaco",
              "Consolas",
              '"Liberation Mono"',
              '"Courier New"',
              "monospace"
            ]
          },
          fontSize: {
            xs: ["0.75rem", { lineHeight: "1rem" }],
            sm: ["0.875rem", { lineHeight: "1.25rem" }],
            base: ["1rem", { lineHeight: "1.5rem" }],
            lg: ["1.125rem", { lineHeight: "1.75rem" }],
            xl: ["1.25rem", { lineHeight: "1.75rem" }],
            "2xl": ["1.5rem", { lineHeight: "2rem" }],
            "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
            "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
            "5xl": ["3rem", { lineHeight: "1" }],
            "6xl": ["3.75rem", { lineHeight: "1" }],
            "7xl": ["4.5rem", { lineHeight: "1" }],
            "8xl": ["6rem", { lineHeight: "1" }],
            "9xl": ["8rem", { lineHeight: "1" }]
          },
          fontWeight: {
            thin: "100",
            extralight: "200",
            light: "300",
            normal: "400",
            medium: "500",
            semibold: "600",
            bold: "700",
            extrabold: "800",
            black: "900"
          },
          gap: ({ theme }) => theme("spacing"),
          gradientColorStops: ({ theme }) => theme("colors"),
          gradientColorStopPositions: {
            "0%": "0%",
            "5%": "5%",
            "10%": "10%",
            "15%": "15%",
            "20%": "20%",
            "25%": "25%",
            "30%": "30%",
            "35%": "35%",
            "40%": "40%",
            "45%": "45%",
            "50%": "50%",
            "55%": "55%",
            "60%": "60%",
            "65%": "65%",
            "70%": "70%",
            "75%": "75%",
            "80%": "80%",
            "85%": "85%",
            "90%": "90%",
            "95%": "95%",
            "100%": "100%"
          },
          grayscale: {
            0: "0",
            DEFAULT: "100%"
          },
          gridAutoColumns: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
          },
          gridAutoRows: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
          },
          gridColumn: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-7": "span 7 / span 7",
            "span-8": "span 8 / span 8",
            "span-9": "span 9 / span 9",
            "span-10": "span 10 / span 10",
            "span-11": "span 11 / span 11",
            "span-12": "span 12 / span 12",
            "span-full": "1 / -1"
          },
          gridColumnEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridColumnStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridRow: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-full": "1 / -1"
          },
          gridRowEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7"
          },
          gridRowStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7"
          },
          gridTemplateColumns: {
            none: "none",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))",
            7: "repeat(7, minmax(0, 1fr))",
            8: "repeat(8, minmax(0, 1fr))",
            9: "repeat(9, minmax(0, 1fr))",
            10: "repeat(10, minmax(0, 1fr))",
            11: "repeat(11, minmax(0, 1fr))",
            12: "repeat(12, minmax(0, 1fr))"
          },
          gridTemplateRows: {
            none: "none",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))"
          },
          height: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          hueRotate: {
            0: "0deg",
            15: "15deg",
            30: "30deg",
            60: "60deg",
            90: "90deg",
            180: "180deg"
          },
          inset: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          }),
          invert: {
            0: "0",
            DEFAULT: "100%"
          },
          keyframes: {
            spin: {
              to: {
                transform: "rotate(360deg)"
              }
            },
            ping: {
              "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
              }
            },
            pulse: {
              "50%": {
                opacity: ".5"
              }
            },
            bounce: {
              "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
              },
              "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
              }
            }
          },
          letterSpacing: {
            tighter: "-0.05em",
            tight: "-0.025em",
            normal: "0em",
            wide: "0.025em",
            wider: "0.05em",
            widest: "0.1em"
          },
          lineHeight: {
            none: "1",
            tight: "1.25",
            snug: "1.375",
            normal: "1.5",
            relaxed: "1.625",
            loose: "2",
            3: ".75rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem"
          },
          listStyleType: {
            none: "none",
            disc: "disc",
            decimal: "decimal"
          },
          listStyleImage: {
            none: "none"
          },
          margin: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing")
          }),
          lineClamp: {
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6"
          },
          maxHeight: ({ theme }) => ({
            ...theme("spacing"),
            none: "none",
            full: "100%",
            screen: "100vh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          maxWidth: ({ theme, breakpoints }) => ({
            none: "none",
            0: "0rem",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...breakpoints(theme("screens"))
          }),
          minHeight: {
            0: "0px",
            full: "100%",
            screen: "100vh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          },
          minWidth: {
            0: "0px",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          },
          objectPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
          },
          opacity: {
            0: "0",
            5: "0.05",
            10: "0.1",
            20: "0.2",
            25: "0.25",
            30: "0.3",
            40: "0.4",
            50: "0.5",
            60: "0.6",
            70: "0.7",
            75: "0.75",
            80: "0.8",
            90: "0.9",
            95: "0.95",
            100: "1"
          },
          order: {
            first: "-9999",
            last: "9999",
            none: "0",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12"
          },
          outlineColor: ({ theme }) => theme("colors"),
          outlineOffset: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          outlineWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          padding: ({ theme }) => theme("spacing"),
          placeholderColor: ({ theme }) => theme("colors"),
          placeholderOpacity: ({ theme }) => theme("opacity"),
          ringColor: ({ theme }) => ({
            DEFAULT: theme("colors.blue.500", "#3b82f6"),
            ...theme("colors")
          }),
          ringOffsetColor: ({ theme }) => theme("colors"),
          ringOffsetWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          ringOpacity: ({ theme }) => ({
            DEFAULT: "0.5",
            ...theme("opacity")
          }),
          ringWidth: {
            DEFAULT: "3px",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          rotate: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg",
            45: "45deg",
            90: "90deg",
            180: "180deg"
          },
          saturate: {
            0: "0",
            50: ".5",
            100: "1",
            150: "1.5",
            200: "2"
          },
          scale: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5"
          },
          screens: {
            sm: "640px",
            md: "768px",
            lg: "1024px",
            xl: "1280px",
            "2xl": "1536px"
          },
          scrollMargin: ({ theme }) => ({
            ...theme("spacing")
          }),
          scrollPadding: ({ theme }) => theme("spacing"),
          sepia: {
            0: "0",
            DEFAULT: "100%"
          },
          skew: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg"
          },
          space: ({ theme }) => ({
            ...theme("spacing")
          }),
          spacing: {
            px: "1px",
            0: "0px",
            0.5: "0.125rem",
            1: "0.25rem",
            1.5: "0.375rem",
            2: "0.5rem",
            2.5: "0.625rem",
            3: "0.75rem",
            3.5: "0.875rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem",
            11: "2.75rem",
            12: "3rem",
            14: "3.5rem",
            16: "4rem",
            20: "5rem",
            24: "6rem",
            28: "7rem",
            32: "8rem",
            36: "9rem",
            40: "10rem",
            44: "11rem",
            48: "12rem",
            52: "13rem",
            56: "14rem",
            60: "15rem",
            64: "16rem",
            72: "18rem",
            80: "20rem",
            96: "24rem"
          },
          stroke: ({ theme }) => ({
            none: "none",
            ...theme("colors")
          }),
          strokeWidth: {
            0: "0",
            1: "1",
            2: "2"
          },
          supports: {},
          data: {},
          textColor: ({ theme }) => theme("colors"),
          textDecorationColor: ({ theme }) => theme("colors"),
          textDecorationThickness: {
            auto: "auto",
            "from-font": "from-font",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          textIndent: ({ theme }) => ({
            ...theme("spacing")
          }),
          textOpacity: ({ theme }) => theme("opacity"),
          textUnderlineOffset: {
            auto: "auto",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          transformOrigin: {
            center: "center",
            top: "top",
            "top-right": "top right",
            right: "right",
            "bottom-right": "bottom right",
            bottom: "bottom",
            "bottom-left": "bottom left",
            left: "left",
            "top-left": "top left"
          },
          transitionDelay: {
            0: "0s",
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
          },
          transitionDuration: {
            DEFAULT: "150ms",
            0: "0s",
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
          },
          transitionProperty: {
            none: "none",
            all: "all",
            DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
            colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
            opacity: "opacity",
            shadow: "box-shadow",
            transform: "transform"
          },
          transitionTimingFunction: {
            DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
            linear: "linear",
            in: "cubic-bezier(0.4, 0, 1, 1)",
            out: "cubic-bezier(0, 0, 0.2, 1)",
            "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
          },
          translate: ({ theme }) => ({
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          }),
          width: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          willChange: {
            auto: "auto",
            scroll: "scroll-position",
            contents: "contents",
            transform: "transform"
          },
          zIndex: {
            auto: "auto",
            0: "0",
            10: "10",
            20: "20",
            30: "30",
            40: "40",
            50: "50"
          }
        },
        plugins: []
      };
    }
  });
  var import_postcss_value_parser = __toESM2(require_value_parser());
  var import_postcss_value_parser2 = __toESM2(require_value_parser());
  var doComplete = null;
  var extractAbbreviation = null;
  var isAbbreviationValid = null;
  var detect_indent_default = null;
  function dset(obj, keys, val) {
    keys.split && (keys = keys.split("."));
    var i2 = 0, l2 = keys.length, t2 = obj, x2, k5;
    while (i2 < l2) {
      k5 = keys[i2++];
      if (k5 === "__proto__" || k5 === "constructor" || k5 === "prototype") break;
      t2 = t2[k5] = i2 === l2 ? val : typeof (x2 = t2[k5]) === typeof keys ? x2 : keys[i2] * 0 !== 0 || !!~("" + keys[i2]).indexOf(".") ? {} : [];
    }
  }
  function isObject3(variable) {
    return Object.prototype.toString.call(variable) === "[object Object]";
  }
  function removeMeta(obj) {
    let result = {};
    for (let key in obj) {
      if (key.substr(0, 2) === "__")
        continue;
      if (isObject3(obj[key])) {
        result[key] = removeMeta(obj[key]);
      } else {
        result[key] = obj[key];
      }
    }
    return result;
  }
  function rangesEqual(a2, b2) {
    return a2.start.line === b2.start.line && a2.start.character === b2.start.character && a2.end.line === b2.end.line && a2.end.character === b2.end.character;
  }
  function dedupe(arr) {
    return arr.filter((value2, index2, self2) => self2.indexOf(value2) === index2);
  }
  function dedupeBy(arr, transform) {
    return arr.filter((value2, index2, self2) => self2.map(transform).indexOf(transform(value2)) === index2);
  }
  function dedupeByRange(arr) {
    return arr.filter(
      (classList, classListIndex) => classListIndex === arr.findIndex((c3) => rangesEqual(c3.range, classList.range))
    );
  }
  function ensureArray(value2) {
    return Array.isArray(value2) ? value2 : [value2];
  }
  function flatten(arrays) {
    return [].concat.apply([], arrays);
  }
  function equal(a2, b2) {
    if (a2 === b2)
      return true;
    if (a2.length !== b2.length)
      return false;
    let aSorted = a2.concat().sort();
    let bSorted = b2.concat().sort();
    for (let i2 = 0; i2 < aSorted.length; ++i2) {
      if (aSorted[i2] !== bSorted[i2])
        return false;
    }
    return true;
  }
  function equalExact(a2, b2) {
    if (a2 === b2)
      return true;
    if (a2.length !== b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; ++i2) {
      if (a2[i2] !== b2[i2])
        return false;
    }
    return true;
  }
  function combinations(str) {
    let fn5 = function(active, rest, a2) {
      if (!active && !rest)
        return void 0;
      if (!rest) {
        a2.push(active);
      } else {
        fn5(active + rest[0], rest.slice(1), a2);
        fn5(active, rest.slice(1), a2);
      }
      return a2;
    };
    return fn5("", str, []);
  }
  function getClassNameParts(state, className) {
    let separator = state.separator;
    className = className.replace(/^\./, "");
    let parts = className.split(separator);
    if (parts.length === 1) {
      return (0, import_dlv3.default)(state.classNames.classNames, [className, "__info", "__rule"]) === true || Array.isArray((0, import_dlv3.default)(state.classNames.classNames, [className, "__info"])) ? [className] : null;
    }
    let points = combinations("123456789".substr(0, parts.length - 1)).map(
      (x2) => x2.split("").map((x22) => parseInt(x22, 10))
    );
    let possibilities = [
      [className],
      ...points.map((p4) => {
        let result = [];
        let i2 = 0;
        p4.forEach((x2) => {
          result.push(parts.slice(i2, x2).join("-"));
          i2 = x2;
        });
        result.push(parts.slice(i2).join("-"));
        return result;
      })
    ];
    return possibilities.find((key) => {
      if ((0, import_dlv3.default)(state.classNames.classNames, [...key, "__info", "__rule"]) === true || Array.isArray((0, import_dlv3.default)(state.classNames.classNames, [...key, "__info"]))) {
        return true;
      }
      return false;
    });
  }
  function applyComments(str, comments) {
    let offset = 0;
    for (let comment2 of comments) {
      let index2 = comment2.index + offset;
      let commentStr = ` /* ${comment2.value} */`;
      str = str.slice(0, index2) + commentStr + str.slice(index2);
      offset += commentStr.length;
    }
    return str;
  }
  function addPixelEquivalentsToValue(value2, rootFontSize) {
    if (!value2.includes("rem")) {
      return value2;
    }
    (0, import_postcss_value_parser.default)(value2).walk((node) => {
      if (node.type !== "word") {
        return true;
      }
      let unit = import_postcss_value_parser.default.unit(node.value);
      if (!unit || unit.unit !== "rem") {
        return false;
      }
      let commentStr = ` /* ${parseFloat(unit.number) * rootFontSize}px */`;
      value2 = value2.slice(0, node.sourceEndIndex) + commentStr + value2.slice(node.sourceEndIndex);
      return false;
    });
    return value2;
  }
  function getPixelEquivalentsForMediaQuery(params, rootFontSize) {
    let comments = [];
    try {
      parse(params).forEach((mediaQuery) => {
        mediaQuery.walk(({ node }) => {
          if (isTokenNode(node) && node.type === "token" && node.value[0] === "dimension-token" && (node.value[4].type === "integer" || node.value[4].type === "number") && (node.value[4].unit === "rem" || node.value[4].unit === "em")) {
            comments.push({
              index: params.length - (params.length - node.value[3] - 1),
              value: `${node.value[4].value * rootFontSize}px`
            });
          }
        });
      });
    } catch {
    }
    return comments;
  }
  function addPixelEquivalentsToMediaQuery(query, rootFontSize) {
    return query.replace(/(?<=^\s*@media\s*).*?$/, (params) => {
      let comments = getPixelEquivalentsForMediaQuery(params, rootFontSize);
      return applyComments(params, comments);
    });
  }
  function equivalentPixelValues({
    comments,
    rootFontSize
  }) {
    return {
      postcssPlugin: "plugin",
      AtRule: {
        media(atRule22) {
          if (!atRule22.params.includes("em")) {
            return;
          }
          comments.push(
            ...getPixelEquivalentsForMediaQuery(atRule22.params, rootFontSize).map(
              ({ index: index2, value: value2 }) => ({
                index: index2 + atRule22.source.start.offset + `@media${atRule22.raws.afterName}`.length,
                value: value2
              })
            )
          );
        }
      },
      Declaration(decl22) {
        if (!decl22.value.includes("rem")) {
          return;
        }
        (0, import_postcss_value_parser.default)(decl22.value).walk((node) => {
          if (node.type !== "word") {
            return true;
          }
          let unit = import_postcss_value_parser.default.unit(node.value);
          if (!unit || unit.unit !== "rem") {
            return false;
          }
          comments.push({
            index: decl22.source.start.offset + `${decl22.prop}${decl22.raws.between}`.length + node.sourceEndIndex,
            value: `${parseFloat(unit.number) * rootFontSize}px`
          });
          return false;
        });
      }
    };
  }
  equivalentPixelValues.postcss = true;
  var allowedFunctions = ["rgb", "rgba", "hsl", "hsla", "lch", "lab", "oklch", "oklab"];
  function equivalentColorValues({ comments }) {
    return {
      postcssPlugin: "plugin",
      Declaration(decl22) {
        if (!allowedFunctions.some((fn5) => decl22.value.includes(fn5))) {
          return;
        }
        (0, import_postcss_value_parser2.default)(decl22.value).walk((node) => {
          if (node.type !== "function") {
            return true;
          }
          if (!allowedFunctions.includes(node.value)) {
            return false;
          }
          const values = node.nodes.filter((n2) => n2.type === "word").map((n2) => n2.value);
          if (values.length < 3) {
            return false;
          }
          const color2 = getColorFromValue(`${node.value}(${values.join(" ")})`);
          if (!inGamut("rgb")(color2)) {
            return false;
          }
          if (!color2 || typeof color2 === "string") {
            return false;
          }
          comments.push({
            index: decl22.source.start.offset + `${decl22.prop}${decl22.raws.between}`.length + node.sourceEndIndex,
            value: formatColor(color2)
          });
          return false;
        });
      }
    };
  }
  equivalentColorValues.postcss = true;
  function addEquivalents(css, settings) {
    let comments = [];
    let plugins = [];
    if (settings.showPixelEquivalents) {
      plugins.push(
        equivalentPixelValues({
          comments,
          rootFontSize: settings.rootFontSize
        })
      );
    }
    plugins.push(equivalentColorValues({ comments }));
    try {
      postcss_default(plugins).process(css, { from: void 0 }).css;
    } catch {
      return css;
    }
    return applyComments(css, comments);
  }
  function bigSign(bigIntValue) {
    return (bigIntValue > 0n) - (bigIntValue < 0n);
  }
  function generateRules(state, classNames, filter = () => true) {
    let rules = state.modules.jit.generateRules.module(new Set(classNames), state.jitContext).sort(([a2], [z2]) => bigSign(a2 - z2));
    let root2 = state.modules.postcss.module.root({ nodes: rules.map(([, rule2]) => rule2) });
    state.modules.jit.expandApplyAtRules.module(state.jitContext)(root2);
    state.modules.jit.evaluateTailwindFunctions?.module?.(state.jitContext)(root2);
    let actualRules = [];
    root2.walkRules((subRule) => {
      if (filter(subRule)) {
        actualRules.push(subRule);
      }
    });
    return {
      root: root2,
      rules: actualRules
    };
  }
  async function stringifyRoot(state, root2, uri) {
    let settings = await state.editor.getConfiguration(uri);
    let clone = root2.clone();
    clone.walkAtRules("defaults", (node) => {
      node.remove();
    });
    let css = clone.toString();
    css = addEquivalents(css, settings.tailwindCSS);
    let identSize = state.v4 ? 2 : 4;
    let identPattern = state.v4 ? /^(?:  )+/gm : /^(?:    )+/gm;
    return css.replace(/([^;{}\s])(\n\s*})/g, (_match, before, after) => `${before};${after}`).replace(
      identPattern,
      (indent) => " ".repeat(indent.length / identSize * settings.editor.tabSize)
    );
  }
  async function stringifyDecls(state, rule2, uri) {
    let settings = await state.editor.getConfiguration(uri);
    let result = [];
    rule2.walkDecls(({ prop, value: value2 }) => {
      if (settings.tailwindCSS.showPixelEquivalents) {
        value2 = addPixelEquivalentsToValue(value2, settings.tailwindCSS.rootFontSize);
      }
      result.push(`${prop}: ${value2};`);
    });
    return result.join(" ");
  }
  function replaceClassName(state, selector, find, replace2) {
    const transform = (selectors) => {
      selectors.walkClasses((className) => {
        if (className.value === find) {
          className.value = replace2;
        }
      });
    };
    return state.modules.postcssSelectorParser.module(transform).processSync(selector);
  }
  function isAtRule(node) {
    return node.type === "atrule";
  }
  function getRuleContext(state, rule2, className) {
    let context = [replaceClassName(state, rule2.selector, className, "__placeholder__")];
    let p4 = rule2;
    while (p4.parent && p4.parent.type !== "root") {
      p4 = p4.parent;
      if (isAtRule(p4)) {
        context.unshift(`@${p4.name} ${p4.params}`);
      }
    }
    return context;
  }
  var COLOR_PROPS = [
    "accent-color",
    "caret-color",
    "color",
    "column-rule-color",
    "background-color",
    "border-color",
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color",
    "fill",
    "outline-color",
    "stop-color",
    "stroke",
    "text-decoration-color"
  ];
  function getKeywordColor(value2) {
    if (typeof value2 !== "string")
      return null;
    let lowercased = value2.toLowerCase();
    if (lowercased === "transparent") {
      return "transparent";
    }
    if (lowercased === "currentcolor") {
      return "currentColor";
    }
    return null;
  }
  var colorRegex = new RegExp(
    `(?:^|\\s|\\(|,)(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgba?|hsla?|(?:ok)?(?:lab|lch))\\(\\s*(-?[\\d.]+%?(\\s*[,/]\\s*|\\s+)+){2,3}\\s*([\\d.]+%?|var\\([^)]+\\))?\\)|transparent|currentColor|${Object.keys(
      color_name_default
    ).join("|")})(?:$|\\s|\\)|,)`,
    "gi"
  );
  function replaceColorVarsWithTheirDefaults(str) {
    return str.replace(/((?:rgba?|hsla?|(?:ok)?(?:lab|lch))\(\s*)var\([^,]+,\s*([^)]+)\)/gi, "$1$2");
  }
  function replaceHexColorVarsWithTheirDefaults(str) {
    return str.replace(/var\([^,]+,\s*(#[^)]+)\)/gi, "$1");
  }
  function getColorsInString(str) {
    if (/(?:box|drop)-shadow/.test(str))
      return [];
    function toColor(match) {
      let color2 = match[1].replace(/var\([^)]+\)/, "1");
      return getKeywordColor(color2) ?? parse_default(color2);
    }
    str = replaceHexColorVarsWithTheirDefaults(str);
    str = replaceColorVarsWithTheirDefaults(str);
    str = removeColorMixWherePossible(str);
    let possibleColors = str.matchAll(colorRegex);
    return Array.from(possibleColors, toColor).filter(Boolean);
  }
  function getColorFromDecls(decls) {
    let props = Object.keys(decls).filter((prop) => {
      if (prop === "content" && (decls[prop] === '""' || decls[prop] === "''" || decls[prop] === "var(--tw-content)")) {
        return false;
      }
      return true;
    });
    if (props.length === 0)
      return null;
    const nonCustomProps = props.filter((prop) => !prop.startsWith("--"));
    const areAllCustom = nonCustomProps.length === 0;
    if (!areAllCustom && nonCustomProps.some((prop) => !COLOR_PROPS.includes(prop))) {
      return null;
    }
    const propsToCheck = areAllCustom ? props : nonCustomProps;
    const colors = propsToCheck.flatMap((prop) => ensureArray(decls[prop]).flatMap(getColorsInString));
    const colorStrings = dedupe(
      colors.map(
        (color2) => typeof color2 === "string" ? color2 : formatRgb({ ...color2, alpha: void 0 })
      )
    );
    if (colorStrings.length !== 1) {
      return null;
    }
    let keyword = getKeywordColor(colorStrings[0]);
    if (keyword) {
      return keyword;
    }
    const nonKeywordColors = colors.filter(
      (color2) => typeof color2 !== "string"
    );
    const alphas = dedupe(nonKeywordColors.map((color2) => color2.alpha ?? 1));
    if (alphas.length === 1) {
      return nonKeywordColors[0];
    }
    if (alphas.length === 2 && alphas.includes(0)) {
      return nonKeywordColors.find((color2) => (color2.alpha ?? 1) !== 0);
    }
    return null;
  }
  function getColorFromRoot(state, css) {
    css = css.clone();
    css.walkAtRules((rule3) => {
      if (rule3.name === "property") {
        rule3.remove();
      }
      if (rule3.name === "supports" && rule3.params === "(-moz-orient: inline)") {
        rule3.remove();
      }
    });
    let decls = {};
    let rule2 = postcss_default.rule({
      selector: ".x",
      nodes: []
    });
    css.walkDecls((decl22) => {
      rule2.append(decl22.clone());
    });
    css.walkDecls((decl22) => {
      var _a4;
      decls[_a4 = decl22.prop] ?? (decls[_a4] = []);
      decls[decl22.prop].push(decl22.value);
    });
    return getColorFromDecls(decls);
  }
  function getColor(state, className) {
    if (state.v4) {
      let css = state.designSystem.compile([className])[0];
      let color2 = getColorFromRoot(state, css);
      return color2;
    }
    if (state.jit) {
      if (state.classNames) {
        const item2 = (0, import_dlv2.default)(state.classNames.classNames, [className, "__info"]);
        if (item2 && item2.__rule) {
          return getColorFromDecls(removeMeta(item2));
        }
      }
      let result;
      try {
        result = generateRules(state, [className]);
      } catch (err) {
        console.error(`Error generating rules for className: ${className}`);
        console.error(err);
        return null;
      }
      let { root: root2, rules } = result;
      if (rules.length === 0)
        return null;
      let decls = {};
      root2.walkDecls((decl22) => {
        let value2 = decls[decl22.prop];
        if (value2) {
          if (Array.isArray(value2)) {
            value2.push(decl22.value);
          } else {
            decls[decl22.prop] = [value2, decl22.value];
          }
        } else {
          decls[decl22.prop] = decl22.value;
        }
      });
      return getColorFromDecls(decls);
    }
    let parts = getClassNameParts(state, className);
    if (!parts)
      return null;
    const item = (0, import_dlv2.default)(state.classNames.classNames, [...parts, "__info"]);
    if (!item.__rule)
      return null;
    return getColorFromDecls(removeMeta(item));
  }
  function getColorFromValue(value2) {
    if (typeof value2 !== "string")
      return null;
    const trimmedValue = value2.trim();
    if (trimmedValue.toLowerCase() === "transparent") {
      return "transparent";
    }
    if (trimmedValue.toLowerCase() === "currentcolor") {
      return "currentColor";
    }
    if (!/^\s*(?:rgba?|hsla?|(?:ok)?(?:lab|lch))\s*\([^)]+\)\s*$/.test(trimmedValue) && !/^\s*#[0-9a-f]+\s*$/i.test(trimmedValue) && !Object.keys(color_name_default).includes(trimmedValue)) {
      return null;
    }
    const color2 = parse_default(trimmedValue);
    return color2 ?? null;
  }
  var toRgb = converter_default("rgb");
  function culoriColorToVscodeColor(color2) {
    let rgb4 = clampRgb(toRgb(color2));
    return { red: rgb4.r, green: rgb4.g, blue: rgb4.b, alpha: rgb4.alpha ?? 1 };
  }
  function formatColor(color2) {
    if (color2.alpha === void 0 || color2.alpha === 1) {
      return formatHex(color2);
    }
    return formatHex8(color2);
  }
  var COLOR_MIX_REGEX = /color-mix\(in srgb, (.*?) (\d+|\.\d+|\d+\.\d+)%, transparent\)/g;
  function removeColorMixWherePossible(str) {
    return str.replace(COLOR_MIX_REGEX, (match, color2, percentage2) => {
      if (color2.startsWith("var("))
        return match;
      let parsed = parse_default(color2);
      if (!parsed)
        return match;
      let alpha = Number(percentage2) / 100;
      if (Number.isNaN(alpha))
        return match;
      return formatRgb({ ...parsed, alpha });
    });
  }
  var htmlLanguages = [
    "aspnetcorerazor",
    "astro",
    "astro-markdown",
    "blade",
    "django-html",
    "edge",
    "ejs",
    "erb",
    "gohtml",
    "GoHTML",
    "gohtmltmpl",
    "haml",
    "handlebars",
    "hbs",
    "html",
    "HTML (Eex)",
    "HTML (EEx)",
    "html-eex",
    "htmldjango",
    "jade",
    "leaf",
    "liquid",
    "markdown",
    "mdx",
    "mustache",
    "njk",
    "nunjucks",
    "phoenix-heex",
    "php",
    "razor",
    "slim",
    "surface",
    "twig"
  ];
  var cssLanguages = [
    "css",
    "less",
    "postcss",
    "sass",
    "scss",
    "stylus",
    "sugarss",
    "tailwindcss"
  ];
  var jsLanguages = [
    "javascript",
    "javascriptreact",
    "reason",
    "rescript",
    "typescript",
    "typescriptreact",
    "glimmer-js",
    "glimmer-ts"
  ];
  var specialLanguages = ["vue", "svelte"];
  var languages = [...cssLanguages, ...htmlLanguages, ...jsLanguages, ...specialLanguages];
  var semicolonlessLanguages = ["sass", "sugarss", "stylus"];
  function isSemicolonlessCssLanguage(languageId, userLanguages = {}) {
    return semicolonlessLanguages.includes(languageId) || semicolonlessLanguages.includes(userLanguages[languageId]);
  }
  function isJsDoc(state, doc) {
    const userJsLanguages = Object.keys(state.editor.userLanguages).filter(
      (lang) => jsLanguages.includes(state.editor.userLanguages[lang])
    );
    return [...jsLanguages, ...userJsLanguages].indexOf(doc.languageId) !== -1;
  }
  function isJsxContext(state, doc, position2) {
    let str = doc.getText({
      start: { line: 0, character: 0 },
      end: position2
    });
    let boundaries = getLanguageBoundaries(state, doc, str);
    return boundaries ? ["jsx", "tsx"].includes(boundaries[boundaries.length - 1].type) : false;
  }
  function getCssLanguages(state) {
    const userCssLanguages = Object.keys(state.editor.userLanguages).filter(
      (lang) => cssLanguages.includes(state.editor.userLanguages[lang])
    );
    return [...cssLanguages, ...userCssLanguages];
  }
  function isCssLanguage(state, lang) {
    return getCssLanguages(state).indexOf(lang) !== -1;
  }
  function isCssDoc(state, doc) {
    return isCssLanguage(state, doc.languageId);
  }
  function isCssContext(state, doc, position2) {
    if (isCssDoc(state, doc)) {
      return true;
    }
    if (isHtmlDoc(state, doc) || isVueDoc(doc) || isSvelteDoc(doc) || isJsDoc(state, doc)) {
      let str = doc.getText({
        start: { line: 0, character: 0 },
        end: position2
      });
      let boundaries = getLanguageBoundaries(state, doc, str);
      return boundaries ? boundaries[boundaries.length - 1].type === "css" : false;
    }
    return false;
  }
  function isWithinRange(position2, range) {
    if (position2.line === range.start.line && position2.character >= range.start.character) {
      if (position2.line === range.end.line && position2.character > range.end.character) {
        return false;
      } else {
        return true;
      }
    }
    if (position2.line === range.end.line && position2.character <= range.end.character) {
      if (position2.line === range.start.line && position2.character < range.end.character) {
        return false;
      } else {
        return true;
      }
    }
    if (position2.line > range.start.line && position2.line < range.end.line) {
      return true;
    }
    return false;
  }
  var lazy = (getter) => {
    let evaluated = false;
    let _res = null;
    const res = function() {
      if (evaluated)
        return _res;
      _res = getter.apply(this, arguments);
      evaluated = true;
      return _res;
    };
    res.isLazy = true;
    return res;
  };
  var classAttributeStates = () => ({
    doubleClassList: {
      arb: { match: new RegExp("(?<!\\\\)\\["), push: "arbitrary" },
      lbrace: { match: new RegExp("(?<!\\\\)\\{"), push: "interpBrace" },
      rbrace: { match: new RegExp("(?<!\\\\)\\}"), pop: 1 },
      end: { match: new RegExp('(?<!\\\\)"'), pop: 1 },
      classlist: { match: new RegExp("[\\s\\S]"), lineBreaks: true }
    },
    singleClassList: {
      lbrace: { match: new RegExp("(?<!\\\\)\\{"), push: "interpBrace" },
      rbrace: { match: new RegExp("(?<!\\\\)\\}"), pop: 1 },
      end: { match: new RegExp("(?<!\\\\)'"), pop: 1 },
      classlist: { match: new RegExp("[\\s\\S]"), lineBreaks: true }
    },
    tickClassList: {
      lbrace: { match: new RegExp("(?<=(?<!\\\\)\\$)\\{"), push: "interpBrace" },
      rbrace: { match: new RegExp("(?<!\\\\)\\}"), pop: 1 },
      end: { match: new RegExp("(?<!\\\\)`"), pop: 1 },
      classlist: { match: new RegExp("[\\s\\S]"), lineBreaks: true }
    },
    interpBrace: {
      startSingle: { match: new RegExp("(?<!\\\\)'"), push: "singleClassList" },
      startDouble: { match: new RegExp('(?<!\\\\)"'), push: "doubleClassList" },
      startTick: { match: new RegExp("(?<!\\\\)`"), push: "tickClassList" },
      lbrace: { match: new RegExp("(?<!\\\\)\\{"), push: "interpBrace" },
      rbrace: { match: new RegExp("(?<!\\\\)\\}"), pop: 1 },
      text: { match: new RegExp("[\\s\\S]"), lineBreaks: true }
    },
    interpSingle: {
      startDouble: { match: new RegExp('(?<!\\\\)"'), push: "doubleClassList" },
      startTick: { match: new RegExp("(?<!\\\\)`"), push: "tickClassList" },
      single: { match: new RegExp("(?<!\\\\)'"), pop: 1 },
      text: { match: new RegExp("[\\s\\S]"), lineBreaks: true }
    },
    interpDouble: {
      startSingle: { match: new RegExp("(?<!\\\\)'"), push: "singleClassList" },
      startTick: { match: new RegExp("(?<!\\\\)`"), push: "tickClassList" },
      double: { match: new RegExp('(?<!\\\\)"'), pop: 1 },
      text: { match: new RegExp("[\\s\\S]"), lineBreaks: true }
    },
    arbitrary: {
      arb: { match: new RegExp("(?<!\\\\)\\]"), pop: 1 },
      space: { match: /\s/, pop: 1, lineBreaks: true },
      arb2: { match: new RegExp("[\\s\\S]"), lineBreaks: true }
    }
  });
  var simpleClassAttributeStates = {
    main: {
      start: { match: '"', push: "doubleClassList" }
    },
    doubleClassList: {
      end: { match: '"', pop: 1 },
      classlist: { match: /[\s\S]/, lineBreaks: true }
    }
  };
  var getClassAttributeLexer = lazy(() => {
    let supportsNegativeLookbehind = true;
    try {
      new RegExp("(?<!)");
    } catch (_2) {
      supportsNegativeLookbehind = false;
    }
    if (supportsNegativeLookbehind) {
      return import_moo.default.states({
        main: {
          start1: { match: '"', push: "doubleClassList" },
          start2: { match: "'", push: "singleClassList" },
          start3: { match: "{", push: "interpBrace" }
        },
        ...classAttributeStates()
      });
    }
    return import_moo.default.states(simpleClassAttributeStates);
  });
  var getComputedClassAttributeLexer = lazy(() => {
    let supportsNegativeLookbehind = true;
    try {
      new RegExp("(?<!)");
    } catch (_2) {
      supportsNegativeLookbehind = false;
    }
    if (supportsNegativeLookbehind) {
      return import_moo.default.states({
        main: {
          lbrace: { match: "{", push: "interpBrace" },
          single: { match: "'", push: "interpSingle" },
          double: { match: '"', push: "interpDouble" }
        },
        ...classAttributeStates()
      });
    }
    return import_moo.default.states(simpleClassAttributeStates);
  });
  function resolveRange(range, relativeTo) {
    return {
      start: {
        line: (relativeTo?.start.line || 0) + range.start.line,
        character: (range.end.line === 0 ? relativeTo?.start.character || 0 : 0) + range.start.character
      },
      end: {
        line: (relativeTo?.start.line || 0) + range.end.line,
        character: (range.end.line === 0 ? relativeTo?.start.character || 0 : 0) + range.end.character
      }
    };
  }
  function getTextWithoutComments(docOrText, type, range) {
    let text2 = typeof docOrText === "string" ? docOrText : docOrText.getText(range);
    if (type === "js" || type === "jsx") {
      return getJsWithoutComments(text2);
    }
    if (type === "css") {
      return text2.replace(/\/\*.*?\*\//gs, replace);
    }
    return text2.replace(/<!--.*?-->/gs, replace);
  }
  function replace(match) {
    return match.replace(/./gs, (char) => char === "\n" ? "\n" : " ");
  }
  var jsLexer;
  function getJsWithoutComments(text2) {
    if (!jsLexer) {
      jsLexer = import_moo2.default.states({
        main: {
          commentLine: /\/\/.*?$/,
          commentBlock: { match: /\/\*[^]*?\*\//, lineBreaks: true },
          stringDouble: /"(?:[^"\\]|\\.)*"/,
          stringSingle: /'(?:[^'\\]|\\.)*'/,
          stringBacktick: /`(?:[^`\\]|\\.)*`/,
          other: { match: /[^]/, lineBreaks: true }
        }
      });
    }
    let str = "";
    jsLexer.reset(text2);
    for (let token of jsLexer) {
      if (token.type === "commentLine") {
        str += " ".repeat(token.value.length);
      } else if (token.type === "commentBlock") {
        str += token.value.replace(/./g, " ");
      } else {
        str += token.value;
      }
    }
    return str;
  }
  function* customClassesIn({
    text: text2,
    filters,
    cursor = null
  }) {
    for (let filter of filters) {
      let [containerPattern, classPattern] = Array.isArray(filter) ? filter : [filter];
      let containerRegex = new RegExp(containerPattern, "gd");
      let classRegex = classPattern ? new RegExp(classPattern, "gd") : void 0;
      for (let match of matchesIn(text2, containerRegex, classRegex, cursor)) {
        yield match;
      }
    }
  }
  function* matchesIn(text2, containerRegex, classRegex, cursor) {
    for (let containerMatch of text2.matchAll(containerRegex)) {
      if (containerMatch[1] === void 0) {
        console.warn(`Regex /${containerRegex.source}/ must have exactly one capture group`);
        continue;
      }
      const matchStart = containerMatch.indices[1][0];
      const matchEnd = matchStart + containerMatch[1].length;
      if (cursor !== null && (cursor < matchStart || cursor > matchEnd)) {
        continue;
      }
      if (!classRegex) {
        yield {
          classList: cursor !== null ? containerMatch[1].slice(0, cursor - matchStart) : containerMatch[1],
          range: [matchStart, matchEnd]
        };
        continue;
      }
      for (let classMatch of containerMatch[1].matchAll(classRegex)) {
        if (classMatch[1] === void 0) {
          console.warn(`Regex /${classRegex.source}/ must have exactly one capture group`);
          continue;
        }
        const classMatchStart = matchStart + classMatch.indices[1][0];
        const classMatchEnd = classMatchStart + classMatch[1].length;
        if (cursor !== null && (cursor < classMatchStart || cursor > classMatchEnd)) {
          continue;
        }
        yield {
          classList: cursor !== null ? classMatch[1].slice(0, cursor - classMatchStart) : classMatch[1],
          range: [classMatchStart, classMatchEnd]
        };
      }
    }
  }
  function findAll(re, str) {
    let match;
    let matches = [];
    while ((match = re.exec(str)) !== null) {
      matches.push({ ...match });
    }
    return matches;
  }
  function findLast(re, str) {
    const matches = findAll(re, str);
    if (matches.length === 0) {
      return null;
    }
    return matches[matches.length - 1];
  }
  function getClassNamesInClassList({ classList, range, important }, blocklist) {
    const parts = classList.split(/(\s+)/);
    const names = [];
    let index2 = 0;
    for (let i2 = 0; i2 < parts.length; i2++) {
      if (i2 % 2 === 0 && !blocklist.includes(parts[i2])) {
        const start = indexToPosition(classList, index2);
        const end = indexToPosition(classList, index2 + parts[i2].length);
        names.push({
          className: parts[i2],
          classList: {
            classList,
            range,
            important
          },
          relativeRange: {
            start,
            end
          },
          range: {
            start: {
              line: range.start.line + start.line,
              character: (end.line === 0 ? range.start.character : 0) + start.character
            },
            end: {
              line: range.start.line + end.line,
              character: (end.line === 0 ? range.start.character : 0) + end.character
            }
          }
        });
      }
      index2 += parts[i2].length;
    }
    return names;
  }
  async function findClassNamesInRange(state, doc, range, mode, includeCustom = true) {
    const classLists = await findClassListsInRange(state, doc, range, mode, includeCustom);
    return flatten(
      classLists.map((classList) => getClassNamesInClassList(classList, state.blocklist))
    );
  }
  function findClassListsInCssRange(state, doc, range, lang) {
    const text2 = getTextWithoutComments(doc, "css", range);
    let regex = isSemicolonlessCssLanguage(lang ?? doc.languageId, state.editor?.userLanguages) ? /(@apply\s+)(?<classList>[^}\r\n]+?)(?<important>\s*!important)?(?:\r|\n|}|$)/g : /(@apply\s+)(?<classList>[^;}]+?)(?<important>\s*!important)?\s*[;}]/g;
    const matches = findAll(regex, text2);
    const globalStart = range ? range.start : { line: 0, character: 0 };
    return matches.map((match) => {
      const start = indexToPosition(text2, match.index + match[1].length);
      const end = indexToPosition(text2, match.index + match[1].length + match.groups.classList.length);
      return {
        classList: match.groups.classList,
        important: Boolean(match.groups.important),
        range: {
          start: {
            line: globalStart.line + start.line,
            character: (end.line === 0 ? globalStart.character : 0) + start.character
          },
          end: {
            line: globalStart.line + end.line,
            character: (end.line === 0 ? globalStart.character : 0) + end.character
          }
        }
      };
    });
  }
  async function findCustomClassLists(state, doc, range) {
    const settings = await state.editor.getConfiguration(doc.uri);
    const regexes = settings.tailwindCSS.experimental.classRegex;
    if (!Array.isArray(regexes) || regexes.length === 0)
      return [];
    const text2 = doc.getText(range ? { ...range, start: doc.positionAt(0) } : void 0);
    const result = [];
    try {
      for (let match of customClassesIn({ text: text2, filters: regexes })) {
        result.push({
          classList: match.classList,
          range: {
            start: doc.positionAt(match.range[0]),
            end: doc.positionAt(match.range[1])
          }
        });
      }
    } catch (err) {
      console.log(JSON.stringify({ text: text2, filters: regexes }));
      throw new Error("Failed to parse custom class regex");
    }
    return result;
  }
  function matchClassAttributes(text2, attributes) {
    const attrs = attributes.filter((x2) => typeof x2 === "string").flatMap((a2) => [a2, `\\[${a2}\\]`]);
    const re = /(?:\s|:|\()(ATTRS)\s*=\s*['"`{]/;
    return findAll(new RegExp(re.source.replace("ATTRS", attrs.join("|")), "gi"), text2);
  }
  async function findClassListsInHtmlRange(state, doc, type, range) {
    const text2 = getTextWithoutComments(doc, type, range);
    const matches = matchClassAttributes(
      text2,
      (await state.editor.getConfiguration(doc.uri)).tailwindCSS.classAttributes
    );
    const result = [];
    matches.forEach((match) => {
      const subtext = text2.substr(match.index + match[0].length - 1);
      let lexer = match[0][0] === ":" || match[1].startsWith("[") && match[1].endsWith("]") ? getComputedClassAttributeLexer() : getClassAttributeLexer();
      lexer.reset(subtext);
      let classLists = [];
      let token;
      let currentClassList;
      try {
        for (let token2 of lexer) {
          if (token2.type === "classlist" || token2.type.startsWith("arb")) {
            if (currentClassList) {
              currentClassList.value += token2.value;
            } else {
              currentClassList = {
                value: token2.value,
                offset: token2.offset
              };
            }
          } else {
            if (currentClassList) {
              classLists.push({
                value: currentClassList.value,
                offset: currentClassList.offset
              });
            }
            currentClassList = void 0;
          }
        }
      } catch (_2) {
      }
      if (currentClassList) {
        classLists.push({
          value: currentClassList.value,
          offset: currentClassList.offset
        });
      }
      result.push(
        ...classLists.map(({ value: value2, offset }) => {
          if (value2.trim() === "") {
            return null;
          }
          const before = value2.match(/^\s*/);
          const beforeOffset = before === null ? 0 : before[0].length;
          const after = value2.match(/\s*$/);
          const afterOffset = after === null ? 0 : -after[0].length;
          const start = indexToPosition(
            text2,
            match.index + match[0].length - 1 + offset + beforeOffset
          );
          const end = indexToPosition(
            text2,
            match.index + match[0].length - 1 + offset + value2.length + afterOffset
          );
          return {
            classList: value2.substr(beforeOffset, value2.length + afterOffset),
            range: {
              start: {
                line: (range?.start.line || 0) + start.line,
                character: (end.line === 0 ? range?.start.character || 0 : 0) + start.character
              },
              end: {
                line: (range?.start.line || 0) + end.line,
                character: (end.line === 0 ? range?.start.character || 0 : 0) + end.character
              }
            }
          };
        }).filter((x2) => x2 !== null)
      );
    });
    return result;
  }
  async function findClassListsInRange(state, doc, range, mode, includeCustom = true) {
    let classLists = [];
    if (mode === "css") {
      classLists = findClassListsInCssRange(state, doc, range);
    } else if (mode === "html" || mode === "jsx") {
      classLists = await findClassListsInHtmlRange(state, doc, mode, range);
    }
    return dedupeByRange([
      ...classLists,
      ...includeCustom ? await findCustomClassLists(state, doc, range) : []
    ]);
  }
  async function findClassListsInDocument(state, doc) {
    if (isCssDoc(state, doc)) {
      return findClassListsInCssRange(state, doc);
    }
    let boundaries = getLanguageBoundaries(state, doc);
    if (!boundaries)
      return [];
    return dedupeByRange(
      flatten([
        ...await Promise.all(
          boundaries.filter((b2) => b2.type === "html" || b2.type === "jsx").map(
            ({ type, range }) => findClassListsInHtmlRange(state, doc, type === "html" ? "html" : "jsx", range)
          )
        ),
        ...boundaries.filter((b2) => b2.type === "css").map(({ range, lang }) => findClassListsInCssRange(state, doc, range, lang)),
        await findCustomClassLists(state, doc)
      ])
    );
  }
  function findHelperFunctionsInDocument(state, doc) {
    if (isCssDoc(state, doc)) {
      return findHelperFunctionsInRange(doc);
    }
    let boundaries = getLanguageBoundaries(state, doc);
    if (!boundaries)
      return [];
    return flatten(
      boundaries.filter((b2) => b2.type === "css").map(({ range }) => findHelperFunctionsInRange(doc, range))
    );
  }
  function getFirstCommaIndex(str) {
    let quoteChar;
    for (let i2 = 0; i2 < str.length; i2++) {
      let char = str[i2];
      if (char === "," && !quoteChar) {
        return i2;
      }
      if (!quoteChar && (char === '"' || char === "'")) {
        quoteChar = char;
      } else if (char === quoteChar) {
        quoteChar = void 0;
      }
    }
    return null;
  }
  function findHelperFunctionsInRange(doc, range) {
    const text2 = getTextWithoutComments(doc, "css", range);
    let matches = findAll(
      /(?<prefix>[\s:;/*(){}])(?<helper>config|theme)(?<innerPrefix>\(\s*)(?<path>[^)]*?)\s*\)/g,
      text2
    );
    return matches.map((match) => {
      let quotesBefore = "";
      let path = match.groups.path;
      let commaIndex = getFirstCommaIndex(path);
      if (commaIndex !== null) {
        path = path.slice(0, commaIndex).trimEnd();
      }
      path = path.replace(/['"]+$/, "").replace(/^['"]+/, (m2) => {
        quotesBefore = m2;
        return "";
      });
      let matches2 = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
      if (matches2) {
        path = matches2[1];
      }
      path = path.replace(/['"]*\s*$/, "");
      let startIndex = match.index + match.groups.prefix.length + match.groups.helper.length + match.groups.innerPrefix.length;
      return {
        helper: match.groups.helper === "theme" ? "theme" : "config",
        path,
        ranges: {
          full: resolveRange(
            {
              start: indexToPosition(text2, startIndex),
              end: indexToPosition(text2, startIndex + match.groups.path.length)
            },
            range
          ),
          path: resolveRange(
            {
              start: indexToPosition(text2, startIndex + quotesBefore.length),
              end: indexToPosition(text2, startIndex + quotesBefore.length + path.length)
            },
            range
          )
        }
      };
    });
  }
  function indexToPosition(str, index2) {
    const { line, col } = (0, import_line_column.default)(str + "\n").fromIndex(index2) ?? { line: 1, col: 1 };
    return { line: line - 1, character: col - 1 };
  }
  async function findClassNameAtPosition(state, doc, position2) {
    let classNames = [];
    const positionOffset = doc.offsetAt(position2);
    const searchRange = {
      start: doc.positionAt(Math.max(0, positionOffset - 2e3)),
      end: doc.positionAt(positionOffset + 2e3)
    };
    if (isVueDoc(doc)) {
      let boundaries = getLanguageBoundaries(state, doc);
      let groups = await Promise.all(
        boundaries.map(async ({ type, range, lang }) => {
          if (type === "css") {
            return findClassListsInCssRange(state, doc, range, lang);
          }
          if (type === "html") {
            return await findClassListsInHtmlRange(state, doc, "html", range);
          }
          if (type === "jsx") {
            return await findClassListsInHtmlRange(state, doc, "jsx", range);
          }
          return [];
        })
      );
      classNames = dedupeByRange(flatten(groups)).flatMap(
        (classList) => getClassNamesInClassList(classList, state.blocklist)
      );
    } else if (isCssContext(state, doc, position2)) {
      classNames = await findClassNamesInRange(state, doc, searchRange, "css");
    } else if (isHtmlContext(state, doc, position2)) {
      classNames = await findClassNamesInRange(state, doc, searchRange, "html");
    } else if (isJsxContext(state, doc, position2)) {
      classNames = await findClassNamesInRange(state, doc, searchRange, "jsx");
    } else {
      classNames = await findClassNamesInRange(state, doc, searchRange);
    }
    if (classNames.length === 0) {
      return null;
    }
    const className = classNames.find(({ range }) => isWithinRange(position2, range));
    if (!className)
      return null;
    return className;
  }
  var htmlScriptTypes = [
    // https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html#option-1-use-script-tag
    "text/html",
    // https://vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats
    "text/x-template",
    // https://github.com/tailwindlabs/tailwindcss-intellisense/issues/722
    "text/x-handlebars-template"
  ];
  var jsxScriptTypes = [
    // https://github.com/tailwindlabs/tailwindcss-intellisense/issues/906
    "text/babel"
  ];
  var text = { text: { match: /[^]/, lineBreaks: true } };
  var states = {
    main: {
      cssBlockStart: { match: /<style(?=[>\s])/, push: "cssBlock" },
      jsBlockStart: { match: "<script", push: "jsBlock" },
      ...text
    },
    cssBlock: {
      styleStart: { match: ">", next: "style" },
      cssBlockEnd: { match: "/>", pop: 1 },
      attrStartDouble: { match: '"', push: "attrDouble" },
      attrStartSingle: { match: "'", push: "attrSingle" },
      interp: { match: "{", push: "interp" },
      ...text
    },
    jsBlock: {
      scriptStart: { match: ">", next: "script" },
      jsBlockEnd: { match: "/>", pop: 1 },
      langAttrStartDouble: { match: 'lang="', push: "langAttrDouble" },
      langAttrStartSingle: { match: "lang='", push: "langAttrSingle" },
      typeAttrStartDouble: { match: 'type="', push: "typeAttrDouble" },
      typeAttrStartSingle: { match: "type='", push: "typeAttrSingle" },
      attrStartDouble: { match: '"', push: "attrDouble" },
      attrStartSingle: { match: "'", push: "attrSingle" },
      interp: { match: "{", push: "interp" },
      ...text
    },
    interp: {
      interp: { match: "{", push: "interp" },
      end: { match: "}", pop: 1 },
      ...text
    },
    langAttrDouble: {
      langAttrEnd: { match: '"', pop: 1 },
      lang: { match: /[^"]+/, lineBreaks: true }
    },
    langAttrSingle: {
      langAttrEnd: { match: "'", pop: 1 },
      lang: { match: /[^']+/, lineBreaks: true }
    },
    typeAttrDouble: {
      langAttrEnd: { match: '"', pop: 1 },
      type: { match: /[^"]+/, lineBreaks: true }
    },
    typeAttrSingle: {
      langAttrEnd: { match: "'", pop: 1 },
      type: { match: /[^']+/, lineBreaks: true }
    },
    attrDouble: {
      attrEnd: { match: '"', pop: 1 },
      ...text
    },
    attrSingle: {
      attrEnd: { match: "'", pop: 1 },
      ...text
    },
    style: {
      cssBlockEnd: { match: /<\/style\s*>/, pop: 1 },
      ...text
    },
    script: {
      jsBlockEnd: { match: /<\/script\s*>/, pop: 1 },
      ...text
    }
  };
  var vueStates = {
    ...states,
    main: {
      htmlBlockStart: { match: "<template", push: "htmlBlock" },
      ...states.main
    },
    cssBlock: {
      langAttrStartDouble: { match: 'lang="', push: "langAttrDouble" },
      langAttrStartSingle: { match: "lang='", push: "langAttrSingle" },
      ...states.cssBlock
    },
    htmlBlock: {
      htmlStart: { match: ">", next: "html" },
      htmlBlockEnd: { match: "/>", pop: 1 },
      attrStartDouble: { match: '"', push: "attrDouble" },
      attrStartSingle: { match: "'", push: "attrSingle" },
      interp: { match: "{", push: "interp" },
      ...text
    },
    html: {
      htmlBlockEnd: { match: "</template>", pop: 1 },
      nestedBlockStart: { match: "<template", push: "nestedBlock" },
      ...text
    },
    nestedBlock: {
      nestedStart: { match: ">", next: "nested" },
      nestedBlockEnd: { match: "/>", pop: 1 },
      ...text
    },
    nested: {
      nestedBlockEnd: { match: "</template>", pop: 1 },
      nestedBlockStart: { match: "<template", push: "nestedBlock" },
      ...text
    }
  };
  var defaultLexer = import_moo3.default.states(states);
  var vueLexer = import_moo3.default.states(vueStates);
  var cache = new import_tmp_cache.default({ max: 25, maxAge: 1e3 });
  function getLanguageBoundaries(state, doc, text2 = doc.getText()) {
    let cacheKey = `${doc.languageId}:${text2}`;
    let cachedBoundaries = cache.get(cacheKey);
    if (cachedBoundaries !== void 0) {
      return cachedBoundaries;
    }
    let isJs = isJsDoc(state, doc);
    let defaultType = isVueDoc(doc) ? "none" : isHtmlDoc(state, doc) || isSvelteDoc(doc) ? "html" : isJs ? "jsx" : null;
    if (defaultType === null) {
      cache.set(cacheKey, null);
      return null;
    }
    text2 = getTextWithoutComments(text2, isJs ? "js" : "html");
    let lexer = defaultType === "none" ? vueLexer : defaultLexer;
    lexer.reset(text2);
    let type = defaultType;
    let boundaries = [
      { type: defaultType, range: { start: { line: 0, character: 0 }, end: void 0 } }
    ];
    let offset = 0;
    try {
      for (let token of lexer) {
        if (!token.type.startsWith("nested")) {
          if (token.type.endsWith("BlockStart")) {
            let position2 = indexToPosition(text2, offset);
            if (!boundaries[boundaries.length - 1].range.end) {
              boundaries[boundaries.length - 1].range.end = position2;
            }
            type = token.type.replace(/BlockStart$/, "");
            boundaries.push({ type, range: { start: position2, end: void 0 } });
          } else if (token.type.endsWith("BlockEnd")) {
            let position2 = indexToPosition(text2, offset);
            boundaries[boundaries.length - 1].range.end = position2;
            boundaries.push({ type: defaultType, range: { start: position2, end: void 0 } });
          } else if (token.type === "lang") {
            boundaries[boundaries.length - 1].type = token.text;
          } else if (token.type === "type" && htmlScriptTypes.includes(token.text)) {
            boundaries[boundaries.length - 1].type = "html";
          } else if (token.type === "type" && jsxScriptTypes.includes(token.text)) {
            boundaries[boundaries.length - 1].type = "jsx";
          }
        }
        offset += token.text.length;
      }
    } catch {
      cache.set(cacheKey, null);
      return null;
    }
    if (!boundaries[boundaries.length - 1].range.end) {
      boundaries[boundaries.length - 1].range.end = indexToPosition(text2, offset);
    }
    cache.set(cacheKey, boundaries);
    for (let boundary of boundaries) {
      if (boundary.type === "css")
        continue;
      if (!isCssLanguage(state, boundary.type))
        continue;
      boundary.lang = boundary.type;
      boundary.type = "css";
    }
    return boundaries;
  }
  function isHtmlDoc(state, doc) {
    const userHtmlLanguages = Object.keys(state.editor.userLanguages).filter(
      (lang) => htmlLanguages.includes(state.editor.userLanguages[lang])
    );
    return [...htmlLanguages, ...userHtmlLanguages].indexOf(doc.languageId) !== -1;
  }
  function isVueDoc(doc) {
    return doc.languageId === "vue";
  }
  function isSvelteDoc(doc) {
    return doc.languageId === "svelte";
  }
  function isHtmlContext(state, doc, position2) {
    let str = doc.getText({
      start: { line: 0, character: 0 },
      end: position2
    });
    let boundaries = getLanguageBoundaries(state, doc, str);
    return boundaries ? boundaries[boundaries.length - 1].type === "html" : false;
  }
  function stringifyConfigValue(x2) {
    if (isObject3(x2))
      return `${Object.keys(x2).length} values`;
    if (typeof x2 === "function")
      return "\u0192";
    if (typeof x2 === "string")
      return x2;
    return stringifyObject(x2, {
      inlineCharacterLimit: Infinity,
      singleQuotes: false,
      transform: (obj, prop, originalResult) => {
        if (typeof obj[prop] === "function") {
          return "\u0192";
        }
        return originalResult;
      }
    });
  }
  function stringifyCss(className, obj, settings) {
    if (obj.__rule !== true && !Array.isArray(obj))
      return null;
    if (Array.isArray(obj)) {
      const rules = obj.map((x2) => stringifyCss(className, x2, settings)).filter(Boolean);
      if (rules.length === 0)
        return null;
      return rules.join("\n\n");
    }
    let css = ``;
    const indent = " ".repeat(settings.editor.tabSize);
    const context = (0, import_dlv4.default)(obj, "__context", []);
    const props = Object.keys(removeMeta(obj));
    if (props.length === 0)
      return null;
    for (let i2 = 0; i2 < context.length; i2++) {
      css += `${indent.repeat(i2)}${context[i2]} {
`;
    }
    const indentStr = indent.repeat(context.length);
    const decls = props.reduce((acc, curr, i2) => {
      const propStr = ensureArray(obj[curr]).map((val) => `${indentStr + indent}${curr}: ${val};`).join("\n");
      return `${acc}${i2 === 0 ? "" : "\n"}${propStr}`;
    }, "");
    css += `${indentStr}${augmentClassName(className, obj)} {
${decls}
${indentStr}}`;
    for (let i2 = context.length - 1; i2 >= 0; i2--) {
      css += `${indent.repeat(i2)}
}`;
    }
    css = addEquivalents(css, settings.tailwindCSS);
    return css;
  }
  function augmentClassName(className, obj) {
    const pseudo = obj.__pseudo.join("");
    const scope = obj.__scope ? `${obj.__scope} ` : "";
    return `${scope}.${(0, import_css.default)(className)}${pseudo}`;
  }
  function isRawScreen(screen) {
    return isObject3(screen) && screen.raw !== void 0;
  }
  function stringifyScreen(screen) {
    if (!screen)
      return void 0;
    if (typeof screen === "string")
      return `@media (min-width: ${screen})`;
    if (isRawScreen(screen)) {
      return `@media ${screen.raw}`;
    }
    let str = (Array.isArray(screen) ? screen : [screen]).map((range) => {
      return [
        typeof range.min === "string" ? `(min-width: ${range.min})` : null,
        typeof range.max === "string" ? `(max-width: ${range.max})` : null
      ].filter(Boolean).join(" and ");
    }).join(", ");
    return str ? `@media ${str}` : void 0;
  }
  function braceLevel(text2) {
    let count = 0;
    for (let i2 = text2.length - 1; i2 >= 0; i2--) {
      let char = text2.charCodeAt(i2);
      count += Number(
        char === 123
        /* { */
      ) - Number(
        char === 125
        /* } */
      );
    }
    return count;
  }
  function isValidLocationForEmmetAbbreviation(document3, abbreviationRange) {
    const startAngle = "<";
    const endAngle = ">";
    const escape2 = "\\";
    const question = "?";
    let start = { line: 0, character: 0 };
    let textToBackTrack = document3.getText({
      start: {
        line: start.line,
        character: start.character
      },
      end: {
        line: abbreviationRange.start.line,
        character: abbreviationRange.start.character
      }
    });
    if (textToBackTrack.length > 500) {
      textToBackTrack = textToBackTrack.substr(textToBackTrack.length - 500);
    }
    if (!textToBackTrack.trim()) {
      return true;
    }
    let valid = true;
    let foundSpace = false;
    let i2 = textToBackTrack.length - 1;
    if (textToBackTrack[i2] === startAngle) {
      return false;
    }
    while (i2 >= 0) {
      const char = textToBackTrack[i2];
      i2--;
      if (!foundSpace && /\s/.test(char)) {
        foundSpace = true;
        continue;
      }
      if (char === question && textToBackTrack[i2] === startAngle) {
        i2--;
        continue;
      }
      if (/\s/.test(char) && textToBackTrack[i2] === startAngle) {
        i2--;
        continue;
      }
      if (char !== startAngle && char !== endAngle) {
        continue;
      }
      if (i2 >= 0 && textToBackTrack[i2] === escape2) {
        i2--;
        continue;
      }
      if (char === endAngle) {
        if (i2 >= 0 && textToBackTrack[i2] === "=") {
          continue;
        } else {
          break;
        }
      }
      if (char === startAngle) {
        valid = !foundSpace;
        break;
      }
    }
    return valid;
  }
  function naturalExpand(value2, total) {
    let length2 = typeof total === "number" ? total.toString().length : 8;
    return ("0".repeat(length2) + value2).slice(-length2);
  }
  function gte(v1, v2) {
    if (v1.startsWith("0.0.0-insiders")) {
      return true;
    }
    return (0, import_gte.default)(v1, v2);
  }
  function docsUrl(version2, paths) {
    let major = 0;
    let url2 = "https://tailwindcss-v0.netlify.app/docs/";
    if (gte(version2, "0.99.0")) {
      major = 1;
      url2 = "https://v1.tailwindcss.com/docs/";
    }
    if (gte(version2, "1.99.0")) {
      major = 2;
      url2 = "https://tailwindcss.com/docs/";
    }
    const path = Array.isArray(paths) ? paths[major] || paths[paths.length - 1] : paths;
    return `${url2}${path}`;
  }
  function getClassNameMeta(state, classNameOrParts) {
    const parts = Array.isArray(classNameOrParts) ? classNameOrParts : getClassNameParts(state, classNameOrParts);
    if (!parts)
      return null;
    const info = (0, import_dlv5.default)(state.classNames.classNames, [...parts, "__info"]);
    if (Array.isArray(info)) {
      return info.map((i2) => ({
        source: i2.__source,
        pseudo: i2.__pseudo,
        scope: i2.__scope,
        context: i2.__context
      }));
    }
    return {
      source: info.__source,
      pseudo: info.__pseudo,
      scope: info.__scope,
      context: info.__context
    };
  }
  function flagEnabled(state, flag) {
    if (state.featureFlags.future.includes(flag)) {
      return state.config.future === "all" || (0, import_dlv6.default)(state.config, ["future", flag], false);
    }
    if (state.featureFlags.experimental.includes(flag)) {
      return state.config.experimental === "all" || (0, import_dlv6.default)(state.config, ["experimental", flag], false);
    }
    return false;
  }
  function validateApply(state, classNameOrParts) {
    if (state.jit) {
      return { isApplyable: true };
    }
    const meta = getClassNameMeta(state, classNameOrParts);
    if (!meta)
      return null;
    if (gte(state.version, "2.0.0-alpha.1") || flagEnabled(state, "applyComplexClasses")) {
      return { isApplyable: true };
    }
    const className = Array.isArray(classNameOrParts) ? classNameOrParts.join(state.separator) : classNameOrParts;
    let reason;
    if (Array.isArray(meta)) {
      reason = `'@apply' cannot be used with '${className}' because it is included in multiple rulesets.`;
    } else if (meta.source !== "utilities") {
      reason = `'@apply' cannot be used with '${className}' because it is not a utility.`;
    } else if (meta.context && meta.context.length > 0) {
      if (meta.context.length === 1) {
        reason = `'@apply' cannot be used with '${className}' because it is nested inside of an at-rule ('${meta.context[0]}').`;
      } else {
        reason = `'@apply' cannot be used with '${className}' because it is nested inside of at-rules (${meta.context.map((c3) => `'${c3}'`).join(", ")}).`;
      }
    } else if (meta.pseudo && meta.pseudo.length > 0) {
      if (meta.pseudo.length === 1) {
        reason = `'@apply' cannot be used with '${className}' because its definition includes a pseudo-selector ('${meta.pseudo[0]}')`;
      } else {
        reason = `'@apply' cannot be used with '${className}' because its definition includes pseudo-selectors (${meta.pseudo.map((p4) => `'${p4}'`).join(", ")}).`;
      }
    }
    if (reason) {
      return { isApplyable: false, reason };
    }
    return { isApplyable: true };
  }
  function getVariantsFromClassName(state, className) {
    let allVariants = state.variants.flatMap((variant) => {
      if (variant.values.length) {
        return variant.values.map(
          (value2) => value2 === "DEFAULT" ? variant.name : `${variant.name}${variant.hasDash ? "-" : ""}${value2}`
        );
      }
      return [variant.name];
    });
    let variants = /* @__PURE__ */ new Set();
    let offset = 0;
    let parts = splitAtTopLevelOnly(className, state.separator);
    if (parts.length < 2) {
      return { variants: Array.from(variants), offset };
    }
    parts = parts.filter(Boolean);
    for (let part of parts) {
      if (allVariants.includes(part) || state.jit && (part.includes("[") && part.endsWith("]") || part.includes("/")) && generateRules(state, [`${part}${state.separator}[color:red]`]).rules.length > 0) {
        variants.add(part);
        offset += part.length + state.separator.length;
        continue;
      }
      break;
    }
    return { variants: Array.from(variants), offset };
  }
  function splitAtTopLevelOnly(input, separator) {
    let stack = [];
    let parts = [];
    let lastPos = 0;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (stack.length === 0 && char === separator[0]) {
        if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
          parts.push(input.slice(lastPos, idx));
          lastPos = idx + separator.length;
        }
      }
      if (char === "(" || char === "[" || char === "{") {
        stack.push(char);
      } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
        stack.pop();
      }
    }
    parts.push(input.slice(lastPos));
    return parts;
  }
  var isUtil = (className) => Array.isArray(className.__info) ? className.__info.some((x2) => x2.__source === "utilities") : className.__info.__source === "utilities";
  function completionsFromClassList(state, classList, classListRange, rootFontSize, filter, context) {
    let classNames = classList.split(/[\s+]/);
    const partialClassName = classNames[classNames.length - 1];
    let sep2 = state.separator;
    let parts = partialClassName.split(sep2);
    let subset;
    let subsetKey = [];
    let isSubset = false;
    let replacementRange = {
      ...classListRange,
      start: {
        ...classListRange.start,
        character: classListRange.end.character - partialClassName.length
      }
    };
    if (state.v4) {
      let variantItem = function(item) {
        return {
          kind: 9,
          data: {
            ...state.completionItemData ?? {},
            _type: "variant"
          },
          command: item.insertTextFormat === 2 ? void 0 : {
            title: "",
            command: "editor.action.triggerSuggest"
          },
          sortText: "-" + naturalExpand(variantOrder++),
          ...item
        };
      };
      let { variants: existingVariants, offset } = getVariantsFromClassName(state, partialClassName);
      if (context && (context.triggerKind === 1 || context.triggerKind === 2 && context.triggerCharacter === "/") && partialClassName.includes("/")) {
        let modifiers;
        let beforeSlash = partialClassName.split("/").slice(0, -1).join("/");
        let baseClassName = beforeSlash.slice(offset);
        modifiers = state.classList.find((cls) => Array.isArray(cls) && cls[0] === baseClassName)?.[1]?.modifiers;
        if (modifiers) {
          return withDefaults(
            {
              isIncomplete: false,
              items: modifiers.map((modifier, index2) => {
                let className = `${beforeSlash}/${modifier}`;
                let kind = CompletionItemKind.Constant;
                let documentation;
                const color2 = getColor(state, className);
                if (color2 !== null) {
                  kind = CompletionItemKind.Color;
                  if (typeof color2 !== "string" && (color2.alpha ?? 1) !== 0) {
                    documentation = formatColor(color2);
                  }
                }
                return {
                  label: className,
                  ...documentation ? { documentation } : {},
                  kind,
                  sortText: naturalExpand(index2)
                };
              })
            },
            {
              range: replacementRange,
              data: state.completionItemData
            },
            state.editor.capabilities.itemDefaults
          );
        }
      }
      replacementRange.start.character += offset;
      let important = partialClassName.substr(offset).endsWith("!");
      if (important) {
        replacementRange.end.character -= 1;
      }
      let items = [];
      let seenVariants = /* @__PURE__ */ new Set();
      let variantOrder = 0;
      for (let variant of state.variants) {
        if (existingVariants.includes(variant.name)) {
          continue;
        }
        if (seenVariants.has(variant.name)) {
          continue;
        }
        seenVariants.add(variant.name);
        if (variant.isArbitrary) {
          items.push(
            variantItem({
              label: `${variant.name}${variant.hasDash ? "-" : ""}[]${sep2}`,
              insertTextFormat: 2,
              textEditText: `${variant.name}${variant.hasDash ? "-" : ""}[\${1}]${sep2}\${0}`
              // command: {
              //   title: '',
              //   command: 'tailwindCSS.onInsertArbitraryVariantSnippet',
              //   arguments: [variant.name, replacementRange],
              // },
            })
          );
        } else {
          let shouldSortVariants = !gte(state.version, "2.99.0");
          let resultingVariants = [...existingVariants, variant.name];
          if (shouldSortVariants) {
            let allVariants = state.variants.map(({ name }) => name);
            resultingVariants = resultingVariants.sort(
              (a2, b2) => allVariants.indexOf(b2) - allVariants.indexOf(a2)
            );
          }
          let selectors = [];
          try {
            selectors = variant.selectors();
          } catch (err) {
            console.log("Error while trying to get selectors for variant");
            console.log({
              variant,
              err
            });
          }
          if (selectors.length === 0) {
            continue;
          }
          items.push(
            variantItem({
              label: `${variant.name}${sep2}`,
              detail: selectors.map((selector) => addPixelEquivalentsToMediaQuery(selector, rootFontSize)).join(", "),
              textEditText: resultingVariants[resultingVariants.length - 1] + sep2,
              additionalTextEdits: shouldSortVariants && resultingVariants.length > 1 ? [
                {
                  newText: resultingVariants.slice(0, resultingVariants.length - 1).join(sep2) + sep2,
                  range: {
                    start: {
                      ...classListRange.start,
                      character: classListRange.end.character - partialClassName.length
                    },
                    end: {
                      ...replacementRange.start,
                      character: replacementRange.start.character
                    }
                  }
                }
              ] : []
            })
          );
        }
        for (let value2 of variant.values ?? []) {
          if (existingVariants.includes(`${variant.name}-${value2}`)) {
            continue;
          }
          if (seenVariants.has(`${variant.name}-${value2}`)) {
            continue;
          }
          seenVariants.add(`${variant.name}-${value2}`);
          let selectors = [];
          try {
            selectors = variant.selectors({ value: value2 });
          } catch (err) {
            console.log("Error while trying to get selectors for variant");
            console.log({
              variant,
              err
            });
          }
          if (selectors.length === 0) {
            continue;
          }
          items.push(
            variantItem({
              label: value2 === "DEFAULT" ? `${variant.name}${sep2}` : `${variant.name}${variant.hasDash ? "-" : ""}${value2}${sep2}`,
              detail: selectors.join(", ")
            })
          );
        }
      }
      return withDefaults(
        {
          isIncomplete: false,
          items: items.concat(
            state.classList.reduce((items2, [className, { color: color2 }], index2) => {
              if (state.blocklist?.includes([...existingVariants, className].join(state.separator))) {
                return items2;
              }
              let kind = color2 ? CompletionItemKind.Color : CompletionItemKind.Constant;
              let documentation;
              if (color2 && typeof color2 !== "string") {
                documentation = formatColor(color2);
              }
              items2.push({
                label: className,
                kind,
                ...documentation ? { documentation } : {},
                sortText: naturalExpand(index2, state.classList.length)
              });
              return items2;
            }, [])
          )
        },
        {
          data: {
            ...state.completionItemData ?? {},
            ...important ? { important } : {},
            variants: existingVariants
          },
          range: replacementRange
        },
        state.editor.capabilities.itemDefaults
      );
    }
    if (state.jit) {
      let { variants: existingVariants, offset } = getVariantsFromClassName(state, partialClassName);
      if (context && (context.triggerKind === 1 || context.triggerKind === 2 && context.triggerCharacter === "/") && partialClassName.includes("/")) {
        let modifiers;
        let beforeSlash = partialClassName.split("/").slice(0, -1).join("/");
        if (state.classListContainsMetadata) {
          let baseClassName = beforeSlash.slice(offset);
          modifiers = state.classList.find(
            (cls) => Array.isArray(cls) && cls[0] === baseClassName
          )?.[1]?.modifiers;
        } else {
          let testClass = beforeSlash + "/[0]";
          let { rules } = generateRules(state, [testClass]);
          if (rules.length > 0) {
            let opacities = (0, import_dlv.default)(state.config, "theme.opacity", {});
            if (!isObject3(opacities)) {
              opacities = {};
            }
            modifiers = Object.keys(opacities);
          }
        }
        if (modifiers) {
          return withDefaults(
            {
              isIncomplete: false,
              items: modifiers.map((modifier, index2) => {
                let className = `${beforeSlash}/${modifier}`;
                let kind = CompletionItemKind.Constant;
                let documentation;
                const color2 = getColor(state, className);
                if (color2 !== null) {
                  kind = CompletionItemKind.Color;
                  if (typeof color2 !== "string" && (color2.alpha ?? 1) !== 0) {
                    documentation = formatColor(color2);
                  }
                }
                return {
                  label: className,
                  ...documentation ? { documentation } : {},
                  kind,
                  sortText: naturalExpand(index2)
                };
              })
            },
            {
              range: replacementRange,
              data: state.completionItemData
            },
            state.editor.capabilities.itemDefaults
          );
        }
      }
      replacementRange.start.character += offset;
      let important = partialClassName.substr(offset).startsWith("!");
      if (important) {
        replacementRange.start.character += 1;
      }
      let items = [];
      let seenVariants = /* @__PURE__ */ new Set();
      if (!important) {
        let variantItem = function(item) {
          return {
            kind: 9,
            data: {
              ...state.completionItemData ?? {},
              _type: "variant"
            },
            command: item.insertTextFormat === 2 ? void 0 : {
              title: "",
              command: "editor.action.triggerSuggest"
            },
            sortText: "-" + naturalExpand(variantOrder++),
            ...item
          };
        };
        let variantOrder = 0;
        for (let variant of state.variants) {
          if (existingVariants.includes(variant.name)) {
            continue;
          }
          if (seenVariants.has(variant.name)) {
            continue;
          }
          seenVariants.add(variant.name);
          if (variant.isArbitrary) {
            items.push(
              variantItem({
                label: `${variant.name}${variant.hasDash ? "-" : ""}[]${sep2}`,
                insertTextFormat: 2,
                textEditText: `${variant.name}${variant.hasDash ? "-" : ""}[\${1}]${sep2}\${0}`
                // command: {
                //   title: '',
                //   command: 'tailwindCSS.onInsertArbitraryVariantSnippet',
                //   arguments: [variant.name, replacementRange],
                // },
              })
            );
          } else {
            let shouldSortVariants = !gte(state.version, "2.99.0");
            let resultingVariants = [...existingVariants, variant.name];
            if (shouldSortVariants) {
              let allVariants = state.variants.map(({ name }) => name);
              resultingVariants = resultingVariants.sort(
                (a2, b2) => allVariants.indexOf(b2) - allVariants.indexOf(a2)
              );
            }
            items.push(
              variantItem({
                label: `${variant.name}${sep2}`,
                detail: variant.selectors().map((selector) => addPixelEquivalentsToMediaQuery(selector, rootFontSize)).join(", "),
                textEditText: resultingVariants[resultingVariants.length - 1] + sep2,
                additionalTextEdits: shouldSortVariants && resultingVariants.length > 1 ? [
                  {
                    newText: resultingVariants.slice(0, resultingVariants.length - 1).join(sep2) + sep2,
                    range: {
                      start: {
                        ...classListRange.start,
                        character: classListRange.end.character - partialClassName.length
                      },
                      end: {
                        ...replacementRange.start,
                        character: replacementRange.start.character
                      }
                    }
                  }
                ] : []
              })
            );
          }
          for (let value2 of variant.values ?? []) {
            if (existingVariants.includes(`${variant.name}-${value2}`)) {
              continue;
            }
            if (seenVariants.has(`${variant.name}-${value2}`)) {
              continue;
            }
            seenVariants.add(`${variant.name}-${value2}`);
            items.push(
              variantItem({
                label: value2 === "DEFAULT" ? `${variant.name}${sep2}` : `${variant.name}${variant.hasDash ? "-" : ""}${value2}${sep2}`,
                detail: variant.selectors({ value: value2 }).join(", ")
              })
            );
          }
        }
      }
      if (state.classList) {
        return withDefaults(
          {
            isIncomplete: false,
            items: items.concat(
              state.classList.reduce((items2, [className, { color: color2 }], index2) => {
                if (state.blocklist?.includes([...existingVariants, className].join(state.separator))) {
                  return items2;
                }
                let kind = color2 ? CompletionItemKind.Color : CompletionItemKind.Constant;
                let documentation;
                if (color2 && typeof color2 !== "string") {
                  documentation = formatColor(color2);
                }
                items2.push({
                  label: className,
                  kind,
                  ...documentation ? { documentation } : {},
                  sortText: naturalExpand(index2, state.classList.length)
                });
                return items2;
              }, [])
            )
          },
          {
            data: {
              ...state.completionItemData ?? {},
              ...important ? { important } : {},
              variants: existingVariants
            },
            range: replacementRange
          },
          state.editor.capabilities.itemDefaults
        );
      }
      return withDefaults(
        {
          isIncomplete: false,
          items: items.concat(
            Object.keys(state.classNames.classNames).filter((className) => {
              let item = state.classNames.classNames[className];
              if (existingVariants.length === 0) {
                return item.__info;
              }
              return item.__info && isUtil(item);
            }).map((className, index2, classNames2) => {
              let kind = CompletionItemKind.Constant;
              let documentation;
              const color2 = getColor(state, className);
              if (color2 !== null) {
                kind = CompletionItemKind.Color;
                if (typeof color2 !== "string" && (color2.alpha ?? 1) !== 0) {
                  documentation = formatColor(color2);
                }
              }
              return {
                label: className,
                kind,
                ...documentation ? { documentation } : {},
                sortText: naturalExpand(index2, classNames2.length)
              };
            })
          ).filter((item) => {
            if (item === null) {
              return false;
            }
            if (filter && !filter(item)) {
              return false;
            }
            return true;
          })
        },
        {
          range: replacementRange,
          data: {
            ...state.completionItemData ?? {},
            variants: existingVariants,
            ...important ? { important } : {}
          }
        },
        state.editor.capabilities.itemDefaults
      );
    }
    for (let i2 = parts.length - 1; i2 > 0; i2--) {
      let keys = parts.slice(0, i2).filter(Boolean);
      subset = (0, import_dlv.default)(state.classNames.classNames, keys);
      if (typeof subset !== "undefined" && typeof (0, import_dlv.default)(subset, ["__info", "__rule"]) === "undefined") {
        isSubset = true;
        subsetKey = keys;
        replacementRange = {
          ...replacementRange,
          start: {
            ...replacementRange.start,
            character: replacementRange.start.character + keys.join(sep2).length + sep2.length
          }
        };
        break;
      }
    }
    return withDefaults(
      {
        isIncomplete: false,
        items: Object.keys(isSubset ? subset : state.classNames.classNames).filter((k5) => k5 !== "__info").filter((className) => isContextItem(state, [...subsetKey, className])).map((className, index2, classNames2) => {
          return {
            label: className + sep2,
            kind: 9,
            command: {
              title: "",
              command: "editor.action.triggerSuggest"
            },
            sortText: "-" + naturalExpand(index2, classNames2.length),
            data: {
              ...state.completionItemData ?? {},
              className,
              variants: subsetKey
            }
          };
        }).concat(
          Object.keys(isSubset ? subset : state.classNames.classNames).filter(
            (className) => (0, import_dlv.default)(state.classNames.classNames, [...subsetKey, className, "__info"])
          ).map((className, index2, classNames2) => {
            let kind = CompletionItemKind.Constant;
            let documentation;
            const color2 = getColor(state, className);
            if (color2 !== null) {
              kind = CompletionItemKind.Color;
              if (typeof color2 !== "string" && (color2.alpha ?? 1) !== 0) {
                documentation = formatColor(color2);
              }
            }
            return {
              label: className,
              kind,
              ...documentation ? { documentation } : {},
              sortText: naturalExpand(index2, classNames2.length)
            };
          })
        ).filter((item) => {
          if (item === null) {
            return false;
          }
          if (filter && !filter(item)) {
            return false;
          }
          return true;
        })
      },
      {
        range: replacementRange,
        data: {
          ...state.completionItemData ?? {},
          variants: subsetKey
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  async function provideClassAttributeCompletions(state, document3, position2, context) {
    let str = document3.getText({
      start: document3.positionAt(Math.max(0, document3.offsetAt(position2) - 2e3)),
      end: position2
    });
    let settings = (await state.editor.getConfiguration(document3.uri)).tailwindCSS;
    let matches = matchClassAttributes(str, settings.classAttributes);
    if (matches.length === 0) {
      return null;
    }
    let match = matches[matches.length - 1];
    const lexer = match[0][0] === ":" || match[1].startsWith("[") && match[1].endsWith("]") ? getComputedClassAttributeLexer() : getClassAttributeLexer();
    lexer.reset(str.substr(match.index + match[0].length - 1));
    try {
      let tokens = Array.from(lexer);
      let last = tokens[tokens.length - 1];
      if (last.type.startsWith("start") || last.type === "classlist" || last.type.startsWith("arb")) {
        let classList = "";
        for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
          if (tokens[i2].type === "classlist" || tokens[i2].type.startsWith("arb")) {
            classList = tokens[i2].value + classList;
          } else {
            break;
          }
        }
        return completionsFromClassList(
          state,
          classList,
          {
            start: {
              line: position2.line,
              character: position2.character - classList.length
            },
            end: position2
          },
          settings.rootFontSize,
          void 0,
          context
        );
      }
    } catch (_2) {
    }
    return null;
  }
  async function provideCustomClassNameCompletions(state, document3, position2, context) {
    const settings = await state.editor.getConfiguration(document3.uri);
    const filters = settings.tailwindCSS.experimental.classRegex;
    if (filters.length === 0)
      return null;
    const cursor = document3.offsetAt(position2);
    let text2 = document3.getText({
      start: document3.positionAt(0),
      end: document3.positionAt(cursor + 2e3)
    });
    for (let match of customClassesIn({ text: text2, cursor, filters })) {
      return completionsFromClassList(
        state,
        match.classList,
        {
          start: {
            line: position2.line,
            character: position2.character - match.classList.length
          },
          end: position2
        },
        settings.tailwindCSS.rootFontSize,
        void 0,
        context
      );
    }
    return null;
  }
  function provideThemeVariableCompletions(state, document3, position2, _context) {
    if (!isCssContext(state, document3, position2))
      return null;
    let text2 = getTextWithoutComments(document3, "css", {
      start: { line: 0, character: 0 },
      end: position2
    });
    if (!text2.endsWith("-"))
      return null;
    let themeBlock = text2.lastIndexOf("@theme");
    if (themeBlock === -1)
      return null;
    if (braceLevel(text2.slice(themeBlock)) !== 1)
      return null;
    function themeVar(label) {
      return {
        label,
        kind: CompletionItemKind.Variable
        // insertTextFormat: InsertTextFormat.Snippet,
        // textEditText: `${label}-[\${1}]`,
      };
    }
    function themeNamespace(label) {
      return {
        label: `${label}-`,
        kind: CompletionItemKind.Variable
        // insertTextFormat: InsertTextFormat.Snippet,
        // textEditText: `${label}-[\${1}]`,
      };
    }
    return withDefaults(
      {
        isIncomplete: false,
        items: [
          themeVar("--default-transition-duration"),
          themeVar("--default-transition-timing-function"),
          themeVar("--default-font-family"),
          themeVar("--default-font-feature-settings"),
          themeVar("--default-font-variation-settings"),
          themeVar("--default-mono-font-family"),
          themeVar("--default-mono-font-feature-settings"),
          themeVar("--default-mono-font-variation-settings"),
          themeNamespace("--breakpoint"),
          themeNamespace("--color"),
          themeNamespace("--animate"),
          themeNamespace("--blur"),
          themeNamespace("--radius"),
          themeNamespace("--shadow"),
          themeNamespace("--inset-shadow"),
          themeNamespace("--drop-shadow"),
          themeNamespace("--spacing"),
          themeNamespace("--width"),
          themeNamespace("--font-family"),
          themeNamespace("--font-size"),
          themeNamespace("--letter-spacing"),
          themeNamespace("--line-height"),
          themeNamespace("--transition-timing-function")
        ]
      },
      {
        data: {
          ...state.completionItemData ?? {}
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  async function provideAtApplyCompletions(state, document3, position2, context) {
    let settings = (await state.editor.getConfiguration(document3.uri)).tailwindCSS;
    let str = document3.getText({
      start: { line: Math.max(position2.line - 30, 0), character: 0 },
      end: position2
    });
    const match = findLast(/@apply\s+(?<classList>[^;}]*)$/gi, str);
    if (match === null) {
      return null;
    }
    const classList = match.groups.classList;
    return completionsFromClassList(
      state,
      classList,
      {
        start: {
          line: position2.line,
          character: position2.character - classList.length
        },
        end: position2
      },
      settings.rootFontSize,
      (item) => {
        if (item.kind === 9) {
          return gte(state.version, "2.0.0-alpha.1") || flagEnabled(state, "applyComplexClasses");
        }
        let variants = item.data?.variants ?? [];
        let className = item.data?.className ?? item.label;
        let validated = validateApply(state, [...variants, className]);
        return validated !== null && validated.isApplyable === true;
      },
      context
    );
  }
  var NUMBER_REGEX = /^(\d+\.?|\d*\.\d+)$/;
  function isNumber2(str) {
    return NUMBER_REGEX.test(str);
  }
  async function provideClassNameCompletions(state, document3, position2, context) {
    if (isCssContext(state, document3, position2)) {
      return provideAtApplyCompletions(state, document3, position2, context);
    }
    if (isHtmlContext(state, document3, position2) || isJsxContext(state, document3, position2)) {
      return provideClassAttributeCompletions(state, document3, position2, context);
    }
    return null;
  }
  function provideCssHelperCompletions(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: { line: position2.line, character: 0 },
      // read one extra character so we can see if it's a ] later
      end: { line: position2.line, character: position2.character + 1 }
    });
    const match = text2.substr(0, text2.length - 1).match(/[\s:;/*(){}](?<helper>config|theme)\(\s*['"]?(?<path>[^)'"]*)$/);
    if (match === null) {
      return null;
    }
    let alpha;
    let path = match.groups.path.replace(/^['"]+/g, "");
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]*))$/);
    if (matches) {
      path = matches[1];
      alpha = matches[2];
    }
    if (alpha !== void 0) {
      return null;
    }
    let base = match.groups.helper === "config" ? state.config : (0, import_dlv.default)(state.config, "theme", {});
    let parts = path.split(/([\[\].]+)/);
    let keys = parts.filter((_2, i2) => i2 % 2 === 0);
    let separators = parts.filter((_2, i2) => i2 % 2 !== 0);
    function totalLength(arr) {
      return arr.reduce((acc, cur) => acc + cur.length, 0);
    }
    let obj;
    let offset = keys[keys.length - 1].length;
    let separator = separators.length ? separators[separators.length - 1] : null;
    if (keys.length === 1) {
      obj = base;
    } else {
      for (let i2 = keys.length - 1; i2 > 0; i2--) {
        let o2 = (0, import_dlv.default)(base, keys.slice(0, i2));
        if (isObject3(o2)) {
          obj = o2;
          offset = totalLength(parts.slice(i2 * 2));
          separator = separators[i2 - 1];
          break;
        }
      }
    }
    if (!obj)
      return null;
    let editRange = {
      start: {
        line: position2.line,
        character: position2.character - offset
      },
      end: position2
    };
    return withDefaults(
      {
        isIncomplete: false,
        items: Object.keys(obj).sort((a2, z2) => {
          let aIsNumber = isNumber2(a2);
          let zIsNumber = isNumber2(z2);
          if (aIsNumber && !zIsNumber) {
            return -1;
          }
          if (!aIsNumber && zIsNumber) {
            return 1;
          }
          if (aIsNumber && zIsNumber) {
            return parseFloat(a2) - parseFloat(z2);
          }
          return 0;
        }).map((item, index2, items) => {
          let color2 = getColorFromValue(obj[item]);
          const replaceDot = item.indexOf(".") !== -1 && separator && separator.endsWith(".");
          const insertClosingBrace = text2.charAt(text2.length - 1) !== "]" && (replaceDot || separator && separator.endsWith("["));
          const detail = stringifyConfigValue(obj[item]);
          return {
            label: item,
            sortText: naturalExpand(index2, items.length),
            commitCharacters: [!item.includes(".") && ".", !item.includes("[") && "["].filter(
              Boolean
            ),
            kind: color2 ? 16 : isObject3(obj[item]) ? 9 : 10,
            // VS Code bug causes some values to not display in some cases
            detail: detail === "0" || detail === "transparent" ? `${detail} ` : detail,
            ...color2 && typeof color2 !== "string" && (color2.alpha ?? 1) !== 0 ? { documentation: formatColor(color2) } : {},
            ...insertClosingBrace ? { textEditText: `${item}]` } : {},
            additionalTextEdits: replaceDot ? [
              {
                newText: "[",
                range: {
                  start: {
                    ...editRange.start,
                    character: editRange.start.character - 1
                  },
                  end: editRange.start
                }
              }
            ] : []
          };
        })
      },
      {
        range: editRange,
        data: {
          ...state.completionItemData ?? {},
          _type: "helper"
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  function provideTailwindDirectiveCompletions(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: { line: position2.line, character: 0 },
      end: position2
    });
    const match = text2.match(/^\s*@tailwind\s+(?<partial>[^\s]*)$/i);
    if (match === null)
      return null;
    let items = [
      gte(state.version, "1.0.0-beta.1") ? {
        label: "base",
        documentation: {
          kind: "markdown",
          value: `This injects Tailwind\u2019s base styles and any base styles registered by plugins.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#tailwind"
          )})`
        }
      } : {
        label: "preflight",
        documentation: {
          kind: "markdown",
          value: `This injects Tailwind\u2019s base styles, which is a combination of Normalize.css and some additional base styles.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#tailwind"
          )})`
        }
      },
      {
        label: "components",
        documentation: {
          kind: "markdown",
          value: `This injects Tailwind\u2019s component classes and any component classes registered by plugins.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#tailwind"
          )})`
        }
      },
      {
        label: "utilities",
        documentation: {
          kind: "markdown",
          value: `This injects Tailwind\u2019s utility classes and any utility classes registered by plugins.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#tailwind"
          )})`
        }
      },
      state.jit && gte(state.version, "2.1.99") ? {
        label: "variants",
        documentation: {
          kind: "markdown",
          value: `Use this directive to control where Tailwind injects the utility variants.

This directive is considered an advanced escape hatch and it is recommended to omit it whenever possible. If omitted, Tailwind will append these classes to the very end of your stylesheet by default.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "just-in-time-mode#variants-are-inserted-at-tailwind-variants"
          )})`
        }
      } : {
        label: "screens",
        documentation: {
          kind: "markdown",
          value: `Use this directive to control where Tailwind injects the responsive variations of each utility.

If omitted, Tailwind will append these classes to the very end of your stylesheet by default.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#tailwind"
          )})`
        }
      }
    ];
    return withDefaults(
      {
        isIncomplete: false,
        items: items.map((item) => ({
          ...item,
          kind: 21
        }))
      },
      {
        data: {
          ...state.completionItemData ?? {},
          _type: "@tailwind"
        },
        range: {
          start: {
            line: position2.line,
            character: position2.character - match.groups.partial.length
          },
          end: position2
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  function provideVariantsDirectiveCompletions(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    if (gte(state.version, "2.99.0")) {
      return null;
    }
    let text2 = document3.getText({
      start: { line: position2.line, character: 0 },
      end: position2
    });
    const match = text2.match(/^\s*@variants\s+(?<partial>[^}]*)$/i);
    if (match === null)
      return null;
    const parts = match.groups.partial.split(/\s*,\s*/);
    if (/\s+/.test(parts[parts.length - 1]))
      return null;
    let possibleVariants = state.variants.flatMap((variant) => {
      if (variant.values.length) {
        return variant.values.map(
          (value2) => value2 === "DEFAULT" ? variant.name : `${variant.name}${variant.hasDash ? "-" : ""}${value2}`
        );
      }
      return [variant.name];
    });
    const existingVariants = parts.slice(0, parts.length - 1);
    if (state.jit) {
      possibleVariants.unshift("responsive");
      possibleVariants = possibleVariants.filter((v2) => !state.screens.includes(v2));
    }
    return withDefaults(
      {
        isIncomplete: false,
        items: possibleVariants.filter((v2) => existingVariants.indexOf(v2) === -1).map((variant, index2, variants) => ({
          // TODO: detail
          label: variant,
          kind: 21,
          sortText: naturalExpand(index2, variants.length)
        }))
      },
      {
        data: {
          ...state.completionItemData ?? {},
          _type: "variant"
        },
        range: {
          start: {
            line: position2.line,
            character: position2.character - parts[parts.length - 1].length
          },
          end: position2
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  function provideLayerDirectiveCompletions(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: { line: position2.line, character: 0 },
      end: position2
    });
    const match = text2.match(/^\s*@layer\s+(?<partial>[^\s]*)$/i);
    if (match === null)
      return null;
    return withDefaults(
      {
        isIncomplete: false,
        items: ["base", "components", "utilities"].map((layer, index2, layers) => ({
          label: layer,
          kind: 21,
          sortText: naturalExpand(index2, layers.length)
        }))
      },
      {
        data: {
          ...state.completionItemData ?? {},
          _type: "layer"
        },
        range: {
          start: {
            line: position2.line,
            character: position2.character - match.groups.partial.length
          },
          end: position2
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  function withDefaults(completionList, defaults3, supportedDefaults) {
    let defaultData = supportedDefaults.includes("data");
    let defaultRange = supportedDefaults.includes("editRange");
    return {
      ...completionList,
      ...defaultData || defaultRange ? {
        itemDefaults: {
          ...defaultData && defaults3.data ? { data: defaults3.data } : {},
          ...defaultRange && defaults3.range ? { editRange: defaults3.range } : {}
        }
      } : {},
      items: defaultData && defaultRange ? completionList.items : completionList.items.map(({ textEditText, ...item }) => ({
        ...item,
        ...defaultData || !defaults3.data || item.data ? {} : { data: defaults3.data },
        ...defaultRange || !defaults3.range ? textEditText ? { textEditText } : {} : {
          textEdit: {
            newText: textEditText ?? item.label,
            range: defaults3.range
          }
        }
      }))
    };
  }
  function provideScreenDirectiveCompletions(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: { line: position2.line, character: 0 },
      end: position2
    });
    const match = text2.match(/^\s*@screen\s+(?<partial>[^\s]*)$/i);
    if (match === null)
      return null;
    const screens = (0, import_dlv.default)(state.config, ["screens"], (0, import_dlv.default)(state.config, ["theme", "screens"], {}));
    if (!isObject3(screens))
      return null;
    return withDefaults(
      {
        isIncomplete: false,
        items: Object.keys(screens).map((screen, index2) => ({
          label: screen,
          kind: 21,
          sortText: naturalExpand(index2)
        }))
      },
      {
        data: {
          ...state.completionItemData ?? {},
          _type: "screen"
        },
        range: {
          start: {
            line: position2.line,
            character: position2.character - match.groups.partial.length
          },
          end: position2
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  function provideCssDirectiveCompletions(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: { line: position2.line, character: 0 },
      end: position2
    });
    const match = text2.match(/^\s*@(?<partial>[a-z]*)$/i);
    if (match === null)
      return null;
    const items = [
      {
        label: "@tailwind",
        documentation: {
          kind: "markdown",
          value: `Use the \`@tailwind\` directive to insert Tailwind\u2019s \`base\`, \`components\`, \`utilities\` and \`${state.jit && gte(state.version, "2.1.99") ? "variants" : "screens"}\` styles into your CSS.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#tailwind"
          )})`
        }
      },
      {
        label: "@screen",
        documentation: {
          kind: "markdown",
          value: `The \`@screen\` directive allows you to create media queries that reference your breakpoints by name instead of duplicating their values in your own CSS.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#screen"
          )})`
        }
      },
      {
        label: "@apply",
        documentation: {
          kind: "markdown",
          value: `Use \`@apply\` to inline any existing utility classes into your own custom CSS.

[Tailwind CSS Documentation](${docsUrl(
            state.version,
            "functions-and-directives/#apply"
          )})`
        }
      },
      ...gte(state.version, "1.8.0") ? [
        {
          label: "@layer",
          documentation: {
            kind: "markdown",
            value: `Use the \`@layer\` directive to tell Tailwind which "bucket" a set of custom styles belong to. Valid layers are \`base\`, \`components\`, and \`utilities\`.

[Tailwind CSS Documentation](${docsUrl(
              state.version,
              "functions-and-directives/#layer"
            )})`
          }
        }
      ] : [],
      ...gte(state.version, "2.99.0") ? [] : [
        {
          label: "@variants",
          documentation: {
            kind: "markdown",
            value: `You can generate \`responsive\`, \`hover\`, \`focus\`, \`active\`, and other variants of your own utilities by wrapping their definitions in the \`@variants\` directive.

[Tailwind CSS Documentation](${docsUrl(
              state.version,
              "functions-and-directives/#variants"
            )})`
          }
        },
        {
          label: "@responsive",
          documentation: {
            kind: "markdown",
            value: `You can generate responsive variants of your own classes by wrapping their definitions in the \`@responsive\` directive.

[Tailwind CSS Documentation](${docsUrl(
              state.version,
              "functions-and-directives/#responsive"
            )})`
          }
        }
      ],
      ...gte(state.version, "3.2.0") ? [
        {
          label: "@config",
          documentation: {
            kind: "markdown",
            value: `Use the \`@config\` directive to specify which config file Tailwind should use when compiling that CSS file.

[Tailwind CSS Documentation](${docsUrl(
              state.version,
              "functions-and-directives/#config"
            )})`
          }
        }
      ] : [],
      ...gte(state.version, "4.0.0") ? [
        {
          label: "@theme",
          documentation: {
            kind: "markdown",
            value: `Use the \`@theme\` directive to specify which config file Tailwind should use when compiling that CSS file.

[Tailwind CSS Documentation](${docsUrl(
              state.version,
              "functions-and-directives/#config"
            )})`
          }
        }
      ] : []
    ];
    return withDefaults(
      {
        isIncomplete: false,
        items: items.map((item) => ({
          ...item,
          kind: 14
        }))
      },
      {
        data: {
          ...state.completionItemData ?? {},
          _type: "directive"
        },
        range: {
          start: {
            line: position2.line,
            character: position2.character - match.groups.partial.length - 1
          },
          end: position2
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  async function provideConfigDirectiveCompletions(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    if (!gte(state.version, "3.2.0")) {
      return null;
    }
    let text2 = document3.getText({ start: { line: position2.line, character: 0 }, end: position2 });
    let match = text2.match(/@config\s*(?<partial>'[^']*|"[^"]*)$/);
    if (!match) {
      return null;
    }
    let partial = match.groups.partial.slice(1);
    let valueBeforeLastSlash = partial.substring(0, partial.lastIndexOf("/"));
    let valueAfterLastSlash = partial.substring(partial.lastIndexOf("/") + 1);
    return withDefaults(
      {
        isIncomplete: false,
        items: (await state.editor.readDirectory(document3, valueBeforeLastSlash || ".")).filter(([name, type]) => type.isDirectory || /\.c?js$/.test(name)).map(([name, type]) => ({
          label: type.isDirectory ? name + "/" : name,
          kind: type.isDirectory ? 19 : 17,
          command: type.isDirectory ? { command: "editor.action.triggerSuggest", title: "" } : void 0
        }))
      },
      {
        data: {
          ...state.completionItemData ?? {},
          _type: "filesystem"
        },
        range: {
          start: {
            line: position2.line,
            character: position2.character - valueAfterLastSlash.length
          },
          end: position2
        }
      },
      state.editor.capabilities.itemDefaults
    );
  }
  async function provideEmmetCompletions(state, document3, position2) {
    let settings = await state.editor.getConfiguration(document3.uri);
    if (settings.tailwindCSS.emmetCompletions !== true)
      return null;
    const isHtml = !isJsDoc(state, document3) && isHtmlContext(state, document3, position2);
    const isJs = isJsDoc(state, document3) || isJsxContext(state, document3, position2);
    const syntax = isHtml ? "html" : isJs ? "jsx" : null;
    if (syntax === null) {
      return null;
    }
    const extractAbbreviationResults = extractAbbreviation(document3, position2, true);
    if (!extractAbbreviationResults || !isAbbreviationValid(syntax, extractAbbreviationResults.abbreviation)) {
      return null;
    }
    if (!isValidLocationForEmmetAbbreviation(document3, extractAbbreviationResults.abbreviationRange)) {
      return null;
    }
    if (isJs) {
      const abbreviation = extractAbbreviationResults.abbreviation;
      if (abbreviation.startsWith("this.")) {
        return null;
      }
      const symbols = await state.editor.getDocumentSymbols(document3.uri);
      if (symbols && symbols.find(
        (symbol) => abbreviation === symbol.name || abbreviation.startsWith(symbol.name + ".") && !/>|\*|\+/.test(abbreviation)
      )) {
        return null;
      }
    }
    const emmetItems = doComplete(document3, position2, syntax, {});
    if (!emmetItems || !emmetItems.items || emmetItems.items.length !== 1) {
      return null;
    }
    if (emmetItems.items[0].label === "widows: ;") {
      return null;
    }
    const parts = emmetItems.items[0].label.split(".");
    if (parts.length < 2)
      return null;
    return completionsFromClassList(
      state,
      parts[parts.length - 1],
      {
        start: {
          line: position2.line,
          character: position2.character - parts[parts.length - 1].length
        },
        end: position2
      },
      settings.tailwindCSS.rootFontSize
    );
  }
  async function doComplete2(state, document3, position2, context) {
    if (state === null)
      return { items: [], isIncomplete: false };
    const result = await provideClassNameCompletions(state, document3, position2, context) || provideCssHelperCompletions(state, document3, position2) || provideCssDirectiveCompletions(state, document3, position2) || provideScreenDirectiveCompletions(state, document3, position2) || provideVariantsDirectiveCompletions(state, document3, position2) || provideTailwindDirectiveCompletions(state, document3, position2) || provideLayerDirectiveCompletions(state, document3, position2) || await provideConfigDirectiveCompletions(state, document3, position2) || await provideCustomClassNameCompletions(state, document3, position2, context) || provideThemeVariableCompletions(state, document3, position2, context);
    if (result)
      return result;
    return provideEmmetCompletions(state, document3, position2);
  }
  async function resolveCompletionItem(state, item) {
    if (["helper", "directive", "variant", "layer", "@tailwind", "filesystem"].includes(
      item.data?._type
    )) {
      return item;
    }
    if (item.data?._type === "screen") {
      let screens = (0, import_dlv.default)(state.config, ["theme", "screens"], (0, import_dlv.default)(state.config, ["screens"], {}));
      if (!isObject3(screens))
        screens = {};
      item.detail = stringifyScreen(screens[item.label]);
      return item;
    }
    let className = item.data?.className ?? item.label;
    if (item.data?.important) {
      className = `!${className}`;
    }
    let variants = item.data?.variants ?? [];
    if (state.v4) {
      if (item.kind === 9)
        return item;
      if (item.detail && item.documentation)
        return item;
      let root2 = state.designSystem.compile([[...variants, className].join(state.separator)])[0];
      let rules2 = root2.nodes.filter((node) => node.type === "rule");
      if (rules2.length === 0)
        return item;
      if (!item.detail) {
        if (rules2.length === 1) {
          let decls = [];
          root2.walkDecls((node) => {
            decls.push(node);
          });
          item.detail = await stringifyDecls(
            state,
            rule({
              nodes: decls
            })
          );
        } else {
          item.detail = `${rules2.length} rules`;
        }
      }
      if (!item.documentation) {
        item.documentation = {
          kind: "markdown",
          value: [
            "```css",
            await stringifyRoot(state, root({ nodes: rules2 })),
            "```"
          ].join("\n")
        };
      }
      return item;
    }
    if (state.jit) {
      if (item.kind === 9)
        return item;
      if (item.detail && item.documentation)
        return item;
      let { root: root2, rules: rules2 } = generateRules(state, [[...variants, className].join(state.separator)]);
      if (rules2.length === 0)
        return item;
      if (!item.detail) {
        if (rules2.length === 1) {
          item.detail = await stringifyDecls(state, rules2[0]);
        } else {
          item.detail = `${rules2.length} rules`;
        }
      }
      if (!item.documentation) {
        item.documentation = {
          kind: "markdown",
          value: ["```css", await stringifyRoot(state, root2), "```"].join("\n")
        };
      }
      return item;
    }
    const rules = (0, import_dlv.default)(state.classNames.classNames, [...variants, className, "__info"]);
    if (item.kind === 9) {
      item.detail = state.classNames.context[className].join(", ");
    } else {
      item.detail = await getCssDetail(state, rules);
      if (!item.documentation) {
        const settings = await state.editor.getConfiguration();
        const css = stringifyCss([...variants, className].join(":"), rules, settings);
        if (css) {
          item.documentation = {
            kind: "markdown",
            value: ["```css", css, "```"].join("\n")
          };
        }
      }
    }
    return item;
  }
  function isContextItem(state, keys) {
    const item = (0, import_dlv.default)(state.classNames.classNames, keys);
    if (!isObject3(item)) {
      return false;
    }
    if (!state.classNames.context[keys[keys.length - 1]]) {
      return false;
    }
    if (Object.keys(item).filter((x2) => x2 !== "__info").length > 0) {
      return true;
    }
    return isObject3(item.__info) && !item.__info.__rule;
  }
  function stringifyDecls2(obj, settings) {
    let props = Object.keys(obj);
    let nonCustomProps = props.filter((prop) => !prop.startsWith("--"));
    if (props.length !== nonCustomProps.length && nonCustomProps.length !== 0) {
      props = nonCustomProps;
    }
    return props.map(
      (prop) => ensureArray(obj[prop]).map((value2) => {
        if (settings.tailwindCSS.showPixelEquivalents) {
          value2 = addPixelEquivalentsToValue(value2, settings.tailwindCSS.rootFontSize);
        }
        return `${prop}: ${value2};`;
      }).join(" ")
    ).join(" ");
  }
  async function getCssDetail(state, className) {
    if (Array.isArray(className)) {
      return `${className.length} rules`;
    }
    if (className.__rule === true) {
      const settings = await state.editor.getConfiguration();
      return stringifyDecls2(removeMeta(className), settings);
    }
    return null;
  }
  function isCssConflictDiagnostic(diagnostic) {
    return diagnostic.code === "cssConflict";
  }
  function isInvalidApplyDiagnostic(diagnostic) {
    return diagnostic.code === "invalidApply";
  }
  function isInvalidScreenDiagnostic(diagnostic) {
    return diagnostic.code === "invalidScreen";
  }
  function isInvalidVariantDiagnostic(diagnostic) {
    return diagnostic.code === "invalidVariant";
  }
  function isInvalidConfigPathDiagnostic(diagnostic) {
    return diagnostic.code === "invalidConfigPath";
  }
  function isInvalidTailwindDirectiveDiagnostic(diagnostic) {
    return diagnostic.code === "invalidTailwindDirective";
  }
  function isRecommendedVariantOrderDiagnostic(diagnostic) {
    return diagnostic.code === "recommendedVariantOrder";
  }
  function joinWithAnd(strings) {
    return strings.reduce((acc, cur, i2) => {
      if (i2 === 0) {
        return cur;
      }
      if (strings.length > 1 && i2 === strings.length - 1) {
        return `${acc} and ${cur}`;
      }
      return `${acc}, ${cur}`;
    }, "");
  }
  function getClassNameDecls(state, className) {
    const parts = getClassNameParts(state, className);
    if (!parts)
      return null;
    const info = (0, import_dlv7.default)(state.classNames.classNames, [...parts, "__info"]);
    if (Array.isArray(info)) {
      return info.map(removeMeta);
    }
    return removeMeta(info);
  }
  function isAtRule2(node) {
    return node.type === "atrule";
  }
  function isKeyframes(rule2) {
    let parent = rule2.parent;
    if (!parent) {
      return false;
    }
    if (isAtRule2(parent) && parent.name === "keyframes") {
      return true;
    }
    return false;
  }
  function getRuleProperties(rule2) {
    let properties = [];
    rule2.walkDecls(({ prop }) => {
      properties.push(prop);
    });
    return properties;
  }
  async function getCssConflictDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.cssConflict;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    const classLists = await findClassListsInDocument(state, document3);
    classLists.forEach((classList) => {
      const classNames = getClassNamesInClassList(classList, state.blocklist);
      if (state.v4) {
        const groups = recordClassDetails(state, classNames);
        for (let [className, conflictingClassNames] of findConflicts(classNames, groups)) {
          diagnostics.push({
            code: "cssConflict",
            className,
            otherClassNames: conflictingClassNames,
            range: className.range,
            severity: severity === "error" ? 1 : 2,
            message: `'${className.className}' applies the same CSS properties as ${joinWithAnd(
              conflictingClassNames.map(
                (conflictingClassName) => `'${conflictingClassName.className}'`
              )
            )}.`,
            relatedInformation: conflictingClassNames.map((conflictingClassName) => {
              return {
                message: conflictingClassName.className,
                location: {
                  uri: document3.uri,
                  range: conflictingClassName.range
                }
              };
            })
          });
        }
        return;
      }
      classNames.forEach((className, index2) => {
        if (state.jit) {
          let { rules } = generateRules(
            state,
            [className.className],
            (rule2) => !isKeyframes(rule2)
          );
          if (rules.length === 0) {
            return;
          }
          let info = rules.map((rule2) => {
            let properties2 = getRuleProperties(rule2);
            let context = getRuleContext(state, rule2, className.className);
            return { context, properties: properties2 };
          });
          let otherClassNames2 = classNames.filter((_className, i2) => i2 !== index2);
          let conflictingClassNames2 = otherClassNames2.filter((otherClassName) => {
            let { rules: otherRules } = generateRules(
              state,
              [otherClassName.className],
              (rule2) => !isKeyframes(rule2)
            );
            if (otherRules.length !== rules.length) {
              return false;
            }
            let propertiesAreComparable = false;
            for (let i2 = 0; i2 < otherRules.length; i2++) {
              let otherRule = otherRules[i2];
              let properties2 = getRuleProperties(otherRule);
              if (info[i2].properties.length > 0 && properties2.length > 0) {
                propertiesAreComparable = true;
              }
              if (!equal(info[i2].properties, properties2)) {
                return false;
              }
              let context = getRuleContext(state, otherRule, otherClassName.className);
              if (!equal(info[i2].context, context)) {
                return false;
              }
            }
            if (!propertiesAreComparable) {
              return false;
            }
            return true;
          });
          if (conflictingClassNames2.length === 0)
            return;
          diagnostics.push({
            code: "cssConflict",
            className,
            otherClassNames: conflictingClassNames2,
            range: className.range,
            severity: severity === "error" ? 1 : 2,
            message: `'${className.className}' applies the same CSS properties as ${joinWithAnd(
              conflictingClassNames2.map(
                (conflictingClassName) => `'${conflictingClassName.className}'`
              )
            )}.`,
            relatedInformation: conflictingClassNames2.map((conflictingClassName) => {
              return {
                message: conflictingClassName.className,
                location: {
                  uri: document3.uri,
                  range: conflictingClassName.range
                }
              };
            })
          });
          return;
        }
        let decls = getClassNameDecls(state, className.className);
        if (!decls)
          return;
        let properties = Object.keys(decls);
        let meta = getClassNameMeta(state, className.className);
        let otherClassNames = classNames.filter((_className, i2) => i2 !== index2);
        let conflictingClassNames = otherClassNames.filter((otherClassName) => {
          let otherDecls = getClassNameDecls(state, otherClassName.className);
          if (!otherDecls)
            return false;
          let otherMeta = getClassNameMeta(state, otherClassName.className);
          return equal(properties, Object.keys(otherDecls)) && !Array.isArray(meta) && !Array.isArray(otherMeta) && equal(meta.context, otherMeta.context) && equal(meta.pseudo, otherMeta.pseudo) && meta.scope === otherMeta.scope;
        });
        if (conflictingClassNames.length === 0)
          return;
        diagnostics.push({
          code: "cssConflict",
          className,
          otherClassNames: conflictingClassNames,
          range: className.range,
          severity: severity === "error" ? 1 : 2,
          message: `'${className.className}' applies the same CSS ${properties.length === 1 ? "property" : "properties"} as ${joinWithAnd(
            conflictingClassNames.map(
              (conflictingClassName) => `'${conflictingClassName.className}'`
            )
          )}.`,
          relatedInformation: conflictingClassNames.map((conflictingClassName) => {
            return {
              message: conflictingClassName.className,
              location: {
                uri: document3.uri,
                range: conflictingClassName.range
              }
            };
          })
        });
      });
    });
    return diagnostics;
  }
  function visit(nodes, cb, path = []) {
    for (let child of nodes) {
      path = [...path, child];
      cb(child, path);
      if ("nodes" in child && child.nodes && child.nodes.length > 0) {
        visit(child.nodes, cb, path);
      }
    }
  }
  function recordClassDetails(state, classes) {
    const groups = {};
    let roots = state.designSystem.compile(classes.map((c3) => c3.className));
    for (let [idx, root2] of roots.entries()) {
      let { className } = classes[idx];
      visit([root2], (node, path) => {
        if (node.type !== "rule" && node.type !== "atrule")
          return;
        let properties = [];
        for (let child of node.nodes ?? []) {
          if (child.type !== "decl")
            continue;
          properties.push(child.prop);
        }
        if (properties.length === 0)
          return;
        groups[className] ?? (groups[className] = []);
        groups[className].push({
          properties,
          context: path.map((node2) => {
            if (node2.type === "rule") {
              return node2.selector;
            } else if (node2.type === "atrule") {
              return `@${node2.name} ${node2.params}`;
            }
            return "";
          }).filter(Boolean).slice(1)
        });
      });
    }
    return groups;
  }
  function* findConflicts(classes, groups) {
    for (let className of classes) {
      let entries = groups[className.className] ?? [];
      let conflictingClassNames = [];
      for (let otherClassName of classes) {
        if (className === otherClassName)
          continue;
        let otherEntries = groups[otherClassName.className] ?? [];
        if (entries.length !== otherEntries.length)
          continue;
        let hasConflict = false;
        for (let i2 = 0; i2 < entries.length; i2++) {
          let entry = entries[i2];
          let otherEntry = otherEntries[i2];
          if (entry.properties.length !== otherEntry.properties.length) {
            hasConflict = false;
            break;
          }
          if (entry.context.length !== otherEntry.context.length) {
            hasConflict = false;
            break;
          }
          if (!equal(entry.properties, otherEntry.properties)) {
            hasConflict = false;
            break;
          }
          if (!equal(entry.context, otherEntry.context)) {
            hasConflict = false;
            break;
          }
          if (entry.properties.length === 0 && otherEntry.properties.length === 0) {
            continue;
          }
          hasConflict = true;
        }
        if (!hasConflict)
          continue;
        conflictingClassNames.push(otherClassName);
      }
      if (conflictingClassNames.length === 0)
        return;
      yield [className, conflictingClassNames];
    }
  }
  async function getInvalidApplyDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidApply;
    if (severity === "ignore")
      return [];
    const classNames = await findClassNamesInRange(state, document3, void 0, "css", false);
    let diagnostics = classNames.map((className) => {
      let result = validateApply(state, className.className);
      if (result === null || result.isApplyable === true) {
        return null;
      }
      return {
        code: "invalidApply",
        severity: severity === "error" ? 1 : 2,
        range: className.range,
        message: result.reason,
        className
      };
    });
    return diagnostics.filter(Boolean);
  }
  function closest(input, options) {
    return options.concat([]).sort((a2, b2) => (0, import_sift_string.default)(input, a2) - (0, import_sift_string.default)(input, b2))[0];
  }
  function absoluteRange(range, reference) {
    return {
      start: {
        line: (reference?.start.line || 0) + range.start.line,
        character: (range.end.line === 0 ? reference?.start.character || 0 : 0) + range.start.character
      },
      end: {
        line: (reference?.start.line || 0) + range.end.line,
        character: (range.end.line === 0 ? reference?.start.character || 0 : 0) + range.end.character
      }
    };
  }
  function getInvalidScreenDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidScreen;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    let ranges = [];
    if (isCssDoc(state, document3)) {
      ranges.push(void 0);
    } else {
      let boundaries = getLanguageBoundaries(state, document3);
      if (!boundaries)
        return [];
      ranges.push(...boundaries.filter((b2) => b2.type === "css").map(({ range }) => range));
    }
    ranges.forEach((range) => {
      let text2 = getTextWithoutComments(document3, "css", range);
      let matches = findAll(/(?:\s|^)@screen\s+(?<screen>[^\s{]+)/g, text2);
      matches.forEach((match) => {
        if (state.screens.includes(match.groups.screen)) {
          return null;
        }
        let message = `The screen '${match.groups.screen}' does not exist in your theme config.`;
        let suggestions = [];
        let suggestion = closest(match.groups.screen, state.screens);
        if (suggestion) {
          suggestions.push(suggestion);
          message += ` Did you mean '${suggestion}'?`;
        }
        diagnostics.push({
          code: "invalidScreen",
          range: absoluteRange(
            {
              start: indexToPosition(
                text2,
                match.index + match[0].length - match.groups.screen.length
              ),
              end: indexToPosition(text2, match.index + match[0].length)
            },
            range
          ),
          severity: severity === "error" ? 1 : 2,
          message,
          suggestions
        });
      });
    });
    return diagnostics;
  }
  function getInvalidVariantDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidVariant;
    if (severity === "ignore")
      return [];
    if (gte(state.version, "2.99.0")) {
      return [];
    }
    let diagnostics = [];
    let ranges = [];
    if (isCssDoc(state, document3)) {
      ranges.push(void 0);
    } else {
      let boundaries = getLanguageBoundaries(state, document3);
      if (!boundaries)
        return [];
      ranges.push(...boundaries.filter((b2) => b2.type === "css").map(({ range }) => range));
    }
    let possibleVariants = state.variants.flatMap((variant) => {
      if (variant.values.length) {
        return variant.values.map(
          (value2) => value2 === "DEFAULT" ? variant.name : `${variant.name}${variant.hasDash ? "-" : ""}${value2}`
        );
      }
      return [variant.name];
    });
    if (state.jit) {
      possibleVariants.unshift("responsive");
      possibleVariants = possibleVariants.filter((v2) => !state.screens.includes(v2));
    }
    ranges.forEach((range) => {
      let text2 = getTextWithoutComments(document3, "css", range);
      let matches = findAll(/(?:\s|^)@variants\s+(?<variants>[^{]+)/g, text2);
      matches.forEach((match) => {
        let variants = match.groups.variants.split(/(\s*,\s*)/);
        let listStartIndex = match.index + match[0].length - match.groups.variants.length;
        for (let i2 = 0; i2 < variants.length; i2 += 2) {
          let variant = variants[i2].trim();
          if (possibleVariants.includes(variant)) {
            continue;
          }
          let message = `The variant '${variant}' does not exist.`;
          let suggestions = [];
          let suggestion = closest(variant, possibleVariants);
          if (suggestion) {
            suggestions.push(suggestion);
            message += ` Did you mean '${suggestion}'?`;
          }
          let variantStartIndex = listStartIndex + variants.slice(0, i2).join("").length;
          diagnostics.push({
            code: "invalidVariant",
            range: absoluteRange(
              {
                start: indexToPosition(text2, variantStartIndex),
                end: indexToPosition(text2, variantStartIndex + variant.length)
              },
              range
            ),
            severity: severity === "error" ? 1 : 2,
            message,
            suggestions
          });
        }
      });
    });
    return diagnostics;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  function stringToPath(string) {
    let result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, (match, number2, quote, subString) => {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
    });
    return result;
  }
  function pathToString(path) {
    if (typeof path === "string")
      return path;
    return path.reduce((acc, cur, i2) => {
      if (i2 === 0)
        return cur;
      if (cur.includes("."))
        return `${acc}[${cur}]`;
      return `${acc}.${cur}`;
    }, "");
  }
  function validateConfigPath(state, path, base = []) {
    let keys = Array.isArray(path) ? path : stringToPath(path);
    let fullPath = [...base, ...keys];
    let value2 = (0, import_dlv8.default)(state.config, fullPath);
    let suggestions = [];
    let transformThemeValue2 = state.modules?.transformThemeValue?.module ?? ((_2) => (value22) => value22);
    if (fullPath[0] === "theme" && fullPath[1]) {
      value2 = transformThemeValue2(fullPath[1])(value2);
    }
    function findAlternativePath() {
      let points = combinations("123456789".substr(0, keys.length - 1)).map(
        (x2) => x2.split("").map((x22) => parseInt(x22, 10))
      );
      let possibilities = points.map((p4) => {
        let result = [];
        let i2 = 0;
        p4.forEach((x2) => {
          result.push(keys.slice(i2, x2).join("."));
          i2 = x2;
        });
        result.push(keys.slice(i2).join("."));
        return result;
      }).slice(1);
      return possibilities.find((possibility) => validateConfigPath(state, possibility, base).isValid);
    }
    if (typeof value2 === "undefined") {
      let reason = `'${pathToString(path)}' does not exist in your theme config.`;
      let parentPath = [...base, ...keys.slice(0, keys.length - 1)];
      let parentValue = (0, import_dlv8.default)(state.config, parentPath);
      if (isObject3(parentValue)) {
        let closestValidKey = closest(
          keys[keys.length - 1],
          Object.keys(parentValue).filter(
            (key) => validateConfigPath(state, [...parentPath, key]).isValid
          )
        );
        if (closestValidKey) {
          suggestions.push(pathToString([...keys.slice(0, keys.length - 1), closestValidKey]));
          reason += ` Did you mean '${suggestions[0]}'?`;
        }
      } else {
        let altPath = findAlternativePath();
        if (altPath) {
          return {
            isValid: false,
            reason: `${reason} Did you mean '${pathToString(altPath)}'?`,
            suggestions: [pathToString(altPath)]
          };
        }
      }
      return {
        isValid: false,
        reason,
        suggestions
      };
    }
    if (!(typeof value2 === "string" || typeof value2 === "number" || value2 instanceof String || value2 instanceof Number || Array.isArray(value2) || typeof value2 === "function")) {
      let reason = `'${pathToString(path)}' was found but does not resolve to a valid theme value.`;
      if (isObject3(value2)) {
        let validKeys = Object.keys(value2).filter(
          (key) => validateConfigPath(state, [...keys, key], base).isValid
        );
        if (validKeys.length) {
          suggestions.push(...validKeys.map((validKey) => pathToString([...keys, validKey])));
          reason += ` Did you mean something like '${suggestions[0]}'?`;
        }
      }
      return {
        isValid: false,
        reason,
        suggestions
      };
    }
    let isValid = true;
    for (let i2 = keys.length - 1; i2 >= 0; i2--) {
      let key = keys[i2];
      let parentValue = (0, import_dlv8.default)(state.config, [...base, ...keys.slice(0, i2)]);
      if (/^[0-9]+$/.test(key)) {
        if (!isObject3(parentValue) && !Array.isArray(parentValue)) {
          isValid = false;
          break;
        }
      } else if (!isObject3(parentValue)) {
        isValid = false;
        break;
      }
    }
    if (!isValid) {
      let reason = `'${pathToString(path)}' does not exist in your theme config.`;
      let altPath = findAlternativePath();
      if (altPath) {
        return {
          isValid: false,
          reason: `${reason} Did you mean '${pathToString(altPath)}'?`,
          suggestions: [pathToString(altPath)]
        };
      }
      return {
        isValid: false,
        reason,
        suggestions: []
      };
    }
    return {
      isValid: true,
      value: value2
    };
  }
  function getInvalidConfigPathDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidConfigPath;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    findHelperFunctionsInDocument(state, document3).forEach((helperFn) => {
      let base = helperFn.helper === "theme" ? ["theme"] : [];
      let result = validateConfigPath(state, helperFn.path, base);
      if (result.isValid === true) {
        return;
      }
      diagnostics.push({
        code: "invalidConfigPath",
        range: helperFn.ranges.path,
        severity: severity === "error" ? 1 : 2,
        message: result.reason,
        suggestions: result.suggestions
      });
    });
    return diagnostics;
  }
  function getInvalidTailwindDirectiveDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidTailwindDirective;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    let ranges = [];
    if (isCssDoc(state, document3)) {
      ranges.push(void 0);
    } else {
      let boundaries = getLanguageBoundaries(state, document3);
      if (!boundaries)
        return [];
      ranges.push(...boundaries.filter((b2) => b2.type === "css").map(({ range }) => range));
    }
    let regex;
    if (isSemicolonlessCssLanguage(document3.languageId, state.editor?.userLanguages)) {
      regex = /(?:\s|^)@tailwind\s+(?<value>[^\r\n]+)/g;
    } else {
      regex = /(?:\s|^)@tailwind\s+(?<value>[^;]+)/g;
    }
    let hasVariantsDirective = state.jit && gte(state.version, "2.1.99");
    ranges.forEach((range) => {
      let text2 = getTextWithoutComments(document3, "css", range);
      let matches = findAll(regex, text2);
      let valid = [
        "utilities",
        "components",
        "screens",
        gte(state.version, "1.0.0-beta.1") ? "base" : "preflight",
        hasVariantsDirective && "variants"
      ].filter(Boolean);
      let suggestable = valid;
      if (hasVariantsDirective) {
        suggestable = suggestable.filter((value2) => value2 !== "screens");
      }
      matches.forEach((match) => {
        if (valid.includes(match.groups.value)) {
          return null;
        }
        let message = `'${match.groups.value}' is not a valid value.`;
        let suggestions = [];
        if (match.groups.value === "preflight") {
          suggestions.push("base");
          message += ` Did you mean 'base'?`;
        } else {
          let suggestion = closest(match.groups.value, suggestable);
          if (suggestion) {
            suggestions.push(suggestion);
            message += ` Did you mean '${suggestion}'?`;
          }
        }
        diagnostics.push({
          code: "invalidTailwindDirective",
          range: absoluteRange(
            {
              start: indexToPosition(text2, match.index + match[0].length - match.groups.value.length),
              end: indexToPosition(text2, match.index + match[0].length)
            },
            range
          ),
          severity: severity === "error" ? 1 : 2,
          message,
          suggestions
        });
      });
    });
    return diagnostics;
  }
  async function getRecommendedVariantOrderDiagnostics(state, document3, settings) {
    if (state.v4)
      return [];
    if (!state.jit)
      return [];
    if (gte(state.version, "2.99.0"))
      return [];
    let severity = settings.tailwindCSS.lint.recommendedVariantOrder;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    const classLists = await findClassListsInDocument(state, document3);
    classLists.forEach((classList) => {
      const classNames = getClassNamesInClassList(classList, state.blocklist);
      classNames.forEach((className) => {
        let { rules } = generateRules(state, [className.className]);
        if (rules.length === 0) {
          return;
        }
        let order = state.jitContext.variantOrder ?? state.jitContext.offsets.variantOffsets;
        let { variants, offset } = getVariantsFromClassName(state, className.className);
        let sortedVariants = [...variants].sort((a2, b2) => bigSign(order.get(b2) - order.get(a2)));
        if (!equalExact(variants, sortedVariants)) {
          diagnostics.push({
            code: "recommendedVariantOrder",
            suggestions: [
              [...sortedVariants, className.className.substr(offset)].join(state.separator)
            ],
            range: className.range,
            severity: severity === "error" ? 1 : 2,
            message: "Variants are not in the recommended order, which may cause unexpected CSS output."
          });
        }
      });
    });
    return diagnostics;
  }
  async function doValidate(state, document3, only = [
    "cssConflict",
    "invalidApply",
    "invalidScreen",
    "invalidVariant",
    "invalidConfigPath",
    "invalidTailwindDirective",
    "recommendedVariantOrder"
    /* RecommendedVariantOrder */
  ]) {
    const settings = await state.editor.getConfiguration(document3.uri);
    return settings.tailwindCSS.validate ? [
      ...only.includes(
        "cssConflict"
        /* CssConflict */
      ) ? await getCssConflictDiagnostics(state, document3, settings) : [],
      ...only.includes(
        "invalidApply"
        /* InvalidApply */
      ) ? await getInvalidApplyDiagnostics(state, document3, settings) : [],
      ...only.includes(
        "invalidScreen"
        /* InvalidScreen */
      ) ? getInvalidScreenDiagnostics(state, document3, settings) : [],
      ...only.includes(
        "invalidVariant"
        /* InvalidVariant */
      ) ? getInvalidVariantDiagnostics(state, document3, settings) : [],
      ...only.includes(
        "invalidConfigPath"
        /* InvalidConfigPath */
      ) ? getInvalidConfigPathDiagnostics(state, document3, settings) : [],
      ...only.includes(
        "invalidTailwindDirective"
        /* InvalidTailwindDirective */
      ) ? getInvalidTailwindDirectiveDiagnostics(state, document3, settings) : [],
      ...only.includes(
        "recommendedVariantOrder"
        /* RecommendedVariantOrder */
      ) ? await getRecommendedVariantOrderDiagnostics(state, document3, settings) : []
    ] : [];
  }
  async function doHover(state, document3, position2) {
    return await provideClassNameHover(state, document3, position2) || await provideCssHelperHover(state, document3, position2);
  }
  async function provideCssHelperHover(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    const settings = await state.editor.getConfiguration(document3.uri);
    let helperFns = findHelperFunctionsInRange(document3, {
      start: { line: position2.line, character: 0 },
      end: { line: position2.line + 1, character: 0 }
    });
    for (let helperFn of helperFns) {
      if (!isWithinRange(position2, helperFn.ranges.path))
        continue;
      let validated = validateConfigPath(
        state,
        helperFn.path,
        helperFn.helper === "theme" ? ["theme"] : []
      );
      let value2 = validated.isValid ? stringifyConfigValue(validated.value) : null;
      if (value2 === null)
        return null;
      if (settings.tailwindCSS.showPixelEquivalents) {
        value2 = addPixelEquivalentsToValue(value2, settings.tailwindCSS.rootFontSize);
      }
      return {
        contents: { kind: "markdown", value: ["```plaintext", value2, "```"].join("\n") },
        range: helperFn.ranges.path
      };
    }
    return null;
  }
  async function provideClassNameHover(state, document3, position2) {
    let className = await findClassNameAtPosition(state, document3, position2);
    if (className === null)
      return null;
    if (state.v4) {
      let root2 = state.designSystem.compile([className.className])[0];
      if (root2.nodes.length === 0) {
        return null;
      }
      return {
        contents: {
          language: "css",
          value: await stringifyRoot(state, root2, document3.uri)
        },
        range: className.range
      };
    }
    if (state.jit) {
      let { root: root2, rules } = generateRules(state, [className.className]);
      if (rules.length === 0) {
        return null;
      }
      return {
        contents: {
          language: "css",
          value: await stringifyRoot(state, root2, document3.uri)
        },
        range: className.range
      };
    }
    const parts = getClassNameParts(state, className.className);
    if (!parts)
      return null;
    if (isCssContext(state, document3, position2)) {
      let validated = validateApply(state, parts);
      if (validated === null || validated.isApplyable === false) {
        return null;
      }
    }
    const settings = await state.editor.getConfiguration(document3.uri);
    const css = stringifyCss(
      className.className,
      (0, import_dlv9.default)(state.classNames.classNames, [...parts, "__info"]),
      settings
    );
    if (!css)
      return null;
    return {
      contents: {
        language: "css",
        value: css
      },
      range: className.range
    };
  }
  function removeRangesFromString(str, rangeOrRanges) {
    let ranges = ensureArray(rangeOrRanges);
    let finder = (0, import_line_column2.default)(str + "\n", { origin: 0 });
    let indexRanges = [];
    ranges.forEach((range) => {
      let start = finder.toIndex(range.start.line, range.start.character);
      let end = finder.toIndex(range.end.line, range.end.character);
      for (let i22 = start - 1; i22 >= 0; i22--) {
        if (/\s/.test(str.charAt(i22))) {
          start = i22;
        } else {
          break;
        }
      }
      indexRanges.push({ start, end });
    });
    indexRanges.sort((a2, b2) => a2.start - b2.start);
    let result = "";
    let i2 = 0;
    indexRanges.forEach((indexRange) => {
      result += str.substring(i2, indexRange.start);
      i2 = indexRange.end;
    });
    result += str.substring(i2);
    return result.trim();
  }
  async function provideCssConflictCodeActions(_state, params, diagnostic) {
    return [
      {
        title: `Delete ${joinWithAnd(
          diagnostic.otherClassNames.map((otherClassName) => `'${otherClassName.className}'`)
        )}`,
        kind: "quickfix",
        // CodeActionKind.QuickFix,
        diagnostics: [diagnostic],
        edit: {
          changes: {
            [params.textDocument.uri]: [
              {
                range: diagnostic.className.classList.range,
                newText: removeRangesFromString(
                  diagnostic.className.classList.classList,
                  diagnostic.otherClassNames.map((otherClassName) => otherClassName.relativeRange)
                )
              }
            ]
          }
        }
      }
    ];
  }
  var IMPORTANT = /\s*!important\s*$/i;
  var unitless = {
    "box-flex": true,
    "box-flex-group": true,
    "column-count": true,
    flex: true,
    "flex-grow": true,
    "flex-positive": true,
    "flex-shrink": true,
    "flex-negative": true,
    "font-weight": true,
    "line-clamp": true,
    "line-height": true,
    opacity: true,
    order: true,
    orphans: true,
    "tab-size": true,
    widows: true,
    "z-index": true,
    zoom: true,
    "fill-opacity": true,
    "stroke-dashoffset": true,
    "stroke-opacity": true,
    "stroke-width": true
  };
  function dashify(str) {
    return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function decl2(parent, name, value2, postcss42) {
    if (value2 === false || value2 === null)
      return;
    name = dashify(name);
    if (typeof value2 === "number") {
      if (value2 === 0 || unitless[name]) {
        value2 = value2.toString();
      } else {
        value2 = value2.toString() + "px";
      }
    }
    if (name === "css-float")
      name = "float";
    if (IMPORTANT.test(value2)) {
      value2 = value2.replace(IMPORTANT, "");
      parent.push(postcss42.decl({ prop: name, value: value2, important: true }));
    } else {
      parent.push(postcss42.decl({ prop: name, value: value2 }));
    }
  }
  function atRule2(parent, parts, value2, postcss42) {
    var node = postcss42.atRule({ name: parts[1], params: parts[3] || "" });
    if (typeof value2 === "object") {
      node.nodes = [];
      parse22(value2, node, postcss42);
    }
    parent.push(node);
  }
  function parse22(obj, parent, postcss42) {
    var name, value2, node, i2;
    for (name in obj) {
      if (obj.hasOwnProperty(name)) {
        value2 = obj[name];
        if (value2 === null || typeof value2 === "undefined") {
          continue;
        } else if (name[0] === "@") {
          var parts = name.match(/@([^\s]+)(\s+([\w\W]*)\s*)?/);
          if (Array.isArray(value2)) {
            for (i2 = 0; i2 < value2.length; i2++) {
              atRule2(parent, parts, value2[i2], postcss42);
            }
          } else {
            atRule2(parent, parts, value2, postcss42);
          }
        } else if (Array.isArray(value2)) {
          for (i2 = 0; i2 < value2.length; i2++) {
            decl2(parent, name, value2[i2], postcss42);
          }
        } else if (typeof value2 === "object") {
          node = postcss42.rule({ selector: name });
          parse22(value2, node, postcss42);
          parent.push(node);
        } else {
          decl2(parent, name, value2, postcss42);
        }
      }
    }
  }
  function cssObjToAst(obj, postcss42) {
    var root2 = postcss42.root();
    parse22(obj, root2, postcss42);
    return root2;
  }
  async function provideInvalidApplyCodeActions(state, document3, diagnostic) {
    if (!document3)
      return [];
    let documentText = getTextWithoutComments(document3, "css");
    let cssRange;
    let cssText = documentText;
    const { postcss: postcss42 } = state.modules;
    let changes = [];
    let totalClassNamesInClassList = diagnostic.className.classList.classList.split(/\s+/).length;
    let className = diagnostic.className.className;
    let classNameParts = getClassNameParts(state, className);
    let classNameInfo = (0, import_dlv10.default)(state.classNames.classNames, classNameParts);
    if (Array.isArray(classNameInfo)) {
      return [];
    }
    if (!isCssDoc(state, document3)) {
      let languageBoundaries = getLanguageBoundaries(state, document3);
      if (!languageBoundaries)
        return [];
      cssRange = languageBoundaries.filter((b2) => b2.type === "css").find(({ range }) => isWithinRange(diagnostic.range.start, range))?.range;
      if (!cssRange)
        return [];
      cssText = getTextWithoutComments(document3, "css", cssRange);
    }
    try {
      await postcss42.module([
        // TODO: use plain function?
        // @ts-ignore
        postcss42.module.plugin("", (_options = {}) => {
          return (root2) => {
            root2.walkRules((rule2) => {
              if (changes.length)
                return false;
              rule2.walkAtRules("apply", (atRule22) => {
                let atRuleRange = postcssSourceToRange(atRule22.source);
                if (cssRange) {
                  atRuleRange = absoluteRange(atRuleRange, cssRange);
                }
                if (!isWithinRange(diagnostic.range.start, atRuleRange))
                  return void 0;
                let ast = classNameToAst(
                  state,
                  classNameParts,
                  rule2.selector,
                  diagnostic.className.classList.important
                );
                if (!ast)
                  return false;
                rule2.after(ast.nodes);
                let insertedRule = rule2.next();
                if (!insertedRule)
                  return false;
                if (totalClassNamesInClassList === 1) {
                  atRule22.remove();
                } else {
                  changes.push({
                    range: diagnostic.className.classList.range,
                    newText: removeRangesFromString(
                      diagnostic.className.classList.classList,
                      diagnostic.className.relativeRange
                    )
                  });
                }
                let ruleRange = postcssSourceToRange(rule2.source);
                if (cssRange) {
                  ruleRange = absoluteRange(ruleRange, cssRange);
                }
                let outputIndent;
                let documentIndent = detect_indent_default(cssText);
                changes.push({
                  range: ruleRange,
                  newText: rule2.toString() + (insertedRule.raws.before || "\n\n") + insertedRule.toString().replace(/\n\s*\n/g, "\n").replace(/(@apply [^;\n]+)$/gm, "$1;").replace(/([^\s^]){$/gm, "$1 {").replace(/^\s+/gm, (m2) => {
                    if (typeof outputIndent === "undefined")
                      outputIndent = m2;
                    return m2.replace(new RegExp(outputIndent, "g"), documentIndent.indent);
                  }).replace(/^(\s+)(.*?[^{}]\n)([^\s}])/gm, "$1$2$1$3")
                });
                return false;
              });
              return void 0;
            });
          };
        })
      ]).process(cssText, { from: void 0 });
    } catch (_2) {
      return [];
    }
    if (!changes.length) {
      return [];
    }
    return [
      {
        title: "Extract to new rule",
        kind: "quickfix",
        // CodeActionKind.QuickFix,
        diagnostics: [diagnostic],
        edit: {
          changes: {
            [document3.uri]: changes
          }
        }
      }
    ];
  }
  function postcssSourceToRange(source) {
    return {
      start: {
        line: source.start.line - 1,
        character: source.start.column - 1
      },
      end: {
        line: source.end.line - 1,
        character: source.end.column
      }
    };
  }
  function classNameToAst(state, classNameParts, selector, important = false) {
    const baseClassName = classNameParts[classNameParts.length - 1];
    const validatedBaseClassName = validateApply(state, [baseClassName]);
    if (validatedBaseClassName === null || validatedBaseClassName.isApplyable === false) {
      return null;
    }
    const meta = getClassNameMeta(state, classNameParts);
    if (Array.isArray(meta))
      return null;
    let context = meta.context;
    let pseudo = meta.pseudo;
    const globalContexts = state.classNames.context;
    const path = [];
    for (let i2 = 0; i2 < classNameParts.length - 1; i2++) {
      let part = classNameParts[i2];
      let common = globalContexts[part];
      if (!common)
        return null;
      if (state.screens.includes(part)) {
        path.push(`@screen ${part}`);
        context = context.filter((con) => !common.includes(con));
      }
    }
    path.push(...context);
    let obj = {};
    for (let i2 = 1; i2 <= path.length; i2++) {
      dset(obj, path.slice(0, i2), {});
    }
    selector = appendPseudosToSelector(selector, pseudo);
    if (selector === null)
      return null;
    let rule2 = {
      [selector]: {
        [`@apply ${baseClassName}${important ? " !important" : ""}`]: ""
      }
    };
    if (path.length) {
      dset(obj, path, rule2);
    } else {
      obj = rule2;
    }
    return cssObjToAst(obj, state.modules.postcss);
  }
  function appendPseudosToSelector(selector, pseudos) {
    if (pseudos.length === 0)
      return selector;
    let canTransform = true;
    let transformedSelector = (0, import_postcss_selector_parser.default)((selectors) => {
      flatten(selectors.split((_2) => true)).forEach((sel) => {
        for (let i2 = sel.nodes.length - 1; i2 >= 0; i2--) {
          if (sel.nodes[i2].type !== "pseudo") {
            break;
          } else if (pseudos.includes(sel.nodes[i2].value)) {
            canTransform = false;
            break;
          }
        }
        if (canTransform) {
          pseudos.forEach((p4) => {
            sel.append(import_postcss_selector_parser.default.pseudo({ value: p4 }));
          });
        }
      });
    }).processSync(selector);
    if (!canTransform)
      return null;
    return transformedSelector;
  }
  function provideSuggestionCodeActions(_state, params, diagnostic) {
    return diagnostic.suggestions.map((suggestion) => ({
      title: `Replace with '${suggestion}'`,
      kind: "quickfix",
      // CodeActionKind.QuickFix,
      diagnostics: [diagnostic],
      edit: {
        changes: {
          [params.textDocument.uri]: [
            {
              range: diagnostic.range,
              newText: suggestion
            }
          ]
        }
      }
    }));
  }
  async function getDiagnosticsFromCodeActionParams(state, params, document3, only) {
    if (!document3)
      return [];
    let diagnostics = await doValidate(state, document3, only);
    return params.context.diagnostics.map((diagnostic) => {
      return diagnostics.find((d2) => {
        return d2.code === diagnostic.code && d2.message === diagnostic.message && rangesEqual(d2.range, diagnostic.range);
      });
    }).filter(Boolean);
  }
  async function doCodeActions(state, params, document3) {
    if (!state.enabled) {
      return [];
    }
    let diagnostics = await getDiagnosticsFromCodeActionParams(
      state,
      params,
      document3,
      params.context.diagnostics.map((diagnostic) => diagnostic.code).filter(Boolean)
    );
    return Promise.all(
      diagnostics.map((diagnostic) => {
        if (isInvalidApplyDiagnostic(diagnostic)) {
          return provideInvalidApplyCodeActions(state, document3, diagnostic);
        }
        if (isCssConflictDiagnostic(diagnostic)) {
          return provideCssConflictCodeActions(state, params, diagnostic);
        }
        if (isInvalidConfigPathDiagnostic(diagnostic) || isInvalidTailwindDirectiveDiagnostic(diagnostic) || isInvalidScreenDiagnostic(diagnostic) || isInvalidVariantDiagnostic(diagnostic) || isRecommendedVariantOrderDiagnostic(diagnostic)) {
          return provideSuggestionCodeActions(state, params, diagnostic);
        }
        return [];
      })
    ).then(flatten).then((x2) => dedupeBy(x2, (item) => JSON.stringify(item.edit)));
  }
  async function getDocumentColors(state, document3) {
    let colors = [];
    if (!state.enabled)
      return colors;
    let settings = await state.editor.getConfiguration(document3.uri);
    if (settings.tailwindCSS.colorDecorators === false)
      return colors;
    let classLists = await findClassListsInDocument(state, document3);
    classLists.forEach((classList) => {
      let classNames = getClassNamesInClassList(classList, state.blocklist);
      classNames.forEach((className) => {
        let color2 = getColor(state, className.className);
        if (color2 === null || typeof color2 === "string" || (color2.alpha ?? 1) === 0) {
          return;
        }
        colors.push({
          range: className.range,
          color: culoriColorToVscodeColor(color2)
        });
      });
    });
    let helperFns = findHelperFunctionsInDocument(state, document3);
    helperFns.forEach((fn5) => {
      let keys = stringToPath(fn5.path);
      let base = fn5.helper === "theme" ? ["theme"] : [];
      let value2 = (0, import_dlv11.default)(state.config, [...base, ...keys]);
      let color2 = getColorFromValue(value2);
      if (color2 && typeof color2 !== "string" && (color2.alpha ?? 1) !== 0) {
        colors.push({ range: fn5.ranges.path, color: culoriColorToVscodeColor(color2) });
      }
    });
    return dedupeByRange(colors);
  }
  function parseObjectStyles(styles) {
    if (!Array.isArray(styles)) {
      return parseObjectStyles([styles]);
    }
    return styles.flatMap((style) => {
      return postcss_default([
        (0, import_postcss_nested.default)({
          bubble: ["screen"]
        })
      ]).process(style, {
        parser: postcss_js_default
      }).root.nodes;
    });
  }
  function isPlainObject(value2) {
    if (Object.prototype.toString.call(value2) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value2);
    return prototype === null || Object.getPrototypeOf(prototype) === null;
  }
  function prefixSelector_default(prefix3, selector, prependNegative = false) {
    if (prefix3 === "") {
      return selector;
    }
    let ast = typeof selector === "string" ? (0, import_postcss_selector_parser5.default)().astSync(selector) : selector;
    ast.walkClasses((classSelector) => {
      let baseClass = classSelector.value;
      let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith("-");
      classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix3}${baseClass.slice(1)}` : `${prefix3}${baseClass}`;
    });
    return typeof selector === "string" ? ast.toString() : ast;
  }
  function escapeCommas(className) {
    return className.replace(/\\,/g, "\\2c ");
  }
  var colorNames_default = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
  var SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
  var VALUE = /(?:\d+|\d*\.\d+)%?/;
  var SEP = /(?:\s*,\s*|\s+)/;
  var ALPHA_SEP = /\s*[,/]\s*/;
  var CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/;
  var RGB = new RegExp(
    `^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
  );
  var HSL = new RegExp(
    `^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
  );
  function parseColor(value2, { loose = false } = {}) {
    if (typeof value2 !== "string") {
      return null;
    }
    value2 = value2.trim();
    if (value2 === "transparent") {
      return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
    }
    if (value2 in colorNames_default) {
      return { mode: "rgb", color: colorNames_default[value2].map((v2) => v2.toString()) };
    }
    let hex2 = value2.replace(SHORT_HEX, (_2, r3, g2, b2, a2) => ["#", r3, r3, g2, g2, b2, b2, a2 ? a2 + a2 : ""].join("")).match(HEX);
    if (hex2 !== null) {
      return {
        mode: "rgb",
        color: [parseInt(hex2[1], 16), parseInt(hex2[2], 16), parseInt(hex2[3], 16)].map(
          (v2) => v2.toString()
        ),
        alpha: hex2[4] ? (parseInt(hex2[4], 16) / 255).toString() : void 0
      };
    }
    let match = value2.match(RGB) ?? value2.match(HSL);
    if (match === null) {
      return null;
    }
    let color2 = [match[2], match[3], match[4]].filter(Boolean).map((v2) => v2.toString());
    if (color2.length === 2 && color2[0].startsWith("var(")) {
      return {
        mode: match[1],
        color: [color2[0]],
        alpha: color2[1]
      };
    }
    if (!loose && color2.length !== 3) {
      return null;
    }
    if (color2.length < 3 && !color2.some((part) => /^var\(.*?\)$/.test(part))) {
      return null;
    }
    return {
      mode: match[1],
      color: color2,
      alpha: match[5]?.toString?.()
    };
  }
  function formatColor2({ mode, color: color2, alpha }) {
    let hasAlpha = alpha !== void 0;
    if (mode === "rgba" || mode === "hsla") {
      return `${mode}(${color2.join(", ")}${hasAlpha ? `, ${alpha}` : ""})`;
    }
    return `${mode}(${color2.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
  }
  function withAlphaValue(color2, alphaValue, defaultValue) {
    if (typeof color2 === "function") {
      return color2({ opacityValue: alphaValue });
    }
    let parsed = parseColor(color2, { loose: true });
    if (parsed === null) {
      return defaultValue;
    }
    return formatColor2({ ...parsed, alpha: alphaValue });
  }
  function withAlphaVariable({ color: color2, property, variable }) {
    let properties = [].concat(property);
    if (typeof color2 === "function") {
      return {
        [variable]: "1",
        ...Object.fromEntries(
          properties.map((p4) => {
            return [p4, color2({ opacityVariable: variable, opacityValue: `var(${variable})` })];
          })
        )
      };
    }
    const parsed = parseColor(color2);
    if (parsed === null) {
      return Object.fromEntries(properties.map((p4) => [p4, color2]));
    }
    if (parsed.alpha !== void 0) {
      return Object.fromEntries(properties.map((p4) => [p4, color2]));
    }
    return {
      [variable]: "1",
      ...Object.fromEntries(
        properties.map((p4) => {
          return [p4, formatColor2({ ...parsed, alpha: `var(${variable})` })];
        })
      )
    };
  }
  function splitAtTopLevelOnly2(input, separator) {
    let stack = [];
    let parts = [];
    let lastPos = 0;
    let isEscaped = false;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (stack.length === 0 && char === separator[0] && !isEscaped) {
        if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
          parts.push(input.slice(lastPos, idx));
          lastPos = idx + separator.length;
        }
      }
      if (isEscaped) {
        isEscaped = false;
      } else if (char === "\\") {
        isEscaped = true;
      }
      if (char === "(" || char === "[" || char === "{") {
        stack.push(char);
      } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
        stack.pop();
      }
    }
    parts.push(input.slice(lastPos));
    return parts;
  }
  var KEYWORDS = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
  var SPACE = /\ +(?![^(]*\))/g;
  var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
  function parseBoxShadowValue(input) {
    let shadows = splitAtTopLevelOnly2(input, ",");
    return shadows.map((shadow2) => {
      let value2 = shadow2.trim();
      let result = { raw: value2 };
      let parts = value2.split(SPACE);
      let seen = /* @__PURE__ */ new Set();
      for (let part of parts) {
        LENGTH.lastIndex = 0;
        if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
          result.keyword = part;
          seen.add("KEYWORD");
        } else if (LENGTH.test(part)) {
          if (!seen.has("X")) {
            result.x = part;
            seen.add("X");
          } else if (!seen.has("Y")) {
            result.y = part;
            seen.add("Y");
          } else if (!seen.has("BLUR")) {
            result.blur = part;
            seen.add("BLUR");
          } else if (!seen.has("SPREAD")) {
            result.spread = part;
            seen.add("SPREAD");
          }
        } else {
          if (!result.color) {
            result.color = part;
          } else {
            if (!result.unknown) result.unknown = [];
            result.unknown.push(part);
          }
        }
      }
      result.valid = result.x !== void 0 && result.y !== void 0;
      return result;
    });
  }
  function formatBoxShadowValue(shadows) {
    return shadows.map((shadow2) => {
      if (!shadow2.valid) {
        return shadow2.raw;
      }
      return [shadow2.keyword, shadow2.x, shadow2.y, shadow2.blur, shadow2.spread, shadow2.color].filter(Boolean).join(" ");
    }).join(", ");
  }
  var cssFunctions = ["min", "max", "clamp", "calc"];
  function isCSSFunction(value2) {
    return cssFunctions.some((fn5) => new RegExp(`^${fn5}\\(.*\\)`).test(value2));
  }
  var AUTO_VAR_INJECTION_EXCEPTIONS = /* @__PURE__ */ new Set([
    // Concrete properties
    "scroll-timeline-name",
    "timeline-scope",
    "view-timeline-name",
    "font-palette",
    // Shorthand properties
    "scroll-timeline",
    "animation-timeline",
    "view-timeline"
  ]);
  function normalize2(value2, context = null, isRoot2 = true) {
    let isVarException = context && AUTO_VAR_INJECTION_EXCEPTIONS.has(context.property);
    if (value2.startsWith("--") && !isVarException) {
      return `var(${value2})`;
    }
    if (value2.includes("url(")) {
      return value2.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
        if (/^url\(.*?\)$/.test(part)) {
          return part;
        }
        return normalize2(part, context, false);
      }).join("");
    }
    value2 = value2.replace(
      /([^\\])_+/g,
      (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)
    ).replace(/^_/g, " ").replace(/\\_/g, "_");
    if (isRoot2) {
      value2 = value2.trim();
    }
    value2 = normalizeMathOperatorSpacing(value2);
    return value2;
  }
  function normalizeMathOperatorSpacing(value2) {
    let preventFormattingInFunctions = ["theme"];
    let preventFormattingKeywords = [
      "min-content",
      "max-content",
      "fit-content",
      // Env
      "safe-area-inset-top",
      "safe-area-inset-right",
      "safe-area-inset-bottom",
      "safe-area-inset-left",
      "titlebar-area-x",
      "titlebar-area-y",
      "titlebar-area-width",
      "titlebar-area-height",
      "keyboard-inset-top",
      "keyboard-inset-right",
      "keyboard-inset-bottom",
      "keyboard-inset-left",
      "keyboard-inset-width",
      "keyboard-inset-height"
    ];
    return value2.replace(/(calc|min|max|clamp)\(.+\)/g, (match) => {
      let result = "";
      function lastChar() {
        let char = result.trimEnd();
        return char[char.length - 1];
      }
      for (let i2 = 0; i2 < match.length; i2++) {
        let peek = function(word) {
          return word.split("").every((char2, j2) => match[i2 + j2] === char2);
        }, consumeUntil = function(chars) {
          let minIndex = Infinity;
          for (let char2 of chars) {
            let index2 = match.indexOf(char2, i2);
            if (index2 !== -1 && index2 < minIndex) {
              minIndex = index2;
            }
          }
          let result2 = match.slice(i2, minIndex);
          i2 += result2.length - 1;
          return result2;
        };
        let char = match[i2];
        if (peek("var")) {
          result += consumeUntil([")", ","]);
        } else if (preventFormattingKeywords.some((keyword) => peek(keyword))) {
          let keyword = preventFormattingKeywords.find((keyword2) => peek(keyword2));
          result += keyword;
          i2 += keyword.length - 1;
        } else if (preventFormattingInFunctions.some((fn5) => peek(fn5))) {
          result += consumeUntil([")"]);
        } else if (["+", "-", "*", "/"].includes(char) && !["(", "+", "-", "*", "/"].includes(lastChar())) {
          result += ` ${char} `;
        } else {
          result += char;
        }
      }
      return result.replace(/\s+/g, " ");
    });
  }
  function url(value2) {
    return value2.startsWith("url(");
  }
  function number(value2) {
    return !isNaN(Number(value2)) || isCSSFunction(value2);
  }
  function percentage(value2) {
    return value2.endsWith("%") && number(value2.slice(0, -1)) || isCSSFunction(value2);
  }
  var lengthUnits = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ];
  var lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
  function length(value2) {
    return value2 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value2) || isCSSFunction(value2);
  }
  var lineWidths = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
  function lineWidth(value2) {
    return lineWidths.has(value2);
  }
  function shadow(value2) {
    let parsedShadows = parseBoxShadowValue(normalize2(value2));
    for (let parsedShadow of parsedShadows) {
      if (!parsedShadow.valid) {
        return false;
      }
    }
    return true;
  }
  function color(value2) {
    let colors = 0;
    let result = splitAtTopLevelOnly2(value2, "_").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var(")) return true;
      if (parseColor(part, { loose: true }) !== null) return colors++, true;
      return false;
    });
    if (!result) return false;
    return colors > 0;
  }
  function image(value2) {
    let images = 0;
    let result = splitAtTopLevelOnly2(value2, ",").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var(")) return true;
      if (url(part) || gradient(part) || ["element(", "image(", "cross-fade(", "image-set("].some((fn5) => part.startsWith(fn5))) {
        images++;
        return true;
      }
      return false;
    });
    if (!result) return false;
    return images > 0;
  }
  var gradientTypes = /* @__PURE__ */ new Set([
    "conic-gradient",
    "linear-gradient",
    "radial-gradient",
    "repeating-conic-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient"
  ]);
  function gradient(value2) {
    value2 = normalize2(value2);
    for (let type of gradientTypes) {
      if (value2.startsWith(`${type}(`)) {
        return true;
      }
    }
    return false;
  }
  var validPositions = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
  function position(value2) {
    let positions = 0;
    let result = splitAtTopLevelOnly2(value2, "_").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var(")) return true;
      if (validPositions.has(part) || length(part) || percentage(part)) {
        positions++;
        return true;
      }
      return false;
    });
    if (!result) return false;
    return positions > 0;
  }
  function familyName(value2) {
    let fonts = 0;
    let result = splitAtTopLevelOnly2(value2, ",").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var(")) return true;
      if (part.includes(" ")) {
        if (!/(['"])([^"']+)\1/g.test(part)) {
          return false;
        }
      }
      if (/^\d/g.test(part)) {
        return false;
      }
      fonts++;
      return true;
    });
    if (!result) return false;
    return fonts > 0;
  }
  var genericNames = /* @__PURE__ */ new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
  ]);
  function genericName(value2) {
    return genericNames.has(value2);
  }
  var absoluteSizes = /* @__PURE__ */ new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
  ]);
  function absoluteSize(value2) {
    return absoluteSizes.has(value2);
  }
  var relativeSizes = /* @__PURE__ */ new Set(["larger", "smaller"]);
  function relativeSize(value2) {
    return relativeSizes.has(value2);
  }
  function negateValue(value2) {
    value2 = `${value2}`;
    if (value2 === "0") {
      return "0";
    }
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value2)) {
      return value2.replace(/^[+-]?/, (sign) => sign === "-" ? "" : "-");
    }
    let numericFunctions = ["var", "calc", "min", "max", "clamp"];
    for (const fn5 of numericFunctions) {
      if (value2.includes(`${fn5}(`)) {
        return `calc(${value2} * -1)`;
      }
    }
  }
  function backgroundSize(value2) {
    let keywordValues = ["cover", "contain"];
    return splitAtTopLevelOnly2(value2, ",").every((part) => {
      let sizes = splitAtTopLevelOnly2(part, "_").filter(Boolean);
      if (sizes.length === 1 && keywordValues.includes(sizes[0])) return true;
      if (sizes.length !== 1 && sizes.length !== 2) return false;
      return sizes.every((size) => length(size) || percentage(size) || size === "auto");
    });
  }
  var picocolors_default = {
    yellow: (input) => input
  };
  function log() {
  }
  function dim(input) {
    return input;
  }
  var log_default = {
    info: log,
    warn: log,
    risk: log
  };
  var defaults = {
    optimizeUniversalDefaults: false,
    generalizedModifiers: true,
    get disableColorOpacityUtilitiesByDefault() {
      return void 0;
    },
    get relativeContentPathsByDefault() {
      return void 0;
    }
  };
  var featureFlags = {
    future: [
      "hoverOnlyWhenSupported",
      "respectDefaultRingColorOpacity",
      "disableColorOpacityUtilitiesByDefault",
      "relativeContentPathsByDefault"
    ],
    experimental: [
      "optimizeUniversalDefaults",
      "generalizedModifiers"
    ]
  };
  function flagEnabled2(config, flag) {
    if (featureFlags.future.includes(flag)) {
      return config.future === "all" || (config?.future?.[flag] ?? defaults[flag] ?? false);
    }
    if (featureFlags.experimental.includes(flag)) {
      return config.experimental === "all" || (config?.experimental?.[flag] ?? defaults[flag] ?? false);
    }
    return false;
  }
  function experimentalFlagsEnabled(config) {
    if (config.experimental === "all") {
      return featureFlags.experimental;
    }
    return Object.keys(config?.experimental ?? {}).filter(
      (flag) => featureFlags.experimental.includes(flag) && config.experimental[flag]
    );
  }
  function issueFlagNotices(config) {
    if (true) {
      return;
    }
    if (experimentalFlagsEnabled(config).length > 0) {
      let changes = experimentalFlagsEnabled(config).map((s2) => picocolors_default.yellow(s2)).join(", ");
      log_default.warn("experimental-flags-enabled", [
        `You have enabled experimental features: ${changes}`,
        "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
      ]);
    }
  }
  function updateAllClasses(selectors, updateClass) {
    selectors.walkClasses((sel) => {
      sel.value = updateClass(sel.value);
      if (sel.raws && sel.raws.value) {
        sel.raws.value = escapeCommas(sel.raws.value);
      }
    });
  }
  function resolveArbitraryValue(modifier, validate) {
    if (!isArbitraryValue(modifier)) {
      return void 0;
    }
    let value2 = modifier.slice(1, -1);
    if (!validate(value2)) {
      return void 0;
    }
    return normalize2(value2);
  }
  function asNegativeValue(modifier, lookup = {}, validate) {
    let positiveValue = lookup[modifier];
    if (positiveValue !== void 0) {
      return negateValue(positiveValue);
    }
    if (isArbitraryValue(modifier)) {
      let resolved = resolveArbitraryValue(modifier, validate);
      if (resolved === void 0) {
        return void 0;
      }
      return negateValue(resolved);
    }
  }
  function asValue(modifier, options = {}, { validate = () => true } = {}) {
    let value2 = options.values?.[modifier];
    if (value2 !== void 0) {
      return value2;
    }
    if (options.supportsNegativeValues && modifier.startsWith("-")) {
      return asNegativeValue(modifier.slice(1), options.values, validate);
    }
    return resolveArbitraryValue(modifier, validate);
  }
  function isArbitraryValue(input) {
    return input.startsWith("[") && input.endsWith("]");
  }
  function splitUtilityModifier(modifier) {
    let slashIdx = modifier.lastIndexOf("/");
    if (slashIdx === -1 || slashIdx === modifier.length - 1) {
      return [modifier, void 0];
    }
    let arbitrary = isArbitraryValue(modifier);
    if (arbitrary && !modifier.includes("]/[")) {
      return [modifier, void 0];
    }
    return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];
  }
  function parseColorFormat(value2) {
    if (typeof value2 === "string" && value2.includes("<alpha-value>")) {
      let oldValue = value2;
      return ({ opacityValue = 1 }) => oldValue.replace("<alpha-value>", opacityValue);
    }
    return value2;
  }
  function unwrapArbitraryModifier(modifier) {
    return normalize2(modifier.slice(1, -1));
  }
  function asColor(modifier, options = {}, { tailwindConfig = {} } = {}) {
    if (options.values?.[modifier] !== void 0) {
      return parseColorFormat(options.values?.[modifier]);
    }
    let [color2, alpha] = splitUtilityModifier(modifier);
    if (alpha !== void 0) {
      let normalizedColor = options.values?.[color2] ?? (isArbitraryValue(color2) ? color2.slice(1, -1) : void 0);
      if (normalizedColor === void 0) {
        return void 0;
      }
      normalizedColor = parseColorFormat(normalizedColor);
      if (isArbitraryValue(alpha)) {
        return withAlphaValue(normalizedColor, unwrapArbitraryModifier(alpha));
      }
      if (tailwindConfig.theme?.opacity?.[alpha] === void 0) {
        return void 0;
      }
      return withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);
    }
    return asValue(modifier, options, { validate: color });
  }
  function asLookupValue(modifier, options = {}) {
    return options.values?.[modifier];
  }
  function guess(validate) {
    return (modifier, options) => {
      return asValue(modifier, options, { validate });
    };
  }
  var typeMap = {
    any: asValue,
    color: asColor,
    url: guess(url),
    image: guess(image),
    length: guess(length),
    percentage: guess(percentage),
    position: guess(position),
    lookup: asLookupValue,
    "generic-name": guess(genericName),
    "family-name": guess(familyName),
    number: guess(number),
    "line-width": guess(lineWidth),
    "absolute-size": guess(absoluteSize),
    "relative-size": guess(relativeSize),
    shadow: guess(shadow),
    size: guess(backgroundSize)
  };
  var supportedTypes = Object.keys(typeMap);
  function splitAtFirst(input, delim) {
    let idx = input.indexOf(delim);
    if (idx === -1) return [void 0, input];
    return [input.slice(0, idx), input.slice(idx + 1)];
  }
  function coerceValue(types2, modifier, options, tailwindConfig) {
    if (options.values && modifier in options.values) {
      for (let { type } of types2 ?? []) {
        let result = typeMap[type](modifier, options, {
          tailwindConfig
        });
        if (result === void 0) {
          continue;
        }
        return [result, type, null];
      }
    }
    if (isArbitraryValue(modifier)) {
      let arbitraryValue = modifier.slice(1, -1);
      let [explicitType, value2] = splitAtFirst(arbitraryValue, ":");
      if (!/^[\w-_]+$/g.test(explicitType)) {
        value2 = arbitraryValue;
      } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
        return [];
      }
      if (value2.length > 0 && supportedTypes.includes(explicitType)) {
        return [asValue(`[${value2}]`, options), explicitType, null];
      }
    }
    let matches = getMatchingTypes(types2, modifier, options, tailwindConfig);
    for (let match of matches) {
      return match;
    }
    return [];
  }
  function* getMatchingTypes(types2, rawModifier, options, tailwindConfig) {
    let modifiersEnabled = flagEnabled2(tailwindConfig, "generalizedModifiers");
    let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
    let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
    if (!canUseUtilityModifier) {
      modifier = rawModifier;
      utilityModifier = void 0;
    }
    if (utilityModifier !== void 0 && modifier === "") {
      modifier = "DEFAULT";
    }
    if (utilityModifier !== void 0) {
      if (typeof options.modifiers === "object") {
        let configValue = options.modifiers?.[utilityModifier] ?? null;
        if (configValue !== null) {
          utilityModifier = configValue;
        } else if (isArbitraryValue(utilityModifier)) {
          utilityModifier = unwrapArbitraryModifier(utilityModifier);
        }
      }
    }
    for (let { type } of types2 ?? []) {
      let result = typeMap[type](modifier, options, {
        tailwindConfig
      });
      if (result === void 0) {
        continue;
      }
      yield [result, type, utilityModifier ?? null];
    }
  }
  var version = "3.3.5";
  var package_default = {
    name: "tailwindcss",
    version,
    description: "A utility-first CSS framework for rapidly building custom user interfaces.",
    license: "MIT",
    main: "lib/index.js",
    types: "types/index.d.ts",
    repository: "https://github.com/tailwindlabs/tailwindcss.git",
    bugs: "https://github.com/tailwindlabs/tailwindcss/issues",
    homepage: "https://tailwindcss.com",
    bin: {
      tailwind: "lib/cli.js",
      tailwindcss: "lib/cli.js"
    },
    tailwindcss: {
      engine: "stable"
    },
    scripts: {
      prebuild: "npm run generate && rimraf lib",
      build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`,
      postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
      "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
      style: "eslint .",
      pretest: "npm run generate",
      test: "jest",
      "test:integrations": "npm run test --prefix ./integrations",
      "install:integrations": "node scripts/install-integrations.js",
      "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
      "generate:types": "node -r @swc/register scripts/generate-types.js",
      generate: "npm run generate:plugin-list && npm run generate:types",
      "release-channel": "node ./scripts/release-channel.js",
      "release-notes": "node ./scripts/release-notes.js",
      prepublishOnly: "npm install --force && npm run build"
    },
    files: [
      "src/*",
      "cli/*",
      "lib/*",
      "peers/*",
      "scripts/*.js",
      "stubs/*",
      "nesting/*",
      "types/**/*",
      "*.d.ts",
      "*.css",
      "*.js"
    ],
    devDependencies: {
      "@swc/cli": "^0.1.62",
      "@swc/core": "^1.3.55",
      "@swc/jest": "^0.2.26",
      "@swc/register": "^0.1.10",
      autoprefixer: "^10.4.14",
      browserslist: "^4.21.5",
      concurrently: "^8.0.1",
      cssnano: "^6.0.0",
      esbuild: "^0.17.18",
      eslint: "^8.39.0",
      "eslint-config-prettier": "^8.8.0",
      "eslint-plugin-prettier": "^4.2.1",
      jest: "^29.6.0",
      "jest-diff": "^29.6.0",
      lightningcss: "1.18.0",
      prettier: "^2.8.8",
      rimraf: "^5.0.0",
      "source-map-js": "^1.0.2",
      turbo: "^1.9.3"
    },
    dependencies: {
      "@alloc/quick-lru": "^5.2.0",
      arg: "^5.0.2",
      chokidar: "^3.5.3",
      didyoumean: "^1.2.2",
      dlv: "^1.1.3",
      "fast-glob": "^3.3.0",
      "glob-parent": "^6.0.2",
      "is-glob": "^4.0.3",
      jiti: "^1.19.1",
      lilconfig: "^2.1.0",
      micromatch: "^4.0.5",
      "normalize-path": "^3.0.0",
      "object-hash": "^3.0.0",
      picocolors: "^1.0.0",
      postcss: "^8.4.23",
      "postcss-import": "^15.1.0",
      "postcss-js": "^4.0.1",
      "postcss-load-config": "^4.0.1",
      "postcss-nested": "^6.0.1",
      "postcss-selector-parser": "^6.0.11",
      resolve: "^1.22.2",
      sucrase: "^3.32.0"
    },
    browserslist: [
      "> 1%",
      "not edge <= 18",
      "not ie 11",
      "not op_mini all"
    ],
    jest: {
      testTimeout: 3e4,
      setupFilesAfterEnv: [
        "<rootDir>/jest/customMatchers.js"
      ],
      testPathIgnorePatterns: [
        "/node_modules/",
        "/integrations/",
        "/standalone-cli/",
        "\\.test\\.skip\\.js$"
      ],
      transformIgnorePatterns: [
        "node_modules/(?!lightningcss)"
      ],
      transform: {
        "\\.js$": "@swc/jest",
        "\\.ts$": "@swc/jest"
      }
    },
    engines: {
      node: ">=14.0.0"
    }
  };
  var env2 = typeof process !== "undefined" ? {
    NODE_ENV: "production",
    DEBUG: resolveDebug(void 0),
    ENGINE: package_default.tailwindcss.engine
  } : {
    NODE_ENV: "production",
    DEBUG: false,
    ENGINE: package_default.tailwindcss.engine
  };
  var NOT_ON_DEMAND = new String("*");
  var NONE = Symbol("__NONE__");
  function resolveDebug(debug) {
    if (debug === void 0) {
      return false;
    }
    if (debug === "true" || debug === "1") {
      return true;
    }
    if (debug === "false" || debug === "0") {
      return false;
    }
    if (debug === "*") {
      return true;
    }
    let debuggers = debug.split(",").map((d2) => d2.split(":")[0]);
    if (debuggers.includes("-tailwindcss")) {
      return false;
    }
    if (debuggers.includes("tailwindcss")) {
      return true;
    }
    return false;
  }
  function escapeClassName2(className) {
    let node = import_postcss_selector_parser7.default.className();
    node.value = className;
    return escapeCommas(node?.raws?.value ?? node.value);
  }
  var elementProperties = {
    // Pseudo elements from the spec
    "::after": ["terminal", "jumpable"],
    "::backdrop": ["terminal", "jumpable"],
    "::before": ["terminal", "jumpable"],
    "::cue": ["terminal"],
    "::cue-region": ["terminal"],
    "::first-letter": ["terminal", "jumpable"],
    "::first-line": ["terminal", "jumpable"],
    "::grammar-error": ["terminal"],
    "::marker": ["terminal", "jumpable"],
    "::part": ["terminal", "actionable"],
    "::placeholder": ["terminal", "jumpable"],
    "::selection": ["terminal", "jumpable"],
    "::slotted": ["terminal"],
    "::spelling-error": ["terminal"],
    "::target-text": ["terminal"],
    // Pseudo elements from the spec with special rules
    "::file-selector-button": ["terminal", "actionable"],
    // Library-specific pseudo elements used by component libraries
    // These are Shadow DOM-like
    "::deep": ["actionable"],
    "::v-deep": ["actionable"],
    "::ng-deep": ["actionable"],
    // Note: As a rule, double colons (::) should be used instead of a single colon
    // (:). This distinguishes pseudo-classes from pseudo-elements. However, since
    // this distinction was not present in older versions of the W3C spec, most
    // browsers support both syntaxes for the original pseudo-elements.
    ":after": ["terminal", "jumpable"],
    ":before": ["terminal", "jumpable"],
    ":first-letter": ["terminal", "jumpable"],
    ":first-line": ["terminal", "jumpable"],
    // The default value is used when the pseudo-element is not recognized
    // Because it's not recognized, we don't know if it's terminal or not
    // So we assume it can be moved AND can have user-action pseudo classes attached to it
    __default__: ["terminal", "actionable"]
  };
  function movePseudos(sel) {
    let [pseudos] = movablePseudos(sel);
    pseudos.forEach(([sel2, pseudo]) => sel2.removeChild(pseudo));
    sel.nodes.push(...pseudos.map(([, pseudo]) => pseudo));
    return sel;
  }
  function movablePseudos(sel) {
    let buffer = [];
    let lastSeenElement = null;
    for (let node of sel.nodes) {
      if (node.type === "combinator") {
        buffer = buffer.filter(([, node2]) => propertiesForPseudo(node2).includes("jumpable"));
        lastSeenElement = null;
      } else if (node.type === "pseudo") {
        if (isMovablePseudoElement(node)) {
          lastSeenElement = node;
          buffer.push([sel, node, null]);
        } else if (lastSeenElement && isAttachablePseudoClass(node, lastSeenElement)) {
          buffer.push([sel, node, lastSeenElement]);
        } else {
          lastSeenElement = null;
        }
        for (let sub of node.nodes ?? []) {
          let [movable, lastSeenElementInSub] = movablePseudos(sub);
          lastSeenElement = lastSeenElementInSub || lastSeenElement;
          buffer.push(...movable);
        }
      }
    }
    return [buffer, lastSeenElement];
  }
  function isPseudoElement(node) {
    return node.value.startsWith("::") || elementProperties[node.value] !== void 0;
  }
  function isMovablePseudoElement(node) {
    return isPseudoElement(node) && propertiesForPseudo(node).includes("terminal");
  }
  function isAttachablePseudoClass(node, pseudo) {
    if (node.type !== "pseudo") return false;
    if (isPseudoElement(node)) return false;
    return propertiesForPseudo(pseudo).includes("actionable");
  }
  function propertiesForPseudo(pseudo) {
    return elementProperties[pseudo.value] ?? elementProperties.__default__;
  }
  var MERGE = ":merge";
  function formatVariantSelector(formats, { context, candidate }) {
    let prefix3 = context?.tailwindConfig.prefix ?? "";
    let parsedFormats = formats.map((format) => {
      let ast = (0, import_postcss_selector_parser6.default)().astSync(format.format);
      return {
        ...format,
        ast: format.respectPrefix ? prefixSelector_default(prefix3, ast) : ast
      };
    });
    let formatAst = import_postcss_selector_parser6.default.root({
      nodes: [
        import_postcss_selector_parser6.default.selector({
          nodes: [import_postcss_selector_parser6.default.className({ value: escapeClassName2(candidate) })]
        })
      ]
    });
    for (let { ast } of parsedFormats) {
      ;
      [formatAst, ast] = handleMergePseudo(formatAst, ast);
      ast.walkNesting((nesting) => nesting.replaceWith(...formatAst.nodes[0].nodes));
      formatAst = ast;
    }
    return formatAst;
  }
  function simpleSelectorForNode(node) {
    let nodes = [];
    while (node.prev() && node.prev().type !== "combinator") {
      node = node.prev();
    }
    while (node && node.type !== "combinator") {
      nodes.push(node);
      node = node.next();
    }
    return nodes;
  }
  function resortSelector(sel) {
    sel.sort((a2, b2) => {
      if (a2.type === "tag" && b2.type === "class") {
        return -1;
      } else if (a2.type === "class" && b2.type === "tag") {
        return 1;
      } else if (a2.type === "class" && b2.type === "pseudo" && b2.value.startsWith("::")) {
        return -1;
      } else if (a2.type === "pseudo" && a2.value.startsWith("::") && b2.type === "class") {
        return 1;
      }
      return sel.index(a2) - sel.index(b2);
    });
    return sel;
  }
  function eliminateIrrelevantSelectors(sel, base) {
    let hasClassesMatchingCandidate = false;
    sel.walk((child) => {
      if (child.type === "class" && child.value === base) {
        hasClassesMatchingCandidate = true;
        return false;
      }
    });
    if (!hasClassesMatchingCandidate) {
      sel.remove();
    }
  }
  function finalizeSelector(current, formats, { context, candidate, base }) {
    let separator = context?.tailwindConfig?.separator ?? ":";
    base = base ?? splitAtTopLevelOnly2(candidate, separator).pop();
    let selector = (0, import_postcss_selector_parser6.default)().astSync(current);
    selector.walkClasses((node) => {
      if (node.raws && node.value.includes(base)) {
        node.raws.value = escapeClassName2((0, import_unesc.default)(node.raws.value));
      }
    });
    selector.each((sel) => eliminateIrrelevantSelectors(sel, base));
    if (selector.length === 0) {
      return null;
    }
    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, { context, candidate }) : formats;
    if (formatAst === null) {
      return selector.toString();
    }
    let simpleStart = import_postcss_selector_parser6.default.comment({ value: "/*__simple__*/" });
    let simpleEnd = import_postcss_selector_parser6.default.comment({ value: "/*__simple__*/" });
    selector.walkClasses((node) => {
      if (node.value !== base) {
        return;
      }
      let parent = node.parent;
      let formatNodes = formatAst.nodes[0].nodes;
      if (parent.nodes.length === 1) {
        node.replaceWith(...formatNodes);
        return;
      }
      let simpleSelector = simpleSelectorForNode(node);
      parent.insertBefore(simpleSelector[0], simpleStart);
      parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
      for (let child of formatNodes) {
        parent.insertBefore(simpleSelector[0], child.clone());
      }
      node.remove();
      simpleSelector = simpleSelectorForNode(simpleStart);
      let firstNode = parent.index(simpleStart);
      parent.nodes.splice(
        firstNode,
        simpleSelector.length,
        ...resortSelector(import_postcss_selector_parser6.default.selector({ nodes: simpleSelector })).nodes
      );
      simpleStart.remove();
      simpleEnd.remove();
    });
    selector.walkPseudos((p4) => {
      if (p4.value === MERGE) {
        p4.replaceWith(p4.nodes);
      }
    });
    selector.each((sel) => movePseudos(sel));
    return selector.toString();
  }
  function handleMergePseudo(selector, format) {
    let merges = [];
    selector.walkPseudos((pseudo) => {
      if (pseudo.value === MERGE) {
        merges.push({
          pseudo,
          value: pseudo.nodes[0].toString()
        });
      }
    });
    format.walkPseudos((pseudo) => {
      if (pseudo.value !== MERGE) {
        return;
      }
      let value2 = pseudo.nodes[0].toString();
      let existing = merges.find((merge) => merge.value === value2);
      if (!existing) {
        return;
      }
      let attachments = [];
      let next = pseudo.next();
      while (next && next.type !== "combinator") {
        attachments.push(next);
        next = next.next();
      }
      let combinator = next;
      existing.pseudo.parent.insertAfter(
        existing.pseudo,
        import_postcss_selector_parser6.default.selector({ nodes: attachments.map((node) => node.clone()) })
      );
      pseudo.remove();
      attachments.forEach((node) => node.remove());
      if (combinator && combinator.type === "combinator") {
        combinator.remove();
      }
    });
    return [selector, format];
  }
  function asClass(name) {
    return escapeCommas(`.${escapeClassName2(name)}`);
  }
  function nameClass(classPrefix, key) {
    return asClass(formatClass(classPrefix, key));
  }
  function formatClass(classPrefix, key) {
    if (key === "DEFAULT") {
      return classPrefix;
    }
    if (key === "-" || key === "-DEFAULT") {
      return `-${classPrefix}`;
    }
    if (key.startsWith("-")) {
      return `-${classPrefix}${key}`;
    }
    if (key.startsWith("/")) {
      return `${classPrefix}${key}`;
    }
    return `${classPrefix}-${key}`;
  }
  var preflight_default = "/*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box; /* 1 */\n  border-width: 0; /* 2 */\n  border-style: solid; /* 2 */\n  border-color: theme('borderColor.DEFAULT', currentColor); /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: '';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user's configured `sans` font-family by default.\n5. Use the user's configured `sans` font-feature-settings by default.\n6. Use the user's configured `sans` font-variation-settings by default.\n*/\n\nhtml {\n  line-height: 1.5; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n  -moz-tab-size: 4; /* 3 */\n  tab-size: 4; /* 3 */\n  font-family: theme('fontFamily.sans', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"); /* 4 */\n  font-feature-settings: theme('fontFamily.sans[1].fontFeatureSettings', normal); /* 5 */\n  font-variation-settings: theme('fontFamily.sans[1].fontVariationSettings', normal); /* 6 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0; /* 1 */\n  line-height: inherit; /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0; /* 1 */\n  color: inherit; /* 2 */\n  border-top-width: 1px; /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user's configured `mono` font family by default.\n2. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: theme('fontFamily.mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace); /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0; /* 1 */\n  border-color: inherit; /* 2 */\n  border-collapse: collapse; /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-feature-settings: inherit; /* 1 */\n  font-variation-settings: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  font-weight: inherit; /* 1 */\n  line-height: inherit; /* 1 */\n  color: inherit; /* 1 */\n  margin: 0; /* 2 */\n  padding: 0; /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n  -webkit-appearance: button; /* 1 */\n  background-color: transparent; /* 2 */\n  background-image: none; /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nReset default styling for dialogs.\n*/\ndialog {\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user's configured gray 400 color.\n*/\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1; /* 1 */\n  color: theme('colors.gray.400', #9ca3af); /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role=\"button\"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don't get the pointer cursor.\n*/\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block; /* 1 */\n  vertical-align: middle; /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n[hidden] {\n  display: none;\n}\n";
  var fs_default = {
    // Reading the preflight CSS is the only use of fs at the moment of writing.
    readFileSync: () => preflight_default
  };
  function transformThemeValue(themeSection) {
    if (["fontSize", "outline"].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function") value2 = value2({});
        if (Array.isArray(value2)) value2 = value2[0];
        return value2;
      };
    }
    if (themeSection === "fontFamily") {
      return (value2) => {
        if (typeof value2 === "function") value2 = value2({});
        let families = Array.isArray(value2) && isPlainObject(value2[1]) ? value2[0] : value2;
        return Array.isArray(families) ? families.join(", ") : families;
      };
    }
    if ([
      "boxShadow",
      "transitionProperty",
      "transitionDuration",
      "transitionDelay",
      "transitionTimingFunction",
      "backgroundImage",
      "backgroundSize",
      "backgroundColor",
      "cursor",
      "animation"
    ].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function") value2 = value2({});
        if (Array.isArray(value2)) value2 = value2.join(", ");
        return value2;
      };
    }
    if (["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function") value2 = value2({});
        if (typeof value2 === "string") value2 = postcss_default.list.comma(value2).join(" ");
        return value2;
      };
    }
    return (value2, opts = {}) => {
      if (typeof value2 === "function") {
        value2 = value2(opts);
      }
      return value2;
    };
  }
  var join = () => "";
  function createUtilityPlugin(themeKey, utilityVariations = [[themeKey, [themeKey]]], { filterDefault = false, ...options } = {}) {
    let transformValue = transformThemeValue(themeKey);
    return function({ matchUtilities, theme }) {
      for (let utilityVariation of utilityVariations) {
        let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [utilityVariation];
        matchUtilities(
          group.reduce((obj, [classPrefix, properties]) => {
            return Object.assign(obj, {
              [classPrefix]: (value2) => {
                return properties.reduce((obj2, name) => {
                  if (Array.isArray(name)) {
                    return Object.assign(obj2, { [name[0]]: name[1] });
                  }
                  return Object.assign(obj2, { [name]: transformValue(value2) });
                }, {});
              }
            });
          }, {}),
          {
            ...options,
            values: filterDefault ? Object.fromEntries(
              Object.entries(theme(themeKey) ?? {}).filter(([modifier]) => modifier !== "DEFAULT")
            ) : theme(themeKey)
          }
        );
      }
    };
  }
  function buildMediaQuery(screens) {
    screens = Array.isArray(screens) ? screens : [screens];
    return screens.map((screen) => {
      let values = screen.values.map((screen2) => {
        if (screen2.raw !== void 0) {
          return screen2.raw;
        }
        return [
          screen2.min && `(min-width: ${screen2.min})`,
          screen2.max && `(max-width: ${screen2.max})`
        ].filter(Boolean).join(" and ");
      });
      return screen.not ? `not all and ${values}` : values;
    }).join(", ");
  }
  var DIRECTIONS = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
  var PLAY_STATES = /* @__PURE__ */ new Set(["running", "paused"]);
  var FILL_MODES = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
  var ITERATION_COUNTS = /* @__PURE__ */ new Set(["infinite"]);
  var TIMINGS = /* @__PURE__ */ new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
  ]);
  var TIMING_FNS = ["cubic-bezier", "steps"];
  var COMMA = /\,(?![^(]*\))/g;
  var SPACE2 = /\ +(?![^(]*\))/g;
  var TIME = /^(-?[\d.]+m?s)$/;
  var DIGIT = /^(\d+)$/;
  function parseAnimationValue(input) {
    let animations = input.split(COMMA);
    return animations.map((animation) => {
      let value2 = animation.trim();
      let result = { value: value2 };
      let parts = value2.split(SPACE2);
      let seen = /* @__PURE__ */ new Set();
      for (let part of parts) {
        if (!seen.has("DIRECTIONS") && DIRECTIONS.has(part)) {
          result.direction = part;
          seen.add("DIRECTIONS");
        } else if (!seen.has("PLAY_STATES") && PLAY_STATES.has(part)) {
          result.playState = part;
          seen.add("PLAY_STATES");
        } else if (!seen.has("FILL_MODES") && FILL_MODES.has(part)) {
          result.fillMode = part;
          seen.add("FILL_MODES");
        } else if (!seen.has("ITERATION_COUNTS") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {
          result.iterationCount = part;
          seen.add("ITERATION_COUNTS");
        } else if (!seen.has("TIMING_FUNCTION") && TIMINGS.has(part)) {
          result.timingFunction = part;
          seen.add("TIMING_FUNCTION");
        } else if (!seen.has("TIMING_FUNCTION") && TIMING_FNS.some((f5) => part.startsWith(`${f5}(`))) {
          result.timingFunction = part;
          seen.add("TIMING_FUNCTION");
        } else if (!seen.has("DURATION") && TIME.test(part)) {
          result.duration = part;
          seen.add("DURATION");
        } else if (!seen.has("DELAY") && TIME.test(part)) {
          result.delay = part;
          seen.add("DELAY");
        } else if (!seen.has("NAME")) {
          result.name = part;
          seen.add("NAME");
        } else {
          if (!result.unknown) result.unknown = [];
          result.unknown.push(part);
        }
      }
      return result;
    });
  }
  var flattenColorPalette = (colors) => Object.assign(
    {},
    ...Object.entries(colors ?? {}).flatMap(
      ([color2, values]) => typeof values == "object" ? Object.entries(flattenColorPalette(values)).map(([number2, hex2]) => ({
        [color2 + (number2 === "DEFAULT" ? "" : `-${number2}`)]: hex2
      })) : [{ [`${color2}`]: values }]
    )
  );
  var flattenColorPalette_default = flattenColorPalette;
  function toColorValue(maybeFunction) {
    return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
  }
  function normalizeScreens(screens, root2 = true) {
    if (Array.isArray(screens)) {
      return screens.map((screen) => {
        if (root2 && Array.isArray(screen)) {
          throw new Error("The tuple syntax is not supported for `screens`.");
        }
        if (typeof screen === "string") {
          return { name: screen.toString(), not: false, values: [{ min: screen, max: void 0 }] };
        }
        let [name, options] = screen;
        name = name.toString();
        if (typeof options === "string") {
          return { name, not: false, values: [{ min: options, max: void 0 }] };
        }
        if (Array.isArray(options)) {
          return { name, not: false, values: options.map((option) => resolveValue(option)) };
        }
        return { name, not: false, values: [resolveValue(options)] };
      });
    }
    return normalizeScreens(Object.entries(screens ?? {}), false);
  }
  function isScreenSortable(screen) {
    if (screen.values.length !== 1) {
      return { result: false, reason: "multiple-values" };
    } else if (screen.values[0].raw !== void 0) {
      return { result: false, reason: "raw-values" };
    } else if (screen.values[0].min !== void 0 && screen.values[0].max !== void 0) {
      return { result: false, reason: "min-and-max" };
    }
    return { result: true, reason: null };
  }
  function compareScreens(type, a2, z2) {
    let aScreen = toScreen(a2, type);
    let zScreen = toScreen(z2, type);
    let aSorting = isScreenSortable(aScreen);
    let bSorting = isScreenSortable(zScreen);
    if (aSorting.reason === "multiple-values" || bSorting.reason === "multiple-values") {
      throw new Error(
        "Attempted to sort a screen with multiple values. This should never happen. Please open a bug report."
      );
    } else if (aSorting.reason === "raw-values" || bSorting.reason === "raw-values") {
      throw new Error(
        "Attempted to sort a screen with raw values. This should never happen. Please open a bug report."
      );
    } else if (aSorting.reason === "min-and-max" || bSorting.reason === "min-and-max") {
      throw new Error(
        "Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report."
      );
    }
    let { min: aMin, max: aMax } = aScreen.values[0];
    let { min: zMin, max: zMax } = zScreen.values[0];
    if (a2.not) [aMin, aMax] = [aMax, aMin];
    if (z2.not) [zMin, zMax] = [zMax, zMin];
    aMin = aMin === void 0 ? aMin : parseFloat(aMin);
    aMax = aMax === void 0 ? aMax : parseFloat(aMax);
    zMin = zMin === void 0 ? zMin : parseFloat(zMin);
    zMax = zMax === void 0 ? zMax : parseFloat(zMax);
    let [aValue, zValue] = type === "min" ? [aMin, zMin] : [zMax, aMax];
    return aValue - zValue;
  }
  function toScreen(value2, type) {
    if (typeof value2 === "object") {
      return value2;
    }
    return {
      name: "arbitrary-screen",
      values: [{ [type]: value2 }]
    };
  }
  function resolveValue({ "min-width": _minWidth, min = _minWidth, max: max2, raw } = {}) {
    return { min, max: max2, raw };
  }
  function removeAlphaVariables(container, toRemove) {
    container.walkDecls((decl22) => {
      if (toRemove.includes(decl22.prop)) {
        decl22.remove();
        return;
      }
      for (let varName of toRemove) {
        if (decl22.value.includes(`/ var(${varName})`)) {
          decl22.value = decl22.value.replace(`/ var(${varName})`, "");
        }
      }
    });
  }
  var variantPlugins = {
    pseudoElementVariants: ({ addVariant }) => {
      addVariant("first-letter", "&::first-letter");
      addVariant("first-line", "&::first-line");
      addVariant("marker", [
        ({ container }) => {
          removeAlphaVariables(container, ["--tw-text-opacity"]);
          return "& *::marker";
        },
        ({ container }) => {
          removeAlphaVariables(container, ["--tw-text-opacity"]);
          return "&::marker";
        }
      ]);
      addVariant("selection", ["& *::selection", "&::selection"]);
      addVariant("file", "&::file-selector-button");
      addVariant("placeholder", "&::placeholder");
      addVariant("backdrop", "&::backdrop");
      addVariant("before", ({ container }) => {
        container.walkRules((rule2) => {
          let foundContent = false;
          rule2.walkDecls("content", () => {
            foundContent = true;
          });
          if (!foundContent) {
            rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
          }
        });
        return "&::before";
      });
      addVariant("after", ({ container }) => {
        container.walkRules((rule2) => {
          let foundContent = false;
          rule2.walkDecls("content", () => {
            foundContent = true;
          });
          if (!foundContent) {
            rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
          }
        });
        return "&::after";
      });
    },
    pseudoClassVariants: ({ addVariant, matchVariant, config, prefix: prefix3 }) => {
      let pseudoVariants = [
        // Positional
        ["first", "&:first-child"],
        ["last", "&:last-child"],
        ["only", "&:only-child"],
        ["odd", "&:nth-child(odd)"],
        ["even", "&:nth-child(even)"],
        "first-of-type",
        "last-of-type",
        "only-of-type",
        // State
        [
          "visited",
          ({ container }) => {
            removeAlphaVariables(container, [
              "--tw-text-opacity",
              "--tw-border-opacity",
              "--tw-bg-opacity"
            ]);
            return "&:visited";
          }
        ],
        "target",
        ["open", "&[open]"],
        // Forms
        "default",
        "checked",
        "indeterminate",
        "placeholder-shown",
        "autofill",
        "optional",
        "required",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "read-only",
        // Content
        "empty",
        // Interactive
        "focus-within",
        [
          "hover",
          !flagEnabled2(config(), "hoverOnlyWhenSupported") ? "&:hover" : "@media (hover: hover) and (pointer: fine) { &:hover }"
        ],
        "focus",
        "focus-visible",
        "active",
        "enabled",
        "disabled"
      ].map((variant) => Array.isArray(variant) ? variant : [variant, `&:${variant}`]);
      for (let [variantName, state] of pseudoVariants) {
        addVariant(variantName, (ctx) => {
          let result = typeof state === "function" ? state(ctx) : state;
          return result;
        });
      }
      let variants = {
        group: (_2, { modifier }) => modifier ? [`:merge(${prefix3(".group")}\\/${escapeClassName2(modifier)})`, " &"] : [`:merge(${prefix3(".group")})`, " &"],
        peer: (_2, { modifier }) => modifier ? [`:merge(${prefix3(".peer")}\\/${escapeClassName2(modifier)})`, " ~ &"] : [`:merge(${prefix3(".peer")})`, " ~ &"]
      };
      for (let [name, fn5] of Object.entries(variants)) {
        matchVariant(
          name,
          (value2 = "", extra) => {
            let result = normalize2(typeof value2 === "function" ? value2(extra) : value2);
            if (!result.includes("&")) result = "&" + result;
            let [a2, b2] = fn5("", extra);
            let start = null;
            let end = null;
            let quotes2 = 0;
            for (let i2 = 0; i2 < result.length; ++i2) {
              let c3 = result[i2];
              if (c3 === "&") {
                start = i2;
              } else if (c3 === "'" || c3 === '"') {
                quotes2 += 1;
              } else if (start !== null && c3 === " " && !quotes2) {
                end = i2;
              }
            }
            if (start !== null && end === null) {
              end = result.length;
            }
            return result.slice(0, start) + a2 + result.slice(start + 1, end) + b2 + result.slice(end);
          },
          {
            values: Object.fromEntries(pseudoVariants),
            [INTERNAL_FEATURES]: {
              respectPrefix: false
            }
          }
        );
      }
    },
    directionVariants: ({ addVariant }) => {
      addVariant("ltr", ':is([dir="ltr"] &)');
      addVariant("rtl", ':is([dir="rtl"] &)');
    },
    reducedMotionVariants: ({ addVariant }) => {
      addVariant("motion-safe", "@media (prefers-reduced-motion: no-preference)");
      addVariant("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    },
    darkVariants: ({ config, addVariant }) => {
      let [mode, className = ".dark"] = [].concat(config("darkMode", "media"));
      if (mode === false) {
        mode = "media";
        log_default.warn("darkmode-false", [
          "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
          "Change `darkMode` to `media` or remove it entirely.",
          "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ]);
      }
      if (mode === "class") {
        addVariant("dark", `:is(${className} &)`);
      } else if (mode === "media") {
        addVariant("dark", "@media (prefers-color-scheme: dark)");
      }
    },
    printVariant: ({ addVariant }) => {
      addVariant("print", "@media print");
    },
    screenVariants: ({ theme, addVariant, matchVariant }) => {
      let rawScreens = theme("screens") ?? {};
      let areSimpleScreens = Object.values(rawScreens).every((v2) => typeof v2 === "string");
      let screens = normalizeScreens(theme("screens"));
      let unitCache = /* @__PURE__ */ new Set([]);
      function units(value2) {
        return value2.match(/(\D+)$/)?.[1] ?? "(none)";
      }
      function recordUnits(value2) {
        if (value2 !== void 0) {
          unitCache.add(units(value2));
        }
      }
      function canUseUnits(value2) {
        recordUnits(value2);
        return unitCache.size === 1;
      }
      for (const screen of screens) {
        for (const value2 of screen.values) {
          recordUnits(value2.min);
          recordUnits(value2.max);
        }
      }
      let screensUseConsistentUnits = unitCache.size <= 1;
      function buildScreenValues(type) {
        return Object.fromEntries(
          screens.filter((screen) => isScreenSortable(screen).result).map((screen) => {
            let { min, max: max2 } = screen.values[0];
            if (type === "min" && min !== void 0) {
              return screen;
            } else if (type === "min" && max2 !== void 0) {
              return { ...screen, not: !screen.not };
            } else if (type === "max" && max2 !== void 0) {
              return screen;
            } else if (type === "max" && min !== void 0) {
              return { ...screen, not: !screen.not };
            }
          }).map((screen) => [screen.name, screen])
        );
      }
      function buildSort(type) {
        return (a2, z2) => compareScreens(type, a2.value, z2.value);
      }
      let maxSort = buildSort("max");
      let minSort = buildSort("min");
      function buildScreenVariant(type) {
        return (value2) => {
          if (!areSimpleScreens) {
            log_default.warn("complex-screen-config", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
            ]);
            return [];
          } else if (!screensUseConsistentUnits) {
            log_default.warn("mixed-screen-units", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
            ]);
            return [];
          } else if (typeof value2 === "string" && !canUseUnits(value2)) {
            log_default.warn("minmax-have-mixed-units", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
            ]);
            return [];
          }
          return [`@media ${buildMediaQuery(toScreen(value2, type))}`];
        };
      }
      matchVariant("max", buildScreenVariant("max"), {
        sort: maxSort,
        values: areSimpleScreens ? buildScreenValues("max") : {}
      });
      let id = "min-screens";
      for (let screen of screens) {
        addVariant(screen.name, `@media ${buildMediaQuery(screen)}`, {
          id,
          sort: areSimpleScreens && screensUseConsistentUnits ? minSort : void 0,
          value: screen
        });
      }
      matchVariant("min", buildScreenVariant("min"), {
        id,
        sort: minSort
      });
    },
    supportsVariants: ({ matchVariant, theme }) => {
      matchVariant(
        "supports",
        (value2 = "") => {
          let check = normalize2(value2);
          let isRaw = /^\w*\s*\(/.test(check);
          check = isRaw ? check.replace(/\b(and|or|not)\b/g, " $1 ") : check;
          if (isRaw) {
            return `@supports ${check}`;
          }
          if (!check.includes(":")) {
            check = `${check}: var(--tw)`;
          }
          if (!(check.startsWith("(") && check.endsWith(")"))) {
            check = `(${check})`;
          }
          return `@supports ${check}`;
        },
        { values: theme("supports") ?? {} }
      );
    },
    ariaVariants: ({ matchVariant, theme }) => {
      matchVariant("aria", (value2) => `&[aria-${normalize2(value2)}]`, { values: theme("aria") ?? {} });
      matchVariant(
        "group-aria",
        (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[aria-${normalize2(value2)}] &` : `:merge(.group)[aria-${normalize2(value2)}] &`,
        { values: theme("aria") ?? {} }
      );
      matchVariant(
        "peer-aria",
        (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[aria-${normalize2(value2)}] ~ &` : `:merge(.peer)[aria-${normalize2(value2)}] ~ &`,
        { values: theme("aria") ?? {} }
      );
    },
    dataVariants: ({ matchVariant, theme }) => {
      matchVariant("data", (value2) => `&[data-${normalize2(value2)}]`, { values: theme("data") ?? {} });
      matchVariant(
        "group-data",
        (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[data-${normalize2(value2)}] &` : `:merge(.group)[data-${normalize2(value2)}] &`,
        { values: theme("data") ?? {} }
      );
      matchVariant(
        "peer-data",
        (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[data-${normalize2(value2)}] ~ &` : `:merge(.peer)[data-${normalize2(value2)}] ~ &`,
        { values: theme("data") ?? {} }
      );
    },
    orientationVariants: ({ addVariant }) => {
      addVariant("portrait", "@media (orientation: portrait)");
      addVariant("landscape", "@media (orientation: landscape)");
    },
    prefersContrastVariants: ({ addVariant }) => {
      addVariant("contrast-more", "@media (prefers-contrast: more)");
      addVariant("contrast-less", "@media (prefers-contrast: less)");
    }
  };
  var cssTransformValue = [
    "translate(var(--tw-translate-x), var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
  ].join(" ");
  var cssFilterValue = [
    "var(--tw-blur)",
    "var(--tw-brightness)",
    "var(--tw-contrast)",
    "var(--tw-grayscale)",
    "var(--tw-hue-rotate)",
    "var(--tw-invert)",
    "var(--tw-saturate)",
    "var(--tw-sepia)",
    "var(--tw-drop-shadow)"
  ].join(" ");
  var cssBackdropFilterValue = [
    "var(--tw-backdrop-blur)",
    "var(--tw-backdrop-brightness)",
    "var(--tw-backdrop-contrast)",
    "var(--tw-backdrop-grayscale)",
    "var(--tw-backdrop-hue-rotate)",
    "var(--tw-backdrop-invert)",
    "var(--tw-backdrop-opacity)",
    "var(--tw-backdrop-saturate)",
    "var(--tw-backdrop-sepia)"
  ].join(" ");
  var corePlugins = {
    preflight: ({ addBase }) => {
      let preflightStyles = postcss_default.parse(
        fs_default.readFileSync(join("/", "./css/preflight.css"), "utf8")
      );
      addBase([
        postcss_default.comment({
          text: `! tailwindcss v${version} | MIT License | https://tailwindcss.com`
        }),
        ...preflightStyles.nodes
      ]);
    },
    container: /* @__PURE__ */ (() => {
      function extractMinWidths(breakpoints = []) {
        return breakpoints.flatMap((breakpoint) => breakpoint.values.map((breakpoint2) => breakpoint2.min)).filter((v2) => v2 !== void 0);
      }
      function mapMinWidthsToPadding(minWidths, screens, paddings) {
        if (typeof paddings === "undefined") {
          return [];
        }
        if (!(typeof paddings === "object" && paddings !== null)) {
          return [
            {
              screen: "DEFAULT",
              minWidth: 0,
              padding: paddings
            }
          ];
        }
        let mapping = [];
        if (paddings.DEFAULT) {
          mapping.push({
            screen: "DEFAULT",
            minWidth: 0,
            padding: paddings.DEFAULT
          });
        }
        for (let minWidth of minWidths) {
          for (let screen of screens) {
            for (let { min } of screen.values) {
              if (min === minWidth) {
                mapping.push({ minWidth, padding: paddings[screen.name] });
              }
            }
          }
        }
        return mapping;
      }
      return function({ addComponents, theme }) {
        let screens = normalizeScreens(theme("container.screens", theme("screens")));
        let minWidths = extractMinWidths(screens);
        let paddings = mapMinWidthsToPadding(minWidths, screens, theme("container.padding"));
        let generatePaddingFor = (minWidth) => {
          let paddingConfig = paddings.find((padding) => padding.minWidth === minWidth);
          if (!paddingConfig) {
            return {};
          }
          return {
            paddingRight: paddingConfig.padding,
            paddingLeft: paddingConfig.padding
          };
        };
        let atRules = Array.from(
          new Set(minWidths.slice().sort((a2, z2) => parseInt(a2) - parseInt(z2)))
        ).map((minWidth) => ({
          [`@media (min-width: ${minWidth})`]: {
            ".container": {
              "max-width": minWidth,
              ...generatePaddingFor(minWidth)
            }
          }
        }));
        addComponents([
          {
            ".container": Object.assign(
              { width: "100%" },
              theme("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {},
              generatePaddingFor(0)
            )
          },
          ...atRules
        ]);
      };
    })(),
    accessibility: ({ addUtilities }) => {
      addUtilities({
        ".sr-only": {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        ".not-sr-only": {
          position: "static",
          width: "auto",
          height: "auto",
          padding: "0",
          margin: "0",
          overflow: "visible",
          clip: "auto",
          whiteSpace: "normal"
        }
      });
    },
    pointerEvents: ({ addUtilities }) => {
      addUtilities({
        ".pointer-events-none": { "pointer-events": "none" },
        ".pointer-events-auto": { "pointer-events": "auto" }
      });
    },
    visibility: ({ addUtilities }) => {
      addUtilities({
        ".visible": { visibility: "visible" },
        ".invisible": { visibility: "hidden" },
        ".collapse": { visibility: "collapse" }
      });
    },
    position: ({ addUtilities }) => {
      addUtilities({
        ".static": { position: "static" },
        ".fixed": { position: "fixed" },
        ".absolute": { position: "absolute" },
        ".relative": { position: "relative" },
        ".sticky": { position: "sticky" }
      });
    },
    inset: createUtilityPlugin(
      "inset",
      [
        ["inset", ["inset"]],
        [
          ["inset-x", ["left", "right"]],
          ["inset-y", ["top", "bottom"]]
        ],
        [
          ["start", ["inset-inline-start"]],
          ["end", ["inset-inline-end"]],
          ["top", ["top"]],
          ["right", ["right"]],
          ["bottom", ["bottom"]],
          ["left", ["left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    isolation: ({ addUtilities }) => {
      addUtilities({
        ".isolate": { isolation: "isolate" },
        ".isolation-auto": { isolation: "auto" }
      });
    },
    zIndex: createUtilityPlugin("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }),
    order: createUtilityPlugin("order", void 0, { supportsNegativeValues: true }),
    gridColumn: createUtilityPlugin("gridColumn", [["col", ["gridColumn"]]]),
    gridColumnStart: createUtilityPlugin("gridColumnStart", [["col-start", ["gridColumnStart"]]]),
    gridColumnEnd: createUtilityPlugin("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]),
    gridRow: createUtilityPlugin("gridRow", [["row", ["gridRow"]]]),
    gridRowStart: createUtilityPlugin("gridRowStart", [["row-start", ["gridRowStart"]]]),
    gridRowEnd: createUtilityPlugin("gridRowEnd", [["row-end", ["gridRowEnd"]]]),
    float: ({ addUtilities }) => {
      addUtilities({
        ".float-right": { float: "right" },
        ".float-left": { float: "left" },
        ".float-none": { float: "none" }
      });
    },
    clear: ({ addUtilities }) => {
      addUtilities({
        ".clear-left": { clear: "left" },
        ".clear-right": { clear: "right" },
        ".clear-both": { clear: "both" },
        ".clear-none": { clear: "none" }
      });
    },
    margin: createUtilityPlugin(
      "margin",
      [
        ["m", ["margin"]],
        [
          ["mx", ["margin-left", "margin-right"]],
          ["my", ["margin-top", "margin-bottom"]]
        ],
        [
          ["ms", ["margin-inline-start"]],
          ["me", ["margin-inline-end"]],
          ["mt", ["margin-top"]],
          ["mr", ["margin-right"]],
          ["mb", ["margin-bottom"]],
          ["ml", ["margin-left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    boxSizing: ({ addUtilities }) => {
      addUtilities({
        ".box-border": { "box-sizing": "border-box" },
        ".box-content": { "box-sizing": "content-box" }
      });
    },
    lineClamp: ({ matchUtilities, addUtilities, theme }) => {
      matchUtilities(
        {
          "line-clamp": (value2) => ({
            overflow: "hidden",
            display: "-webkit-box",
            "-webkit-box-orient": "vertical",
            "-webkit-line-clamp": `${value2}`
          })
        },
        { values: theme("lineClamp") }
      );
      addUtilities({
        ".line-clamp-none": {
          overflow: "visible",
          display: "block",
          "-webkit-box-orient": "horizontal",
          "-webkit-line-clamp": "none"
        }
      });
    },
    display: ({ addUtilities }) => {
      addUtilities({
        ".block": { display: "block" },
        ".inline-block": { display: "inline-block" },
        ".inline": { display: "inline" },
        ".flex": { display: "flex" },
        ".inline-flex": { display: "inline-flex" },
        ".table": { display: "table" },
        ".inline-table": { display: "inline-table" },
        ".table-caption": { display: "table-caption" },
        ".table-cell": { display: "table-cell" },
        ".table-column": { display: "table-column" },
        ".table-column-group": { display: "table-column-group" },
        ".table-footer-group": { display: "table-footer-group" },
        ".table-header-group": { display: "table-header-group" },
        ".table-row-group": { display: "table-row-group" },
        ".table-row": { display: "table-row" },
        ".flow-root": { display: "flow-root" },
        ".grid": { display: "grid" },
        ".inline-grid": { display: "inline-grid" },
        ".contents": { display: "contents" },
        ".list-item": { display: "list-item" },
        ".hidden": { display: "none" }
      });
    },
    aspectRatio: createUtilityPlugin("aspectRatio", [["aspect", ["aspect-ratio"]]]),
    height: createUtilityPlugin("height", [["h", ["height"]]]),
    maxHeight: createUtilityPlugin("maxHeight", [["max-h", ["maxHeight"]]]),
    minHeight: createUtilityPlugin("minHeight", [["min-h", ["minHeight"]]]),
    width: createUtilityPlugin("width", [["w", ["width"]]]),
    minWidth: createUtilityPlugin("minWidth", [["min-w", ["minWidth"]]]),
    maxWidth: createUtilityPlugin("maxWidth", [["max-w", ["maxWidth"]]]),
    flex: createUtilityPlugin("flex"),
    flexShrink: createUtilityPlugin("flexShrink", [
      ["flex-shrink", ["flex-shrink"]],
      // Deprecated
      ["shrink", ["flex-shrink"]]
    ]),
    flexGrow: createUtilityPlugin("flexGrow", [
      ["flex-grow", ["flex-grow"]],
      // Deprecated
      ["grow", ["flex-grow"]]
    ]),
    flexBasis: createUtilityPlugin("flexBasis", [["basis", ["flex-basis"]]]),
    tableLayout: ({ addUtilities }) => {
      addUtilities({
        ".table-auto": { "table-layout": "auto" },
        ".table-fixed": { "table-layout": "fixed" }
      });
    },
    captionSide: ({ addUtilities }) => {
      addUtilities({
        ".caption-top": { "caption-side": "top" },
        ".caption-bottom": { "caption-side": "bottom" }
      });
    },
    borderCollapse: ({ addUtilities }) => {
      addUtilities({
        ".border-collapse": { "border-collapse": "collapse" },
        ".border-separate": { "border-collapse": "separate" }
      });
    },
    borderSpacing: ({ addDefaults, matchUtilities, theme }) => {
      addDefaults("border-spacing", {
        "--tw-border-spacing-x": 0,
        "--tw-border-spacing-y": 0
      });
      matchUtilities(
        {
          "border-spacing": (value2) => {
            return {
              "--tw-border-spacing-x": value2,
              "--tw-border-spacing-y": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-x": (value2) => {
            return {
              "--tw-border-spacing-x": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-y": (value2) => {
            return {
              "--tw-border-spacing-y": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          }
        },
        { values: theme("borderSpacing") }
      );
    },
    transformOrigin: createUtilityPlugin("transformOrigin", [["origin", ["transformOrigin"]]]),
    translate: createUtilityPlugin(
      "translate",
      [
        [
          [
            "translate-x",
            [["@defaults transform", {}], "--tw-translate-x", ["transform", cssTransformValue]]
          ],
          [
            "translate-y",
            [["@defaults transform", {}], "--tw-translate-y", ["transform", cssTransformValue]]
          ]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    rotate: createUtilityPlugin(
      "rotate",
      [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", cssTransformValue]]]],
      { supportsNegativeValues: true }
    ),
    skew: createUtilityPlugin(
      "skew",
      [
        [
          ["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", cssTransformValue]]],
          ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", cssTransformValue]]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    scale: createUtilityPlugin(
      "scale",
      [
        [
          "scale",
          [
            ["@defaults transform", {}],
            "--tw-scale-x",
            "--tw-scale-y",
            ["transform", cssTransformValue]
          ]
        ],
        [
          [
            "scale-x",
            [["@defaults transform", {}], "--tw-scale-x", ["transform", cssTransformValue]]
          ],
          [
            "scale-y",
            [["@defaults transform", {}], "--tw-scale-y", ["transform", cssTransformValue]]
          ]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    transform: ({ addDefaults, addUtilities }) => {
      addDefaults("transform", {
        "--tw-translate-x": "0",
        "--tw-translate-y": "0",
        "--tw-rotate": "0",
        "--tw-skew-x": "0",
        "--tw-skew-y": "0",
        "--tw-scale-x": "1",
        "--tw-scale-y": "1"
      });
      addUtilities({
        ".transform": { "@defaults transform": {}, transform: cssTransformValue },
        ".transform-cpu": {
          transform: cssTransformValue
        },
        ".transform-gpu": {
          transform: cssTransformValue.replace(
            "translate(var(--tw-translate-x), var(--tw-translate-y))",
            "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)"
          )
        },
        ".transform-none": { transform: "none" }
      });
    },
    animation: ({ matchUtilities, theme, config }) => {
      let prefixName = (name) => escapeClassName2(config("prefix") + name);
      let keyframes = Object.fromEntries(
        Object.entries(theme("keyframes") ?? {}).map(([key, value2]) => {
          return [key, { [`@keyframes ${prefixName(key)}`]: value2 }];
        })
      );
      matchUtilities(
        {
          animate: (value2) => {
            let animations = parseAnimationValue(value2);
            return [
              ...animations.flatMap((animation) => keyframes[animation.name]),
              {
                animation: animations.map(({ name, value: value3 }) => {
                  if (name === void 0 || keyframes[name] === void 0) {
                    return value3;
                  }
                  return value3.replace(name, prefixName(name));
                }).join(", ")
              }
            ];
          }
        },
        { values: theme("animation") }
      );
    },
    cursor: createUtilityPlugin("cursor"),
    touchAction: ({ addDefaults, addUtilities }) => {
      addDefaults("touch-action", {
        "--tw-pan-x": " ",
        "--tw-pan-y": " ",
        "--tw-pinch-zoom": " "
      });
      let cssTouchActionValue = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
      addUtilities({
        ".touch-auto": { "touch-action": "auto" },
        ".touch-none": { "touch-action": "none" },
        ".touch-pan-x": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-x",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-left": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-left",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-right": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-right",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-y": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-y",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-up": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-up",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-down": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-down",
          "touch-action": cssTouchActionValue
        },
        ".touch-pinch-zoom": {
          "@defaults touch-action": {},
          "--tw-pinch-zoom": "pinch-zoom",
          "touch-action": cssTouchActionValue
        },
        ".touch-manipulation": { "touch-action": "manipulation" }
      });
    },
    userSelect: ({ addUtilities }) => {
      addUtilities({
        ".select-none": { "user-select": "none" },
        ".select-text": { "user-select": "text" },
        ".select-all": { "user-select": "all" },
        ".select-auto": { "user-select": "auto" }
      });
    },
    resize: ({ addUtilities }) => {
      addUtilities({
        ".resize-none": { resize: "none" },
        ".resize-y": { resize: "vertical" },
        ".resize-x": { resize: "horizontal" },
        ".resize": { resize: "both" }
      });
    },
    scrollSnapType: ({ addDefaults, addUtilities }) => {
      addDefaults("scroll-snap-type", {
        "--tw-scroll-snap-strictness": "proximity"
      });
      addUtilities({
        ".snap-none": { "scroll-snap-type": "none" },
        ".snap-x": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
        },
        ".snap-y": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
        },
        ".snap-both": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
        },
        ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" },
        ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" }
      });
    },
    scrollSnapAlign: ({ addUtilities }) => {
      addUtilities({
        ".snap-start": { "scroll-snap-align": "start" },
        ".snap-end": { "scroll-snap-align": "end" },
        ".snap-center": { "scroll-snap-align": "center" },
        ".snap-align-none": { "scroll-snap-align": "none" }
      });
    },
    scrollSnapStop: ({ addUtilities }) => {
      addUtilities({
        ".snap-normal": { "scroll-snap-stop": "normal" },
        ".snap-always": { "scroll-snap-stop": "always" }
      });
    },
    scrollMargin: createUtilityPlugin(
      "scrollMargin",
      [
        ["scroll-m", ["scroll-margin"]],
        [
          ["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]],
          ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]
        ],
        [
          ["scroll-ms", ["scroll-margin-inline-start"]],
          ["scroll-me", ["scroll-margin-inline-end"]],
          ["scroll-mt", ["scroll-margin-top"]],
          ["scroll-mr", ["scroll-margin-right"]],
          ["scroll-mb", ["scroll-margin-bottom"]],
          ["scroll-ml", ["scroll-margin-left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    scrollPadding: createUtilityPlugin("scrollPadding", [
      ["scroll-p", ["scroll-padding"]],
      [
        ["scroll-px", ["scroll-padding-left", "scroll-padding-right"]],
        ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]
      ],
      [
        ["scroll-ps", ["scroll-padding-inline-start"]],
        ["scroll-pe", ["scroll-padding-inline-end"]],
        ["scroll-pt", ["scroll-padding-top"]],
        ["scroll-pr", ["scroll-padding-right"]],
        ["scroll-pb", ["scroll-padding-bottom"]],
        ["scroll-pl", ["scroll-padding-left"]]
      ]
    ]),
    listStylePosition: ({ addUtilities }) => {
      addUtilities({
        ".list-inside": { "list-style-position": "inside" },
        ".list-outside": { "list-style-position": "outside" }
      });
    },
    listStyleType: createUtilityPlugin("listStyleType", [["list", ["listStyleType"]]]),
    listStyleImage: createUtilityPlugin("listStyleImage", [["list-image", ["listStyleImage"]]]),
    appearance: ({ addUtilities }) => {
      addUtilities({
        ".appearance-none": { appearance: "none" }
      });
    },
    columns: createUtilityPlugin("columns", [["columns", ["columns"]]]),
    breakBefore: ({ addUtilities }) => {
      addUtilities({
        ".break-before-auto": { "break-before": "auto" },
        ".break-before-avoid": { "break-before": "avoid" },
        ".break-before-all": { "break-before": "all" },
        ".break-before-avoid-page": { "break-before": "avoid-page" },
        ".break-before-page": { "break-before": "page" },
        ".break-before-left": { "break-before": "left" },
        ".break-before-right": { "break-before": "right" },
        ".break-before-column": { "break-before": "column" }
      });
    },
    breakInside: ({ addUtilities }) => {
      addUtilities({
        ".break-inside-auto": { "break-inside": "auto" },
        ".break-inside-avoid": { "break-inside": "avoid" },
        ".break-inside-avoid-page": { "break-inside": "avoid-page" },
        ".break-inside-avoid-column": { "break-inside": "avoid-column" }
      });
    },
    breakAfter: ({ addUtilities }) => {
      addUtilities({
        ".break-after-auto": { "break-after": "auto" },
        ".break-after-avoid": { "break-after": "avoid" },
        ".break-after-all": { "break-after": "all" },
        ".break-after-avoid-page": { "break-after": "avoid-page" },
        ".break-after-page": { "break-after": "page" },
        ".break-after-left": { "break-after": "left" },
        ".break-after-right": { "break-after": "right" },
        ".break-after-column": { "break-after": "column" }
      });
    },
    gridAutoColumns: createUtilityPlugin("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]),
    gridAutoFlow: ({ addUtilities }) => {
      addUtilities({
        ".grid-flow-row": { gridAutoFlow: "row" },
        ".grid-flow-col": { gridAutoFlow: "column" },
        ".grid-flow-dense": { gridAutoFlow: "dense" },
        ".grid-flow-row-dense": { gridAutoFlow: "row dense" },
        ".grid-flow-col-dense": { gridAutoFlow: "column dense" }
      });
    },
    gridAutoRows: createUtilityPlugin("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]),
    gridTemplateColumns: createUtilityPlugin("gridTemplateColumns", [
      ["grid-cols", ["gridTemplateColumns"]]
    ]),
    gridTemplateRows: createUtilityPlugin("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]),
    flexDirection: ({ addUtilities }) => {
      addUtilities({
        ".flex-row": { "flex-direction": "row" },
        ".flex-row-reverse": { "flex-direction": "row-reverse" },
        ".flex-col": { "flex-direction": "column" },
        ".flex-col-reverse": { "flex-direction": "column-reverse" }
      });
    },
    flexWrap: ({ addUtilities }) => {
      addUtilities({
        ".flex-wrap": { "flex-wrap": "wrap" },
        ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" },
        ".flex-nowrap": { "flex-wrap": "nowrap" }
      });
    },
    placeContent: ({ addUtilities }) => {
      addUtilities({
        ".place-content-center": { "place-content": "center" },
        ".place-content-start": { "place-content": "start" },
        ".place-content-end": { "place-content": "end" },
        ".place-content-between": { "place-content": "space-between" },
        ".place-content-around": { "place-content": "space-around" },
        ".place-content-evenly": { "place-content": "space-evenly" },
        ".place-content-baseline": { "place-content": "baseline" },
        ".place-content-stretch": { "place-content": "stretch" }
      });
    },
    placeItems: ({ addUtilities }) => {
      addUtilities({
        ".place-items-start": { "place-items": "start" },
        ".place-items-end": { "place-items": "end" },
        ".place-items-center": { "place-items": "center" },
        ".place-items-baseline": { "place-items": "baseline" },
        ".place-items-stretch": { "place-items": "stretch" }
      });
    },
    alignContent: ({ addUtilities }) => {
      addUtilities({
        ".content-normal": { "align-content": "normal" },
        ".content-center": { "align-content": "center" },
        ".content-start": { "align-content": "flex-start" },
        ".content-end": { "align-content": "flex-end" },
        ".content-between": { "align-content": "space-between" },
        ".content-around": { "align-content": "space-around" },
        ".content-evenly": { "align-content": "space-evenly" },
        ".content-baseline": { "align-content": "baseline" },
        ".content-stretch": { "align-content": "stretch" }
      });
    },
    alignItems: ({ addUtilities }) => {
      addUtilities({
        ".items-start": { "align-items": "flex-start" },
        ".items-end": { "align-items": "flex-end" },
        ".items-center": { "align-items": "center" },
        ".items-baseline": { "align-items": "baseline" },
        ".items-stretch": { "align-items": "stretch" }
      });
    },
    justifyContent: ({ addUtilities }) => {
      addUtilities({
        ".justify-normal": { "justify-content": "normal" },
        ".justify-start": { "justify-content": "flex-start" },
        ".justify-end": { "justify-content": "flex-end" },
        ".justify-center": { "justify-content": "center" },
        ".justify-between": { "justify-content": "space-between" },
        ".justify-around": { "justify-content": "space-around" },
        ".justify-evenly": { "justify-content": "space-evenly" },
        ".justify-stretch": { "justify-content": "stretch" }
      });
    },
    justifyItems: ({ addUtilities }) => {
      addUtilities({
        ".justify-items-start": { "justify-items": "start" },
        ".justify-items-end": { "justify-items": "end" },
        ".justify-items-center": { "justify-items": "center" },
        ".justify-items-stretch": { "justify-items": "stretch" }
      });
    },
    gap: createUtilityPlugin("gap", [
      ["gap", ["gap"]],
      [
        ["gap-x", ["columnGap"]],
        ["gap-y", ["rowGap"]]
      ]
    ]),
    space: ({ matchUtilities, addUtilities, theme }) => {
      matchUtilities(
        {
          "space-x": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            if (void 0) {
              return {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "--tw-space-x-reverse": "0",
                  "margin-inline-end": `calc(${value2} * var(--tw-space-x-reverse))`,
                  "margin-inline-start": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
                }
              };
            }
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "0",
                "margin-right": `calc(${value2} * var(--tw-space-x-reverse))`,
                "margin-left": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
              }
            };
          },
          "space-y": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-y-reverse": "0",
                "margin-top": `calc(${value2} * calc(1 - var(--tw-space-y-reverse)))`,
                "margin-bottom": `calc(${value2} * var(--tw-space-y-reverse))`
              }
            };
          }
        },
        { values: theme("space"), supportsNegativeValues: true }
      );
      addUtilities({
        ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" },
        ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" }
      });
    },
    divideWidth: ({ matchUtilities, addUtilities, theme }) => {
      matchUtilities(
        {
          "divide-x": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            if (void 0) {
              return {
                "& > :not([hidden]) ~ :not([hidden])": {
                  "@defaults border-width": {},
                  "--tw-divide-x-reverse": "0",
                  "border-inline-end-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
                  "border-inline-start-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
                }
              };
            }
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "0",
                "border-right-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
                "border-left-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
              }
            };
          },
          "divide-y": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-y-reverse": "0",
                "border-top-width": `calc(${value2} * calc(1 - var(--tw-divide-y-reverse)))`,
                "border-bottom-width": `calc(${value2} * var(--tw-divide-y-reverse))`
              }
            };
          }
        },
        { values: theme("divideWidth"), type: ["line-width", "length", "any"] }
      );
      addUtilities({
        ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-y-reverse": "1"
        },
        ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-x-reverse": "1"
        }
      });
    },
    divideStyle: ({ addUtilities }) => {
      addUtilities({
        ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" },
        ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" },
        ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" },
        ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" },
        ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" }
      });
    },
    divideColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          divide: (value2) => {
            if (!corePlugins2("divideOpacity")) {
              return {
                ["& > :not([hidden]) ~ :not([hidden])"]: {
                  "border-color": toColorValue(value2)
                }
              };
            }
            return {
              ["& > :not([hidden]) ~ :not([hidden])"]: withAlphaVariable({
                color: value2,
                property: "border-color",
                variable: "--tw-divide-opacity"
              })
            };
          }
        },
        {
          values: (({ DEFAULT: _2, ...colors }) => colors)(flattenColorPalette_default(theme("divideColor"))),
          type: ["color", "any"]
        }
      );
    },
    divideOpacity: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "divide-opacity": (value2) => {
            return { [`& > :not([hidden]) ~ :not([hidden])`]: { "--tw-divide-opacity": value2 } };
          }
        },
        { values: theme("divideOpacity") }
      );
    },
    placeSelf: ({ addUtilities }) => {
      addUtilities({
        ".place-self-auto": { "place-self": "auto" },
        ".place-self-start": { "place-self": "start" },
        ".place-self-end": { "place-self": "end" },
        ".place-self-center": { "place-self": "center" },
        ".place-self-stretch": { "place-self": "stretch" }
      });
    },
    alignSelf: ({ addUtilities }) => {
      addUtilities({
        ".self-auto": { "align-self": "auto" },
        ".self-start": { "align-self": "flex-start" },
        ".self-end": { "align-self": "flex-end" },
        ".self-center": { "align-self": "center" },
        ".self-stretch": { "align-self": "stretch" },
        ".self-baseline": { "align-self": "baseline" }
      });
    },
    justifySelf: ({ addUtilities }) => {
      addUtilities({
        ".justify-self-auto": { "justify-self": "auto" },
        ".justify-self-start": { "justify-self": "start" },
        ".justify-self-end": { "justify-self": "end" },
        ".justify-self-center": { "justify-self": "center" },
        ".justify-self-stretch": { "justify-self": "stretch" }
      });
    },
    overflow: ({ addUtilities }) => {
      addUtilities({
        ".overflow-auto": { overflow: "auto" },
        ".overflow-hidden": { overflow: "hidden" },
        ".overflow-clip": { overflow: "clip" },
        ".overflow-visible": { overflow: "visible" },
        ".overflow-scroll": { overflow: "scroll" },
        ".overflow-x-auto": { "overflow-x": "auto" },
        ".overflow-y-auto": { "overflow-y": "auto" },
        ".overflow-x-hidden": { "overflow-x": "hidden" },
        ".overflow-y-hidden": { "overflow-y": "hidden" },
        ".overflow-x-clip": { "overflow-x": "clip" },
        ".overflow-y-clip": { "overflow-y": "clip" },
        ".overflow-x-visible": { "overflow-x": "visible" },
        ".overflow-y-visible": { "overflow-y": "visible" },
        ".overflow-x-scroll": { "overflow-x": "scroll" },
        ".overflow-y-scroll": { "overflow-y": "scroll" }
      });
    },
    overscrollBehavior: ({ addUtilities }) => {
      addUtilities({
        ".overscroll-auto": { "overscroll-behavior": "auto" },
        ".overscroll-contain": { "overscroll-behavior": "contain" },
        ".overscroll-none": { "overscroll-behavior": "none" },
        ".overscroll-y-auto": { "overscroll-behavior-y": "auto" },
        ".overscroll-y-contain": { "overscroll-behavior-y": "contain" },
        ".overscroll-y-none": { "overscroll-behavior-y": "none" },
        ".overscroll-x-auto": { "overscroll-behavior-x": "auto" },
        ".overscroll-x-contain": { "overscroll-behavior-x": "contain" },
        ".overscroll-x-none": { "overscroll-behavior-x": "none" }
      });
    },
    scrollBehavior: ({ addUtilities }) => {
      addUtilities({
        ".scroll-auto": { "scroll-behavior": "auto" },
        ".scroll-smooth": { "scroll-behavior": "smooth" }
      });
    },
    textOverflow: ({ addUtilities }) => {
      addUtilities({
        ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" },
        ".overflow-ellipsis": { "text-overflow": "ellipsis" },
        // Deprecated
        ".text-ellipsis": { "text-overflow": "ellipsis" },
        ".text-clip": { "text-overflow": "clip" }
      });
    },
    hyphens: ({ addUtilities }) => {
      addUtilities({
        ".hyphens-none": { hyphens: "none" },
        ".hyphens-manual": { hyphens: "manual" },
        ".hyphens-auto": { hyphens: "auto" }
      });
    },
    whitespace: ({ addUtilities }) => {
      addUtilities({
        ".whitespace-normal": { "white-space": "normal" },
        ".whitespace-nowrap": { "white-space": "nowrap" },
        ".whitespace-pre": { "white-space": "pre" },
        ".whitespace-pre-line": { "white-space": "pre-line" },
        ".whitespace-pre-wrap": { "white-space": "pre-wrap" },
        ".whitespace-break-spaces": { "white-space": "break-spaces" }
      });
    },
    wordBreak: ({ addUtilities }) => {
      addUtilities({
        ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" },
        ".break-words": { "overflow-wrap": "break-word" },
        ".break-all": { "word-break": "break-all" },
        ".break-keep": { "word-break": "keep-all" }
      });
    },
    borderRadius: createUtilityPlugin("borderRadius", [
      ["rounded", ["border-radius"]],
      [
        ["rounded-s", ["border-start-start-radius", "border-end-start-radius"]],
        ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]],
        ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]],
        ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]],
        ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]],
        ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]
      ],
      [
        ["rounded-ss", ["border-start-start-radius"]],
        ["rounded-se", ["border-start-end-radius"]],
        ["rounded-ee", ["border-end-end-radius"]],
        ["rounded-es", ["border-end-start-radius"]],
        ["rounded-tl", ["border-top-left-radius"]],
        ["rounded-tr", ["border-top-right-radius"]],
        ["rounded-br", ["border-bottom-right-radius"]],
        ["rounded-bl", ["border-bottom-left-radius"]]
      ]
    ]),
    borderWidth: createUtilityPlugin(
      "borderWidth",
      [
        ["border", [["@defaults border-width", {}], "border-width"]],
        [
          ["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]],
          ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]
        ],
        [
          ["border-s", [["@defaults border-width", {}], "border-inline-start-width"]],
          ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]],
          ["border-t", [["@defaults border-width", {}], "border-top-width"]],
          ["border-r", [["@defaults border-width", {}], "border-right-width"]],
          ["border-b", [["@defaults border-width", {}], "border-bottom-width"]],
          ["border-l", [["@defaults border-width", {}], "border-left-width"]]
        ]
      ],
      { type: ["line-width", "length"] }
    ),
    borderStyle: ({ addUtilities }) => {
      addUtilities({
        ".border-solid": { "border-style": "solid" },
        ".border-dashed": { "border-style": "dashed" },
        ".border-dotted": { "border-style": "dotted" },
        ".border-double": { "border-style": "double" },
        ".border-hidden": { "border-style": "hidden" },
        ".border-none": { "border-style": "none" }
      });
    },
    borderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          border: (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-color",
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _2, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
          type: ["color", "any"]
        }
      );
      matchUtilities(
        {
          "border-x": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": toColorValue(value2),
                "border-right-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: ["border-left-color", "border-right-color"],
              variable: "--tw-border-opacity"
            });
          },
          "border-y": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": toColorValue(value2),
                "border-bottom-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: ["border-top-color", "border-bottom-color"],
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _2, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
          type: ["color", "any"]
        }
      );
      matchUtilities(
        {
          "border-s": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-inline-start-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-inline-start-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-e": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-inline-end-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-inline-end-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-t": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-top-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-r": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-right-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-right-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-b": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-bottom-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-bottom-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-l": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-left-color",
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _2, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
          type: ["color", "any"]
        }
      );
    },
    borderOpacity: createUtilityPlugin("borderOpacity", [
      ["border-opacity", ["--tw-border-opacity"]]
    ]),
    backgroundColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          bg: (value2) => {
            if (!corePlugins2("backgroundOpacity")) {
              return {
                "background-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "background-color",
              variable: "--tw-bg-opacity"
            });
          }
        },
        { values: flattenColorPalette_default(theme("backgroundColor")), type: ["color", "any"] }
      );
    },
    backgroundOpacity: createUtilityPlugin("backgroundOpacity", [
      ["bg-opacity", ["--tw-bg-opacity"]]
    ]),
    backgroundImage: createUtilityPlugin("backgroundImage", [["bg", ["background-image"]]], {
      type: ["lookup", "image", "url"]
    }),
    gradientColorStops: /* @__PURE__ */ (() => {
      function transparentTo(value2) {
        return withAlphaValue(value2, 0, "rgb(255 255 255 / 0)");
      }
      return function({ matchUtilities, theme, addDefaults }) {
        addDefaults("gradient-color-stops", {
          "--tw-gradient-from-position": " ",
          "--tw-gradient-via-position": " ",
          "--tw-gradient-to-position": " "
        });
        let options = {
          values: flattenColorPalette_default(theme("gradientColorStops")),
          type: ["color", "any"]
        };
        let positionOptions = {
          values: theme("gradientColorStopPositions"),
          type: ["length", "percentage"]
        };
        matchUtilities(
          {
            from: (value2) => {
              let transparentToValue = transparentTo(value2);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-from": `${toColorValue(value2)} var(--tw-gradient-from-position)`,
                "--tw-gradient-to": `${transparentToValue} var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), var(--tw-gradient-to)`
              };
            }
          },
          options
        );
        matchUtilities(
          {
            from: (value2) => {
              return {
                "--tw-gradient-from-position": value2
              };
            }
          },
          positionOptions
        );
        matchUtilities(
          {
            via: (value2) => {
              let transparentToValue = transparentTo(value2);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-to": `${transparentToValue}  var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${toColorValue(
                  value2
                )} var(--tw-gradient-via-position), var(--tw-gradient-to)`
              };
            }
          },
          options
        );
        matchUtilities(
          {
            via: (value2) => {
              return {
                "--tw-gradient-via-position": value2
              };
            }
          },
          positionOptions
        );
        matchUtilities(
          {
            to: (value2) => ({
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${toColorValue(value2)} var(--tw-gradient-to-position)`
            })
          },
          options
        );
        matchUtilities(
          {
            to: (value2) => {
              return {
                "--tw-gradient-to-position": value2
              };
            }
          },
          positionOptions
        );
      };
    })(),
    boxDecorationBreak: ({ addUtilities }) => {
      addUtilities({
        ".decoration-slice": { "box-decoration-break": "slice" },
        // Deprecated
        ".decoration-clone": { "box-decoration-break": "clone" },
        // Deprecated
        ".box-decoration-slice": { "box-decoration-break": "slice" },
        ".box-decoration-clone": { "box-decoration-break": "clone" }
      });
    },
    backgroundSize: createUtilityPlugin("backgroundSize", [["bg", ["background-size"]]], {
      type: ["lookup", "length", "percentage", "size"]
    }),
    backgroundAttachment: ({ addUtilities }) => {
      addUtilities({
        ".bg-fixed": { "background-attachment": "fixed" },
        ".bg-local": { "background-attachment": "local" },
        ".bg-scroll": { "background-attachment": "scroll" }
      });
    },
    backgroundClip: ({ addUtilities }) => {
      addUtilities({
        ".bg-clip-border": { "background-clip": "border-box" },
        ".bg-clip-padding": { "background-clip": "padding-box" },
        ".bg-clip-content": { "background-clip": "content-box" },
        ".bg-clip-text": { "background-clip": "text" }
      });
    },
    backgroundPosition: createUtilityPlugin("backgroundPosition", [["bg", ["background-position"]]], {
      type: ["lookup", ["position", { preferOnConflict: true }]]
    }),
    backgroundRepeat: ({ addUtilities }) => {
      addUtilities({
        ".bg-repeat": { "background-repeat": "repeat" },
        ".bg-no-repeat": { "background-repeat": "no-repeat" },
        ".bg-repeat-x": { "background-repeat": "repeat-x" },
        ".bg-repeat-y": { "background-repeat": "repeat-y" },
        ".bg-repeat-round": { "background-repeat": "round" },
        ".bg-repeat-space": { "background-repeat": "space" }
      });
    },
    backgroundOrigin: ({ addUtilities }) => {
      addUtilities({
        ".bg-origin-border": { "background-origin": "border-box" },
        ".bg-origin-padding": { "background-origin": "padding-box" },
        ".bg-origin-content": { "background-origin": "content-box" }
      });
    },
    fill: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          fill: (value2) => {
            return { fill: toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("fill")), type: ["color", "any"] }
      );
    },
    stroke: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          stroke: (value2) => {
            return { stroke: toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("stroke")), type: ["color", "url", "any"] }
      );
    },
    strokeWidth: createUtilityPlugin("strokeWidth", [["stroke", ["stroke-width"]]], {
      type: ["length", "number", "percentage"]
    }),
    objectFit: ({ addUtilities }) => {
      addUtilities({
        ".object-contain": { "object-fit": "contain" },
        ".object-cover": { "object-fit": "cover" },
        ".object-fill": { "object-fit": "fill" },
        ".object-none": { "object-fit": "none" },
        ".object-scale-down": { "object-fit": "scale-down" }
      });
    },
    objectPosition: createUtilityPlugin("objectPosition", [["object", ["object-position"]]]),
    padding: createUtilityPlugin("padding", [
      ["p", ["padding"]],
      [
        ["px", ["padding-left", "padding-right"]],
        ["py", ["padding-top", "padding-bottom"]]
      ],
      [
        ["ps", ["padding-inline-start"]],
        ["pe", ["padding-inline-end"]],
        ["pt", ["padding-top"]],
        ["pr", ["padding-right"]],
        ["pb", ["padding-bottom"]],
        ["pl", ["padding-left"]]
      ]
    ]),
    textAlign: ({ addUtilities }) => {
      addUtilities({
        ".text-left": { "text-align": "left" },
        ".text-center": { "text-align": "center" },
        ".text-right": { "text-align": "right" },
        ".text-justify": { "text-align": "justify" },
        ".text-start": { "text-align": "start" },
        ".text-end": { "text-align": "end" }
      });
    },
    textIndent: createUtilityPlugin("textIndent", [["indent", ["text-indent"]]], {
      supportsNegativeValues: true
    }),
    verticalAlign: ({ addUtilities, matchUtilities }) => {
      addUtilities({
        ".align-baseline": { "vertical-align": "baseline" },
        ".align-top": { "vertical-align": "top" },
        ".align-middle": { "vertical-align": "middle" },
        ".align-bottom": { "vertical-align": "bottom" },
        ".align-text-top": { "vertical-align": "text-top" },
        ".align-text-bottom": { "vertical-align": "text-bottom" },
        ".align-sub": { "vertical-align": "sub" },
        ".align-super": { "vertical-align": "super" }
      });
      matchUtilities({ align: (value2) => ({ "vertical-align": value2 }) });
    },
    fontFamily: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          font: (value2) => {
            let [families, options = {}] = Array.isArray(value2) && isPlainObject(value2[1]) ? value2 : [value2];
            let { fontFeatureSettings, fontVariationSettings } = options;
            return {
              "font-family": Array.isArray(families) ? families.join(", ") : families,
              ...fontFeatureSettings === void 0 ? {} : { "font-feature-settings": fontFeatureSettings },
              ...fontVariationSettings === void 0 ? {} : { "font-variation-settings": fontVariationSettings }
            };
          }
        },
        {
          values: theme("fontFamily"),
          type: ["lookup", "generic-name", "family-name"]
        }
      );
    },
    fontSize: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          text: (value2, { modifier }) => {
            let [fontSize, options] = Array.isArray(value2) ? value2 : [value2];
            if (modifier) {
              return {
                "font-size": fontSize,
                "line-height": modifier
              };
            }
            let { lineHeight, letterSpacing, fontWeight } = isPlainObject(options) ? options : { lineHeight: options };
            return {
              "font-size": fontSize,
              ...lineHeight === void 0 ? {} : { "line-height": lineHeight },
              ...letterSpacing === void 0 ? {} : { "letter-spacing": letterSpacing },
              ...fontWeight === void 0 ? {} : { "font-weight": fontWeight }
            };
          }
        },
        {
          values: theme("fontSize"),
          modifiers: theme("lineHeight"),
          type: ["absolute-size", "relative-size", "length", "percentage"]
        }
      );
    },
    fontWeight: createUtilityPlugin("fontWeight", [["font", ["fontWeight"]]], {
      type: ["lookup", "number", "any"]
    }),
    textTransform: ({ addUtilities }) => {
      addUtilities({
        ".uppercase": { "text-transform": "uppercase" },
        ".lowercase": { "text-transform": "lowercase" },
        ".capitalize": { "text-transform": "capitalize" },
        ".normal-case": { "text-transform": "none" }
      });
    },
    fontStyle: ({ addUtilities }) => {
      addUtilities({
        ".italic": { "font-style": "italic" },
        ".not-italic": { "font-style": "normal" }
      });
    },
    fontVariantNumeric: ({ addDefaults, addUtilities }) => {
      let cssFontVariantNumericValue = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
      addDefaults("font-variant-numeric", {
        "--tw-ordinal": " ",
        "--tw-slashed-zero": " ",
        "--tw-numeric-figure": " ",
        "--tw-numeric-spacing": " ",
        "--tw-numeric-fraction": " "
      });
      addUtilities({
        ".normal-nums": { "font-variant-numeric": "normal" },
        ".ordinal": {
          "@defaults font-variant-numeric": {},
          "--tw-ordinal": "ordinal",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".slashed-zero": {
          "@defaults font-variant-numeric": {},
          "--tw-slashed-zero": "slashed-zero",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".lining-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "lining-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".oldstyle-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "oldstyle-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".proportional-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "proportional-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".tabular-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "tabular-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".diagonal-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "diagonal-fractions",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".stacked-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "stacked-fractions",
          "font-variant-numeric": cssFontVariantNumericValue
        }
      });
    },
    lineHeight: createUtilityPlugin("lineHeight", [["leading", ["lineHeight"]]]),
    letterSpacing: createUtilityPlugin("letterSpacing", [["tracking", ["letterSpacing"]]], {
      supportsNegativeValues: true
    }),
    textColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          text: (value2) => {
            if (!corePlugins2("textOpacity")) {
              return { color: toColorValue(value2) };
            }
            return withAlphaVariable({
              color: value2,
              property: "color",
              variable: "--tw-text-opacity"
            });
          }
        },
        { values: flattenColorPalette_default(theme("textColor")), type: ["color", "any"] }
      );
    },
    textOpacity: createUtilityPlugin("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]),
    textDecoration: ({ addUtilities }) => {
      addUtilities({
        ".underline": { "text-decoration-line": "underline" },
        ".overline": { "text-decoration-line": "overline" },
        ".line-through": { "text-decoration-line": "line-through" },
        ".no-underline": { "text-decoration-line": "none" }
      });
    },
    textDecorationColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          decoration: (value2) => {
            return { "text-decoration-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("textDecorationColor")), type: ["color", "any"] }
      );
    },
    textDecorationStyle: ({ addUtilities }) => {
      addUtilities({
        ".decoration-solid": { "text-decoration-style": "solid" },
        ".decoration-double": { "text-decoration-style": "double" },
        ".decoration-dotted": { "text-decoration-style": "dotted" },
        ".decoration-dashed": { "text-decoration-style": "dashed" },
        ".decoration-wavy": { "text-decoration-style": "wavy" }
      });
    },
    textDecorationThickness: createUtilityPlugin(
      "textDecorationThickness",
      [["decoration", ["text-decoration-thickness"]]],
      { type: ["length", "percentage"] }
    ),
    textUnderlineOffset: createUtilityPlugin(
      "textUnderlineOffset",
      [["underline-offset", ["text-underline-offset"]]],
      { type: ["length", "percentage", "any"] }
    ),
    fontSmoothing: ({ addUtilities }) => {
      addUtilities({
        ".antialiased": {
          "-webkit-font-smoothing": "antialiased",
          "-moz-osx-font-smoothing": "grayscale"
        },
        ".subpixel-antialiased": {
          "-webkit-font-smoothing": "auto",
          "-moz-osx-font-smoothing": "auto"
        }
      });
    },
    placeholderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          placeholder: (value2) => {
            if (!corePlugins2("placeholderOpacity")) {
              return {
                "&::placeholder": {
                  color: toColorValue(value2)
                }
              };
            }
            return {
              "&::placeholder": withAlphaVariable({
                color: value2,
                property: "color",
                variable: "--tw-placeholder-opacity"
              })
            };
          }
        },
        { values: flattenColorPalette_default(theme("placeholderColor")), type: ["color", "any"] }
      );
    },
    placeholderOpacity: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "placeholder-opacity": (value2) => {
            return { ["&::placeholder"]: { "--tw-placeholder-opacity": value2 } };
          }
        },
        { values: theme("placeholderOpacity") }
      );
    },
    caretColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          caret: (value2) => {
            return { "caret-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("caretColor")), type: ["color", "any"] }
      );
    },
    accentColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          accent: (value2) => {
            return { "accent-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("accentColor")), type: ["color", "any"] }
      );
    },
    opacity: createUtilityPlugin("opacity", [["opacity", ["opacity"]]]),
    backgroundBlendMode: ({ addUtilities }) => {
      addUtilities({
        ".bg-blend-normal": { "background-blend-mode": "normal" },
        ".bg-blend-multiply": { "background-blend-mode": "multiply" },
        ".bg-blend-screen": { "background-blend-mode": "screen" },
        ".bg-blend-overlay": { "background-blend-mode": "overlay" },
        ".bg-blend-darken": { "background-blend-mode": "darken" },
        ".bg-blend-lighten": { "background-blend-mode": "lighten" },
        ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" },
        ".bg-blend-color-burn": { "background-blend-mode": "color-burn" },
        ".bg-blend-hard-light": { "background-blend-mode": "hard-light" },
        ".bg-blend-soft-light": { "background-blend-mode": "soft-light" },
        ".bg-blend-difference": { "background-blend-mode": "difference" },
        ".bg-blend-exclusion": { "background-blend-mode": "exclusion" },
        ".bg-blend-hue": { "background-blend-mode": "hue" },
        ".bg-blend-saturation": { "background-blend-mode": "saturation" },
        ".bg-blend-color": { "background-blend-mode": "color" },
        ".bg-blend-luminosity": { "background-blend-mode": "luminosity" }
      });
    },
    mixBlendMode: ({ addUtilities }) => {
      addUtilities({
        ".mix-blend-normal": { "mix-blend-mode": "normal" },
        ".mix-blend-multiply": { "mix-blend-mode": "multiply" },
        ".mix-blend-screen": { "mix-blend-mode": "screen" },
        ".mix-blend-overlay": { "mix-blend-mode": "overlay" },
        ".mix-blend-darken": { "mix-blend-mode": "darken" },
        ".mix-blend-lighten": { "mix-blend-mode": "lighten" },
        ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" },
        ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" },
        ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" },
        ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" },
        ".mix-blend-difference": { "mix-blend-mode": "difference" },
        ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" },
        ".mix-blend-hue": { "mix-blend-mode": "hue" },
        ".mix-blend-saturation": { "mix-blend-mode": "saturation" },
        ".mix-blend-color": { "mix-blend-mode": "color" },
        ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" },
        ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" }
      });
    },
    boxShadow: (() => {
      let transformValue = transformThemeValue("boxShadow");
      let defaultBoxShadow = [
        `var(--tw-ring-offset-shadow, 0 0 #0000)`,
        `var(--tw-ring-shadow, 0 0 #0000)`,
        `var(--tw-shadow)`
      ].join(", ");
      return function({ matchUtilities, addDefaults, theme }) {
        addDefaults(" box-shadow", {
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        });
        matchUtilities(
          {
            shadow: (value2) => {
              value2 = transformValue(value2);
              let ast = parseBoxShadowValue(value2);
              for (let shadow2 of ast) {
                if (!shadow2.valid) {
                  continue;
                }
                shadow2.color = "var(--tw-shadow-color)";
              }
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": value2 === "none" ? "0 0 #0000" : value2,
                "--tw-shadow-colored": value2 === "none" ? "0 0 #0000" : formatBoxShadowValue(ast),
                "box-shadow": defaultBoxShadow
              };
            }
          },
          { values: theme("boxShadow"), type: ["shadow"] }
        );
      };
    })(),
    boxShadowColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          shadow: (value2) => {
            return {
              "--tw-shadow-color": toColorValue(value2),
              "--tw-shadow": "var(--tw-shadow-colored)"
            };
          }
        },
        { values: flattenColorPalette_default(theme("boxShadowColor")), type: ["color", "any"] }
      );
    },
    outlineStyle: ({ addUtilities }) => {
      addUtilities({
        ".outline-none": {
          outline: "2px solid transparent",
          "outline-offset": "2px"
        },
        ".outline": { "outline-style": "solid" },
        ".outline-dashed": { "outline-style": "dashed" },
        ".outline-dotted": { "outline-style": "dotted" },
        ".outline-double": { "outline-style": "double" }
      });
    },
    outlineWidth: createUtilityPlugin("outlineWidth", [["outline", ["outline-width"]]], {
      type: ["length", "number", "percentage"]
    }),
    outlineOffset: createUtilityPlugin("outlineOffset", [["outline-offset", ["outline-offset"]]], {
      type: ["length", "number", "percentage", "any"],
      supportsNegativeValues: true
    }),
    outlineColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          outline: (value2) => {
            return { "outline-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("outlineColor")), type: ["color", "any"] }
      );
    },
    ringWidth: ({ matchUtilities, addDefaults, addUtilities, theme, config }) => {
      let ringColorDefault = (() => {
        if (flagEnabled2(config(), "respectDefaultRingColorOpacity")) {
          return theme("ringColor.DEFAULT");
        }
        let ringOpacityDefault = theme("ringOpacity.DEFAULT", "0.5");
        if (!theme("ringColor")?.DEFAULT) {
          return `rgb(147 197 253 / ${ringOpacityDefault})`;
        }
        return withAlphaValue(
          theme("ringColor")?.DEFAULT,
          ringOpacityDefault,
          `rgb(147 197 253 / ${ringOpacityDefault})`
        );
      })();
      addDefaults("ring-width", {
        "--tw-ring-inset": " ",
        "--tw-ring-offset-width": theme("ringOffsetWidth.DEFAULT", "0px"),
        "--tw-ring-offset-color": theme("ringOffsetColor.DEFAULT", "#fff"),
        "--tw-ring-color": ringColorDefault,
        "--tw-ring-offset-shadow": "0 0 #0000",
        "--tw-ring-shadow": "0 0 #0000",
        "--tw-shadow": "0 0 #0000",
        "--tw-shadow-colored": "0 0 #0000"
      });
      matchUtilities(
        {
          ring: (value2) => {
            return {
              "@defaults ring-width": {},
              "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
              "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${value2} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
              "box-shadow": [
                `var(--tw-ring-offset-shadow)`,
                `var(--tw-ring-shadow)`,
                `var(--tw-shadow, 0 0 #0000)`
              ].join(", ")
            };
          }
        },
        { values: theme("ringWidth"), type: "length" }
      );
      addUtilities({
        ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" }
      });
    },
    ringColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          ring: (value2) => {
            if (!corePlugins2("ringOpacity")) {
              return {
                "--tw-ring-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "--tw-ring-color",
              variable: "--tw-ring-opacity"
            });
          }
        },
        {
          values: Object.fromEntries(
            Object.entries(flattenColorPalette_default(theme("ringColor"))).filter(
              ([modifier]) => modifier !== "DEFAULT"
            )
          ),
          type: ["color", "any"]
        }
      );
    },
    ringOpacity: (helpers) => {
      let { config } = helpers;
      return createUtilityPlugin("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], {
        filterDefault: !flagEnabled2(config(), "respectDefaultRingColorOpacity")
      })(helpers);
    },
    ringOffsetWidth: createUtilityPlugin(
      "ringOffsetWidth",
      [["ring-offset", ["--tw-ring-offset-width"]]],
      { type: "length" }
    ),
    ringOffsetColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "ring-offset": (value2) => {
            return {
              "--tw-ring-offset-color": toColorValue(value2)
            };
          }
        },
        { values: flattenColorPalette_default(theme("ringOffsetColor")), type: ["color", "any"] }
      );
    },
    blur: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          blur: (value2) => {
            return {
              "--tw-blur": `blur(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("blur") }
      );
    },
    brightness: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          brightness: (value2) => {
            return {
              "--tw-brightness": `brightness(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("brightness") }
      );
    },
    contrast: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          contrast: (value2) => {
            return {
              "--tw-contrast": `contrast(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("contrast") }
      );
    },
    dropShadow: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "drop-shadow": (value2) => {
            return {
              "--tw-drop-shadow": Array.isArray(value2) ? value2.map((v2) => `drop-shadow(${v2})`).join(" ") : `drop-shadow(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("dropShadow") }
      );
    },
    grayscale: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          grayscale: (value2) => {
            return {
              "--tw-grayscale": `grayscale(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("grayscale") }
      );
    },
    hueRotate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "hue-rotate": (value2) => {
            return {
              "--tw-hue-rotate": `hue-rotate(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("hueRotate"), supportsNegativeValues: true }
      );
    },
    invert: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          invert: (value2) => {
            return {
              "--tw-invert": `invert(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("invert") }
      );
    },
    saturate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          saturate: (value2) => {
            return {
              "--tw-saturate": `saturate(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("saturate") }
      );
    },
    sepia: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          sepia: (value2) => {
            return {
              "--tw-sepia": `sepia(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("sepia") }
      );
    },
    filter: ({ addDefaults, addUtilities }) => {
      addDefaults("filter", {
        "--tw-blur": " ",
        "--tw-brightness": " ",
        "--tw-contrast": " ",
        "--tw-grayscale": " ",
        "--tw-hue-rotate": " ",
        "--tw-invert": " ",
        "--tw-saturate": " ",
        "--tw-sepia": " ",
        "--tw-drop-shadow": " "
      });
      addUtilities({
        ".filter": { "@defaults filter": {}, filter: cssFilterValue },
        ".filter-none": { filter: "none" }
      });
    },
    backdropBlur: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-blur": (value2) => {
            return {
              "--tw-backdrop-blur": `blur(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropBlur") }
      );
    },
    backdropBrightness: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-brightness": (value2) => {
            return {
              "--tw-backdrop-brightness": `brightness(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropBrightness") }
      );
    },
    backdropContrast: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-contrast": (value2) => {
            return {
              "--tw-backdrop-contrast": `contrast(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropContrast") }
      );
    },
    backdropGrayscale: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-grayscale": (value2) => {
            return {
              "--tw-backdrop-grayscale": `grayscale(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropGrayscale") }
      );
    },
    backdropHueRotate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-hue-rotate": (value2) => {
            return {
              "--tw-backdrop-hue-rotate": `hue-rotate(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropHueRotate"), supportsNegativeValues: true }
      );
    },
    backdropInvert: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-invert": (value2) => {
            return {
              "--tw-backdrop-invert": `invert(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropInvert") }
      );
    },
    backdropOpacity: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-opacity": (value2) => {
            return {
              "--tw-backdrop-opacity": `opacity(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropOpacity") }
      );
    },
    backdropSaturate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-saturate": (value2) => {
            return {
              "--tw-backdrop-saturate": `saturate(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropSaturate") }
      );
    },
    backdropSepia: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-sepia": (value2) => {
            return {
              "--tw-backdrop-sepia": `sepia(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropSepia") }
      );
    },
    backdropFilter: ({ addDefaults, addUtilities }) => {
      addDefaults("backdrop-filter", {
        "--tw-backdrop-blur": " ",
        "--tw-backdrop-brightness": " ",
        "--tw-backdrop-contrast": " ",
        "--tw-backdrop-grayscale": " ",
        "--tw-backdrop-hue-rotate": " ",
        "--tw-backdrop-invert": " ",
        "--tw-backdrop-opacity": " ",
        "--tw-backdrop-saturate": " ",
        "--tw-backdrop-sepia": " "
      });
      addUtilities({
        ".backdrop-filter": {
          "@defaults backdrop-filter": {},
          "backdrop-filter": cssBackdropFilterValue
        },
        ".backdrop-filter-none": { "backdrop-filter": "none" }
      });
    },
    transitionProperty: ({ matchUtilities, theme }) => {
      let defaultTimingFunction = theme("transitionTimingFunction.DEFAULT");
      let defaultDuration = theme("transitionDuration.DEFAULT");
      matchUtilities(
        {
          transition: (value2) => {
            return {
              "transition-property": value2,
              ...value2 === "none" ? {} : {
                "transition-timing-function": defaultTimingFunction,
                "transition-duration": defaultDuration
              }
            };
          }
        },
        { values: theme("transitionProperty") }
      );
    },
    transitionDelay: createUtilityPlugin("transitionDelay", [["delay", ["transitionDelay"]]]),
    transitionDuration: createUtilityPlugin(
      "transitionDuration",
      [["duration", ["transitionDuration"]]],
      { filterDefault: true }
    ),
    transitionTimingFunction: createUtilityPlugin(
      "transitionTimingFunction",
      [["ease", ["transitionTimingFunction"]]],
      { filterDefault: true }
    ),
    willChange: createUtilityPlugin("willChange", [["will-change", ["will-change"]]]),
    content: createUtilityPlugin("content", [
      ["content", ["--tw-content", ["content", "var(--tw-content)"]]]
    ])
  };
  function toPath(path) {
    if (Array.isArray(path)) return path;
    let openBrackets = path.split("[").length - 1;
    let closedBrackets = path.split("]").length - 1;
    if (openBrackets !== closedBrackets) {
      throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
    }
    return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
  var matchingBrackets = /* @__PURE__ */ new Map([
    ["{", "}"],
    ["[", "]"],
    ["(", ")"]
  ]);
  var inverseMatchingBrackets = new Map(
    Array.from(matchingBrackets.entries()).map(([k5, v2]) => [v2, k5])
  );
  var quotes = /* @__PURE__ */ new Set(['"', "'", "`"]);
  function isSyntacticallyValidPropertyValue(value2) {
    let stack = [];
    let inQuotes = false;
    for (let i2 = 0; i2 < value2.length; i2++) {
      let char = value2[i2];
      if (char === ":" && !inQuotes && stack.length === 0) {
        return false;
      }
      if (quotes.has(char) && value2[i2 - 1] !== "\\") {
        inQuotes = !inQuotes;
      }
      if (inQuotes) continue;
      if (value2[i2 - 1] === "\\") continue;
      if (matchingBrackets.has(char)) {
        stack.push(char);
      } else if (inverseMatchingBrackets.has(char)) {
        let inverse = inverseMatchingBrackets.get(char);
        if (stack.length <= 0) {
          return false;
        }
        if (stack.pop() !== inverse) {
          return false;
        }
      }
    }
    if (stack.length > 0) {
      return false;
    }
    return true;
  }
  function bigSign2(bigIntValue) {
    return (bigIntValue > 0n) - (bigIntValue < 0n);
  }
  function remapBitfield(num3, mapping) {
    let oldMask = 0n;
    let newMask = 0n;
    for (let [oldBit, newBit] of mapping) {
      if (num3 & oldBit) {
        oldMask = oldMask | oldBit;
        newMask = newMask | newBit;
      }
    }
    return num3 & ~oldMask | newMask;
  }
  var Offsets = class {
    constructor() {
      this.offsets = {
        defaults: 0n,
        base: 0n,
        components: 0n,
        utilities: 0n,
        variants: 0n,
        user: 0n
      };
      this.layerPositions = {
        defaults: 0n,
        base: 1n,
        components: 2n,
        utilities: 3n,
        // There isn't technically a "user" layer, but we need to give it a position
        // Because it's used for ordering user-css from @apply
        user: 4n,
        variants: 5n
      };
      this.reservedVariantBits = 0n;
      this.variantOffsets = /* @__PURE__ */ new Map();
    }
    /**
     * @param {Layer} layer
     * @returns {RuleOffset}
     */
    create(layer) {
      return {
        layer,
        parentLayer: layer,
        arbitrary: 0n,
        variants: 0n,
        parallelIndex: 0n,
        index: this.offsets[layer]++,
        options: []
      };
    }
    /**
     * @returns {RuleOffset}
     */
    arbitraryProperty() {
      return {
        ...this.create("utilities"),
        arbitrary: 1n
      };
    }
    /**
     * Get the offset for a variant
     *
     * @param {string} variant
     * @param {number} index
     * @returns {RuleOffset}
     */
    forVariant(variant, index2 = 0) {
      let offset = this.variantOffsets.get(variant);
      if (offset === void 0) {
        throw new Error(`Cannot find offset for unknown variant ${variant}`);
      }
      return {
        ...this.create("variants"),
        variants: offset << BigInt(index2)
      };
    }
    /**
     * @param {RuleOffset} rule
     * @param {RuleOffset} variant
     * @param {VariantOption} options
     * @returns {RuleOffset}
     */
    applyVariantOffset(rule2, variant, options) {
      options.variant = variant.variants;
      return {
        ...rule2,
        layer: "variants",
        parentLayer: rule2.layer === "variants" ? rule2.parentLayer : rule2.layer,
        variants: rule2.variants | variant.variants,
        options: options.sort ? [].concat(options, rule2.options) : rule2.options,
        // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
        // We'll take the max of all the parallel indexes for now.
        // @ts-ignore
        parallelIndex: max([rule2.parallelIndex, variant.parallelIndex])
      };
    }
    /**
     * @param {RuleOffset} offset
     * @param {number} parallelIndex
     * @returns {RuleOffset}
     */
    applyParallelOffset(offset, parallelIndex) {
      return {
        ...offset,
        parallelIndex: BigInt(parallelIndex)
      };
    }
    /**
     * Each variant gets 1 bit per function / rule registered.
     * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
     * Additionally, every unique group of variants is grouped together in the stylesheet.
     *
     * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
     *
     * @param {string[]} variants
     * @param {(name: string) => number} getLength
     */
    recordVariants(variants, getLength) {
      for (let variant of variants) {
        this.recordVariant(variant, getLength(variant));
      }
    }
    /**
     * The same as `recordVariants` but for a single arbitrary variant at runtime.
     * @param {string} variant
     * @param {number} fnCount
     *
     * @returns {RuleOffset} The highest offset for this variant
     */
    recordVariant(variant, fnCount = 1) {
      this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
      this.reservedVariantBits += BigInt(fnCount);
      return {
        ...this.create("variants"),
        variants: this.variantOffsets.get(variant)
      };
    }
    /**
     * @param {RuleOffset} a
     * @param {RuleOffset} b
     * @returns {bigint}
     */
    compare(a2, b2) {
      if (a2.layer !== b2.layer) {
        return this.layerPositions[a2.layer] - this.layerPositions[b2.layer];
      }
      if (a2.parentLayer !== b2.parentLayer) {
        return this.layerPositions[a2.parentLayer] - this.layerPositions[b2.parentLayer];
      }
      for (let aOptions of a2.options) {
        for (let bOptions of b2.options) {
          if (aOptions.id !== bOptions.id) continue;
          if (!aOptions.sort || !bOptions.sort) continue;
          let maxFnVariant = max([aOptions.variant, bOptions.variant]) ?? 0n;
          let mask = ~(maxFnVariant | maxFnVariant - 1n);
          let aVariantsAfterFn = a2.variants & mask;
          let bVariantsAfterFn = b2.variants & mask;
          if (aVariantsAfterFn !== bVariantsAfterFn) {
            continue;
          }
          let result = aOptions.sort(
            {
              value: aOptions.value,
              modifier: aOptions.modifier
            },
            {
              value: bOptions.value,
              modifier: bOptions.modifier
            }
          );
          if (result !== 0) return result;
        }
      }
      if (a2.variants !== b2.variants) {
        return a2.variants - b2.variants;
      }
      if (a2.parallelIndex !== b2.parallelIndex) {
        return a2.parallelIndex - b2.parallelIndex;
      }
      if (a2.arbitrary !== b2.arbitrary) {
        return a2.arbitrary - b2.arbitrary;
      }
      return a2.index - b2.index;
    }
    /**
     * Arbitrary variants are recorded in the order they're encountered.
     * This means that the order is not stable between environments and sets of content files.
     *
     * In order to make the order stable, we need to remap the arbitrary variant offsets to
     * be in alphabetical order starting from the offset of the first arbitrary variant.
     */
    recalculateVariantOffsets() {
      let variants = Array.from(this.variantOffsets.entries()).filter(([v2]) => v2.startsWith("[")).sort(([a2], [z2]) => fastCompare(a2, z2));
      let newOffsets = variants.map(([, offset]) => offset).sort((a2, z2) => bigSign2(a2 - z2));
      let mapping = variants.map(([, oldOffset], i2) => [oldOffset, newOffsets[i2]]);
      return mapping.filter(([a2, z2]) => a2 !== z2);
    }
    /**
     * @template T
     * @param {[RuleOffset, T][]} list
     * @returns {[RuleOffset, T][]}
     */
    remapArbitraryVariantOffsets(list22) {
      let mapping = this.recalculateVariantOffsets();
      if (mapping.length === 0) {
        return list22;
      }
      return list22.map((item) => {
        let [offset, rule2] = item;
        offset = {
          ...offset,
          variants: remapBitfield(offset.variants, mapping)
        };
        return [offset, rule2];
      });
    }
    /**
     * @template T
     * @param {[RuleOffset, T][]} list
     * @returns {[RuleOffset, T][]}
     */
    sort(list22) {
      list22 = this.remapArbitraryVariantOffsets(list22);
      return list22.sort(([a2], [b2]) => bigSign2(this.compare(a2, b2)));
    }
  };
  function max(nums) {
    let max2 = null;
    for (const num3 of nums) {
      max2 = max2 ?? num3;
      max2 = max2 > num3 ? max2 : num3;
    }
    return max2;
  }
  function fastCompare(a2, b2) {
    let aLen = a2.length;
    let bLen = b2.length;
    let minLen = aLen < bLen ? aLen : bLen;
    for (let i2 = 0; i2 < minLen; i2++) {
      let cmp = a2.charCodeAt(i2) - b2.charCodeAt(i2);
      if (cmp !== 0) return cmp;
    }
    return aLen - bLen;
  }
  var INTERNAL_FEATURES = Symbol();
  var VARIANT_TYPES = {
    AddVariant: Symbol.for("ADD_VARIANT"),
    MatchVariant: Symbol.for("MATCH_VARIANT")
  };
  var VARIANT_INFO = {
    Base: 1 << 0,
    Dynamic: 1 << 1
  };
  function prefix(context, selector) {
    let prefix3 = context.tailwindConfig.prefix;
    return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
  }
  function normalizeOptionTypes({ type = "any", ...options }) {
    let types2 = [].concat(type);
    return {
      ...options,
      types: types2.map((type2) => {
        if (Array.isArray(type2)) {
          return { type: type2[0], ...type2[1] };
        }
        return { type: type2, preferOnConflict: false };
      })
    };
  }
  function parseVariantFormatString(input) {
    let parts = [];
    let current = "";
    let depth = 0;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (char === "\\") {
        current += "\\" + input[++idx];
      } else if (char === "{") {
        ++depth;
        parts.push(current.trim());
        current = "";
      } else if (char === "}") {
        if (--depth < 0) {
          throw new Error(`Your { and } are unbalanced.`);
        }
        parts.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }
    if (current.length > 0) {
      parts.push(current.trim());
    }
    parts = parts.filter((part) => part !== "");
    return parts;
  }
  function insertInto(list22, value2, { before = [] } = {}) {
    before = [].concat(before);
    if (before.length <= 0) {
      list22.push(value2);
      return;
    }
    let idx = list22.length - 1;
    for (let other of before) {
      let iidx = list22.indexOf(other);
      if (iidx === -1) continue;
      idx = Math.min(idx, iidx);
    }
    list22.splice(idx, 0, value2);
  }
  function parseStyles(styles) {
    if (!Array.isArray(styles)) {
      return parseStyles([styles]);
    }
    return styles.flatMap((style) => {
      let isNode = !Array.isArray(style) && !isPlainObject(style);
      return isNode ? style : parseObjectStyles(style);
    });
  }
  function getClasses(selector, mutate) {
    let parser5 = (0, import_postcss_selector_parser8.default)((selectors) => {
      let allClasses = [];
      if (mutate) {
        mutate(selectors);
      }
      selectors.walkClasses((classNode) => {
        allClasses.push(classNode.value);
      });
      return allClasses;
    });
    return parser5.transformSync(selector);
  }
  function ignoreNot(selectors) {
    selectors.walkPseudos((pseudo) => {
      if (pseudo.value === ":not") {
        pseudo.remove();
      }
    });
  }
  function extractCandidates(node, state = { containsNonOnDemandable: false }, depth = 0) {
    let classes = [];
    let selectors = [];
    if (node.type === "rule") {
      selectors.push(...node.selectors);
    } else if (node.type === "atrule") {
      node.walkRules((rule2) => selectors.push(...rule2.selectors));
    }
    for (let selector of selectors) {
      let classCandidates = getClasses(selector, ignoreNot);
      if (classCandidates.length === 0) {
        state.containsNonOnDemandable = true;
      }
      for (let classCandidate of classCandidates) {
        classes.push(classCandidate);
      }
    }
    if (depth === 0) {
      return [state.containsNonOnDemandable || classes.length === 0, classes];
    }
    return classes;
  }
  function withIdentifiers(styles) {
    return parseStyles(styles).flatMap((node) => {
      let nodeMap = /* @__PURE__ */ new Map();
      let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
      if (containsNonOnDemandableSelectors) {
        candidates.unshift(NOT_ON_DEMAND);
      }
      return candidates.map((c3) => {
        if (!nodeMap.has(node)) {
          nodeMap.set(node, node);
        }
        return [c3, nodeMap.get(node)];
      });
    });
  }
  function isValidVariantFormatString(format) {
    return format.startsWith("@") || format.includes("&");
  }
  function parseVariant(variant) {
    variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    let fns = parseVariantFormatString(variant).map((str) => {
      if (!str.startsWith("@")) {
        return ({ format }) => format(str);
      }
      let [, name, params] = /@(\S*)( .+|[({].*)?/g.exec(str);
      return ({ wrap }) => wrap(postcss_default.atRule({ name, params: params?.trim() ?? "" }));
    }).reverse();
    return (api) => {
      for (let fn5 of fns) {
        fn5(api);
      }
    };
  }
  function buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets, classList }) {
    function getConfigValue(path, defaultValue) {
      return path ? (0, import_dlv12.default)(tailwindConfig, path, defaultValue) : tailwindConfig;
    }
    function applyConfiguredPrefix(selector) {
      return prefixSelector_default(tailwindConfig.prefix, selector);
    }
    function prefixIdentifier(identifier, options) {
      if (identifier === NOT_ON_DEMAND) {
        return NOT_ON_DEMAND;
      }
      if (!options.respectPrefix) {
        return identifier;
      }
      return context.tailwindConfig.prefix + identifier;
    }
    function resolveThemeValue(path, defaultValue, opts = {}) {
      let parts = toPath(path);
      let value2 = getConfigValue(["theme", ...parts], defaultValue);
      return transformThemeValue(parts[0])(value2, opts);
    }
    let variantIdentifier = 0;
    let api = {
      postcss: postcss_default,
      prefix: applyConfiguredPrefix,
      e: escapeClassName2,
      config: getConfigValue,
      theme: resolveThemeValue,
      corePlugins: (path) => {
        if (Array.isArray(tailwindConfig.corePlugins)) {
          return tailwindConfig.corePlugins.includes(path);
        }
        return getConfigValue(["corePlugins", path], true);
      },
      variants: () => {
        return [];
      },
      addBase(base) {
        for (let [identifier, rule2] of withIdentifiers(base)) {
          let prefixedIdentifier = prefixIdentifier(identifier, {});
          let offset = offsets.create("base");
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offset, layer: "base" }, rule2]);
        }
      },
      /**
       * @param {string} group
       * @param {Record<string, string | string[]>} declarations
       */
      addDefaults(group, declarations) {
        const groups = {
          [`@defaults ${group}`]: declarations
        };
        for (let [identifier, rule2] of withIdentifiers(groups)) {
          let prefixedIdentifier = prefixIdentifier(identifier, {});
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("defaults"), layer: "defaults" }, rule2]);
        }
      },
      addComponents(components, options) {
        let defaultOptions = {
          preserveSource: false,
          respectPrefix: true,
          respectImportant: false
        };
        options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
        for (let [identifier, rule2] of withIdentifiers(components)) {
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("components"), layer: "components", options }, rule2]);
        }
      },
      addUtilities(utilities, options) {
        let defaultOptions = {
          preserveSource: false,
          respectPrefix: true,
          respectImportant: true
        };
        options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
        for (let [identifier, rule2] of withIdentifiers(utilities)) {
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("utilities"), layer: "utilities", options }, rule2]);
        }
      },
      matchUtilities: function(utilities, options) {
        let defaultOptions = {
          respectPrefix: true,
          respectImportant: true,
          modifiers: false
        };
        options = normalizeOptionTypes({ ...defaultOptions, ...options });
        let offset = offsets.create("utilities");
        for (let identifier in utilities) {
          let wrapped = function(modifier, { isOnlyPlugin }) {
            let [value2, coercedType, utilityModifier] = coerceValue(
              options.types,
              modifier,
              options,
              tailwindConfig
            );
            if (value2 === void 0) {
              return [];
            }
            if (!options.types.some(({ type }) => type === coercedType)) {
              if (isOnlyPlugin) {
                log_default.warn([
                  `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                  `You can safely update it to \`${identifier}-${modifier.replace(
                    coercedType + ":",
                    ""
                  )}\`.`
                ]);
              } else {
                return [];
              }
            }
            if (!isSyntacticallyValidPropertyValue(value2)) {
              return [];
            }
            let extras = {
              get modifier() {
                if (!options.modifiers) {
                  log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]);
                }
                return utilityModifier;
              }
            };
            let modifiersEnabled = flagEnabled2(tailwindConfig, "generalizedModifiers");
            let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration
            }));
            return ruleSets;
          };
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          let rule2 = utilities[identifier];
          classList.add([prefixedIdentifier, options]);
          let withOffsets = [{ sort: offset, layer: "utilities", options }, wrapped];
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
        }
      },
      matchComponents: function(components, options) {
        let defaultOptions = {
          respectPrefix: true,
          respectImportant: false,
          modifiers: false
        };
        options = normalizeOptionTypes({ ...defaultOptions, ...options });
        let offset = offsets.create("components");
        for (let identifier in components) {
          let wrapped = function(modifier, { isOnlyPlugin }) {
            let [value2, coercedType, utilityModifier] = coerceValue(
              options.types,
              modifier,
              options,
              tailwindConfig
            );
            if (value2 === void 0) {
              return [];
            }
            if (!options.types.some(({ type }) => type === coercedType)) {
              if (isOnlyPlugin) {
                log_default.warn([
                  `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                  `You can safely update it to \`${identifier}-${modifier.replace(
                    coercedType + ":",
                    ""
                  )}\`.`
                ]);
              } else {
                return [];
              }
            }
            if (!isSyntacticallyValidPropertyValue(value2)) {
              return [];
            }
            let extras = {
              get modifier() {
                if (!options.modifiers) {
                  log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]);
                }
                return utilityModifier;
              }
            };
            let modifiersEnabled = flagEnabled2(tailwindConfig, "generalizedModifiers");
            let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration
            }));
            return ruleSets;
          };
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          let rule2 = components[identifier];
          classList.add([prefixedIdentifier, options]);
          let withOffsets = [{ sort: offset, layer: "components", options }, wrapped];
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
        }
      },
      addVariant(variantName, variantFunctions, options = {}) {
        variantFunctions = [].concat(variantFunctions).map((variantFunction) => {
          if (typeof variantFunction !== "string") {
            return (api2 = {}) => {
              let { args, modifySelectors, container, separator, wrap, format } = api2;
              let result = variantFunction(
                Object.assign(
                  { modifySelectors, container, separator },
                  options.type === VARIANT_TYPES.MatchVariant && { args, wrap, format }
                )
              );
              if (typeof result === "string" && !isValidVariantFormatString(result)) {
                throw new Error(
                  `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
                );
              }
              if (Array.isArray(result)) {
                return result.filter((variant) => typeof variant === "string").map((variant) => parseVariant(variant));
              }
              return result && typeof result === "string" && parseVariant(result)(api2);
            };
          }
          if (!isValidVariantFormatString(variantFunction)) {
            throw new Error(
              `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
            );
          }
          return parseVariant(variantFunction);
        });
        insertInto(variantList, variantName, options);
        variantMap.set(variantName, variantFunctions);
        context.variantOptions.set(variantName, options);
      },
      matchVariant(variant, variantFn, options) {
        let id = options?.id ?? ++variantIdentifier;
        let isSpecial = variant === "@";
        let modifiersEnabled = flagEnabled2(tailwindConfig, "generalizedModifiers");
        for (let [key, value2] of Object.entries(options?.values ?? {})) {
          if (key === "DEFAULT") continue;
          api.addVariant(
            isSpecial ? `${variant}${key}` : `${variant}-${key}`,
            ({ args, container }) => {
              return variantFn(
                value2,
                modifiersEnabled ? { modifier: args?.modifier, container } : { container }
              );
            },
            {
              ...options,
              value: value2,
              id,
              type: VARIANT_TYPES.MatchVariant,
              variantInfo: VARIANT_INFO.Base
            }
          );
        }
        let hasDefault = "DEFAULT" in (options?.values ?? {});
        api.addVariant(
          variant,
          ({ args, container }) => {
            if (args?.value === NONE && !hasDefault) {
              return null;
            }
            return variantFn(
              args?.value === NONE ? options.values.DEFAULT : (
                // Falling back to args if it is a string, otherwise '' for older intellisense
                // (JetBrains) plugins.
                args?.value ?? (typeof args === "string" ? args : "")
              ),
              modifiersEnabled ? { modifier: args?.modifier, container } : { container }
            );
          },
          {
            ...options,
            id,
            type: VARIANT_TYPES.MatchVariant,
            variantInfo: VARIANT_INFO.Dynamic
          }
        );
      }
    };
    return api;
  }
  function extractVariantAtRules(node) {
    node.walkAtRules((atRule22) => {
      if (["responsive", "variants"].includes(atRule22.name)) {
        extractVariantAtRules(atRule22);
        atRule22.before(atRule22.nodes);
        atRule22.remove();
      }
    });
  }
  function collectLayerPlugins(root2) {
    let layerPlugins = [];
    root2.each((node) => {
      if (node.type === "atrule" && ["responsive", "variants"].includes(node.name)) {
        node.name = "layer";
        node.params = "utilities";
      }
    });
    root2.walkAtRules("layer", (layerRule) => {
      extractVariantAtRules(layerRule);
      if (layerRule.params === "base") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addBase }) {
            addBase(node, { respectPrefix: false });
          });
        }
        layerRule.remove();
      } else if (layerRule.params === "components") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addComponents }) {
            addComponents(node, { respectPrefix: false, preserveSource: true });
          });
        }
        layerRule.remove();
      } else if (layerRule.params === "utilities") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addUtilities }) {
            addUtilities(node, { respectPrefix: false, preserveSource: true });
          });
        }
        layerRule.remove();
      }
    });
    return layerPlugins;
  }
  function resolvePlugins(context, root2) {
    let corePluginList = Object.entries({ ...variantPlugins, ...corePlugins }).map(([name, plugin2]) => {
      if (!context.tailwindConfig.corePlugins.includes(name)) {
        return null;
      }
      return plugin2;
    }).filter(Boolean);
    let userPlugins = context.tailwindConfig.plugins.map((plugin2) => {
      if (plugin2.__isOptionsFunction) {
        plugin2 = plugin2();
      }
      return typeof plugin2 === "function" ? plugin2 : plugin2.handler;
    });
    let layerPlugins = collectLayerPlugins(root2);
    let beforeVariants = [
      variantPlugins["pseudoElementVariants"],
      variantPlugins["pseudoClassVariants"],
      variantPlugins["ariaVariants"],
      variantPlugins["dataVariants"]
    ];
    let afterVariants = [
      variantPlugins["supportsVariants"],
      variantPlugins["directionVariants"],
      variantPlugins["reducedMotionVariants"],
      variantPlugins["prefersContrastVariants"],
      variantPlugins["darkVariants"],
      variantPlugins["printVariant"],
      variantPlugins["screenVariants"],
      variantPlugins["orientationVariants"]
    ];
    return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];
  }
  function registerPlugins(plugins, context) {
    let variantList = [];
    let variantMap = /* @__PURE__ */ new Map();
    context.variantMap = variantMap;
    let offsets = new Offsets();
    context.offsets = offsets;
    let classList = /* @__PURE__ */ new Set();
    let pluginApi = buildPluginApi(context.tailwindConfig, context, {
      variantList,
      variantMap,
      offsets,
      classList
    });
    for (let plugin2 of plugins) {
      if (Array.isArray(plugin2)) {
        for (let pluginItem of plugin2) {
          pluginItem(pluginApi);
        }
      } else {
        plugin2?.(pluginApi);
      }
    }
    offsets.recordVariants(variantList, (variant) => variantMap.get(variant).length);
    for (let [variantName, variantFunctions] of variantMap.entries()) {
      context.variantMap.set(
        variantName,
        variantFunctions.map((variantFunction, idx) => [
          offsets.forVariant(variantName, idx),
          variantFunction
        ])
      );
    }
    let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean);
    if (safelist.length > 0) {
      let checks = [];
      for (let value2 of safelist) {
        if (typeof value2 === "string") {
          context.changedContent.push({ content: value2, extension: "html" });
          continue;
        }
        if (value2 instanceof RegExp) {
          log_default.warn("root-regex", [
            "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
            "Update your `safelist` configuration to eliminate this warning.",
            "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
          ]);
          continue;
        }
        checks.push(value2);
      }
      if (checks.length > 0) {
        let patternMatchingCount = /* @__PURE__ */ new Map();
        let prefixLength = context.tailwindConfig.prefix.length;
        let checkImportantUtils = checks.some((check) => check.pattern.source.includes("!"));
        for (let util of classList) {
          let utils = Array.isArray(util) ? (() => {
            let [utilName, options] = util;
            let values = Object.keys(options?.values ?? {});
            let classes = values.map((value2) => formatClass(utilName, value2));
            if (options?.supportsNegativeValues) {
              classes = [...classes, ...classes.map((cls) => "-" + cls)];
              classes = [
                ...classes,
                ...classes.map(
                  (cls) => cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength)
                )
              ];
            }
            if (options.types.some(({ type }) => type === "color")) {
              classes = [
                ...classes,
                ...classes.flatMap(
                  (cls) => Object.keys(context.tailwindConfig.theme.opacity).map(
                    (opacity) => `${cls}/${opacity}`
                  )
                )
              ];
            }
            if (checkImportantUtils && options?.respectImportant) {
              classes = [...classes, ...classes.map((cls) => "!" + cls)];
            }
            return classes;
          })() : [util];
          for (let util2 of utils) {
            for (let { pattern: pattern2, variants = [] } of checks) {
              pattern2.lastIndex = 0;
              if (!patternMatchingCount.has(pattern2)) {
                patternMatchingCount.set(pattern2, 0);
              }
              if (!pattern2.test(util2)) continue;
              patternMatchingCount.set(pattern2, patternMatchingCount.get(pattern2) + 1);
              context.changedContent.push({ content: util2, extension: "html" });
              for (let variant of variants) {
                context.changedContent.push({
                  content: variant + context.tailwindConfig.separator + util2,
                  extension: "html"
                });
              }
            }
          }
        }
        for (let [regex, count] of patternMatchingCount.entries()) {
          if (count !== 0) continue;
          log_default.warn([
            `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
            "Fix this pattern or remove it from your `safelist` configuration.",
            "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
          ]);
        }
      }
    }
    let darkClassName = [].concat(context.tailwindConfig.darkMode ?? "media")[1] ?? "dark";
    let parasiteUtilities = [
      prefix(context, darkClassName),
      prefix(context, "group"),
      prefix(context, "peer")
    ];
    context.getClassOrder = function getClassOrder(classes) {
      let sorted = [...classes].sort((a2, z2) => {
        if (a2 === z2) return 0;
        if (a2 < z2) return -1;
        return 1;
      });
      let sortedClassNames = new Map(sorted.map((className) => [className, null]));
      let rules = generateRules2(new Set(sorted), context, true);
      rules = context.offsets.sort(rules);
      let idx = BigInt(parasiteUtilities.length);
      for (const [, rule2] of rules) {
        let candidate = rule2.raws.tailwind.candidate;
        sortedClassNames.set(candidate, sortedClassNames.get(candidate) ?? idx++);
      }
      return classes.map((className) => {
        let order = sortedClassNames.get(className) ?? null;
        let parasiteIndex = parasiteUtilities.indexOf(className);
        if (order === null && parasiteIndex !== -1) {
          order = BigInt(parasiteIndex);
        }
        return [className, order];
      });
    };
    context.getClassList = function getClassList(options = {}) {
      let output = [];
      for (let util of classList) {
        if (Array.isArray(util)) {
          let [utilName, utilOptions] = util;
          let negativeClasses = [];
          let modifiers = Object.keys(utilOptions?.modifiers ?? {});
          if (utilOptions?.types?.some(({ type }) => type === "color")) {
            modifiers.push(...Object.keys(context.tailwindConfig.theme.opacity ?? {}));
          }
          let metadata = { modifiers };
          let includeMetadata = options.includeMetadata && modifiers.length > 0;
          for (let [key, value2] of Object.entries(utilOptions?.values ?? {})) {
            if (value2 == null) {
              continue;
            }
            let cls = formatClass(utilName, key);
            output.push(includeMetadata ? [cls, metadata] : cls);
            if (utilOptions?.supportsNegativeValues && negateValue(value2)) {
              let cls2 = formatClass(utilName, `-${key}`);
              negativeClasses.push(includeMetadata ? [cls2, metadata] : cls2);
            }
          }
          output.push(...negativeClasses);
        } else {
          output.push(util);
        }
      }
      return output;
    };
    context.getVariants = function getVariants() {
      let result = [];
      for (let [name, options] of context.variantOptions.entries()) {
        if (options.variantInfo === VARIANT_INFO.Base) continue;
        result.push({
          name,
          isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
          values: Object.keys(options.values ?? {}),
          hasDash: name !== "@",
          selectors({ modifier, value: value2 } = {}) {
            let candidate = "__TAILWIND_PLACEHOLDER__";
            let rule2 = postcss_default.rule({ selector: `.${candidate}` });
            let container = postcss_default.root({ nodes: [rule2.clone()] });
            let before = container.toString();
            let fns = (context.variantMap.get(name) ?? []).flatMap(([_2, fn5]) => fn5);
            let formatStrings = [];
            for (let fn5 of fns) {
              let localFormatStrings = [];
              let api = {
                args: { modifier, value: options.values?.[value2] ?? value2 },
                separator: context.tailwindConfig.separator,
                modifySelectors(modifierFunction) {
                  container.each((rule3) => {
                    if (rule3.type !== "rule") {
                      return;
                    }
                    rule3.selectors = rule3.selectors.map((selector) => {
                      return modifierFunction({
                        get className() {
                          return getClassNameFromSelector(selector);
                        },
                        selector
                      });
                    });
                  });
                  return container;
                },
                format(str) {
                  localFormatStrings.push(str);
                },
                wrap(wrapper) {
                  localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
                },
                container
              };
              let ruleWithVariant = fn5(api);
              if (localFormatStrings.length > 0) {
                formatStrings.push(localFormatStrings);
              }
              if (Array.isArray(ruleWithVariant)) {
                for (let variantFunction of ruleWithVariant) {
                  localFormatStrings = [];
                  variantFunction(api);
                  formatStrings.push(localFormatStrings);
                }
              }
            }
            let manualFormatStrings = [];
            let after = container.toString();
            if (before !== after) {
              container.walkRules((rule3) => {
                let modified = rule3.selector;
                let rebuiltBase = (0, import_postcss_selector_parser8.default)((selectors) => {
                  selectors.walkClasses((classNode) => {
                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                  });
                }).processSync(modified);
                manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
              });
              container.walkAtRules((atrule) => {
                manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
              });
            }
            let isArbitraryVariant = !(value2 in (options.values ?? {}));
            let internalFeatures = options[INTERNAL_FEATURES] ?? {};
            let respectPrefix = (() => {
              if (isArbitraryVariant) return false;
              if (internalFeatures.respectPrefix === false) return false;
              return true;
            })();
            formatStrings = formatStrings.map(
              (format) => format.map((str) => ({
                format: str,
                respectPrefix
              }))
            );
            manualFormatStrings = manualFormatStrings.map((format) => ({
              format,
              respectPrefix
            }));
            let opts = {
              candidate,
              context
            };
            let result2 = formatStrings.map(
              (formats) => finalizeSelector(`.${candidate}`, formatVariantSelector(formats, opts), opts).replace(`.${candidate}`, "&").replace("{ & }", "").trim()
            );
            if (manualFormatStrings.length > 0) {
              result2.push(
                formatVariantSelector(manualFormatStrings, opts).toString().replace(`.${candidate}`, "&")
              );
            }
            return result2;
          }
        });
      }
      return result;
    };
  }
  function markInvalidUtilityCandidate(context, candidate) {
    if (!context.classCache.has(candidate)) {
      return;
    }
    context.notClassCache.add(candidate);
    context.classCache.delete(candidate);
    context.applyClassCache.delete(candidate);
    context.candidateRuleMap.delete(candidate);
    context.candidateRuleCache.delete(candidate);
    context.stylesheetCache = null;
  }
  function markInvalidUtilityNode(context, node) {
    let candidate = node.raws.tailwind.candidate;
    if (!candidate) {
      return;
    }
    for (const entry of context.ruleCache) {
      if (entry[1].raws.tailwind.candidate === candidate) {
        context.ruleCache.delete(entry);
      }
    }
    markInvalidUtilityCandidate(context, candidate);
  }
  function createContext(tailwindConfig, changedContent = [], root2 = postcss_default.root()) {
    let context = {
      disposables: [],
      ruleCache: /* @__PURE__ */ new Set(),
      candidateRuleCache: /* @__PURE__ */ new Map(),
      classCache: /* @__PURE__ */ new Map(),
      applyClassCache: /* @__PURE__ */ new Map(),
      // Seed the not class cache with the blocklist (which is only strings)
      notClassCache: new Set(tailwindConfig.blocklist ?? []),
      postCssNodeCache: /* @__PURE__ */ new Map(),
      candidateRuleMap: /* @__PURE__ */ new Map(),
      tailwindConfig,
      changedContent,
      variantMap: /* @__PURE__ */ new Map(),
      stylesheetCache: null,
      variantOptions: /* @__PURE__ */ new Map(),
      markInvalidUtilityCandidate: (candidate) => markInvalidUtilityCandidate(context, candidate),
      markInvalidUtilityNode: (node) => markInvalidUtilityNode(context, node)
    };
    let resolvedPlugins = resolvePlugins(context, root2);
    registerPlugins(resolvedPlugins, context);
    return context;
  }
  function applyImportantSelector(selector, important) {
    let sel = (0, import_postcss_selector_parser9.default)().astSync(selector);
    sel.each((sel2) => {
      let isWrapped = sel2.nodes[0].type === "pseudo" && sel2.nodes[0].value === ":is" && sel2.nodes.every((node) => node.type !== "combinator");
      if (!isWrapped) {
        sel2.nodes = [
          import_postcss_selector_parser9.default.pseudo({
            value: ":is",
            nodes: [sel2.clone()]
          })
        ];
      }
      movePseudos(sel2);
    });
    return `${important} ${sel.toString()}`;
  }
  var classNameParser = (0, import_postcss_selector_parser4.default)((selectors) => {
    return selectors.first.filter(({ type }) => type === "class").pop().value;
  });
  function getClassNameFromSelector(selector) {
    return classNameParser.transformSync(selector);
  }
  function* candidatePermutations(candidate) {
    let lastIndex = Infinity;
    while (lastIndex >= 0) {
      let dashIdx;
      let wasSlash = false;
      if (lastIndex === Infinity && candidate.endsWith("]")) {
        let bracketIdx = candidate.indexOf("[");
        if (candidate[bracketIdx - 1] === "-") {
          dashIdx = bracketIdx - 1;
        } else if (candidate[bracketIdx - 1] === "/") {
          dashIdx = bracketIdx - 1;
          wasSlash = true;
        } else {
          dashIdx = -1;
        }
      } else if (lastIndex === Infinity && candidate.includes("/")) {
        dashIdx = candidate.lastIndexOf("/");
        wasSlash = true;
      } else {
        dashIdx = candidate.lastIndexOf("-", lastIndex);
      }
      if (dashIdx < 0) {
        break;
      }
      let prefix3 = candidate.slice(0, dashIdx);
      let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
      lastIndex = dashIdx - 1;
      if (prefix3 === "" || modifier === "/") {
        continue;
      }
      yield [prefix3, modifier];
    }
  }
  function applyPrefix(matches, context) {
    if (matches.length === 0 || context.tailwindConfig.prefix === "") {
      return matches;
    }
    for (let match of matches) {
      let [meta] = match;
      if (meta.options.respectPrefix) {
        let container = postcss_default.root({ nodes: [match[1].clone()] });
        let classCandidate = match[1].raws.tailwind.classCandidate;
        container.walkRules((r3) => {
          let shouldPrependNegative = classCandidate.startsWith("-");
          r3.selector = prefixSelector_default(
            context.tailwindConfig.prefix,
            r3.selector,
            shouldPrependNegative
          );
        });
        match[1] = container.nodes[0];
      }
    }
    return matches;
  }
  function applyImportant(matches, classCandidate) {
    if (matches.length === 0) {
      return matches;
    }
    let result = [];
    for (let [meta, rule2] of matches) {
      let container = postcss_default.root({ nodes: [rule2.clone()] });
      container.walkRules((r3) => {
        let ast = (0, import_postcss_selector_parser4.default)().astSync(r3.selector);
        ast.each((sel) => eliminateIrrelevantSelectors(sel, classCandidate));
        updateAllClasses(
          ast,
          (className) => className === classCandidate ? `!${className}` : className
        );
        r3.selector = ast.toString();
        r3.walkDecls((d2) => d2.important = true);
      });
      result.push([{ ...meta, important: true }, container.nodes[0]]);
    }
    return result;
  }
  function applyVariant(variant, matches, context) {
    if (matches.length === 0) {
      return matches;
    }
    let args = { modifier: null, value: NONE };
    {
      let [baseVariant, ...modifiers] = splitAtTopLevelOnly2(variant, "/");
      if (modifiers.length > 1) {
        baseVariant = baseVariant + "/" + modifiers.slice(0, -1).join("/");
        modifiers = modifiers.slice(-1);
      }
      if (modifiers.length && !context.variantMap.has(variant)) {
        variant = baseVariant;
        args.modifier = modifiers[0];
        if (!flagEnabled2(context.tailwindConfig, "generalizedModifiers")) {
          return [];
        }
      }
    }
    if (variant.endsWith("]") && !variant.startsWith("[")) {
      let match = /(.)(-?)\[(.*)\]/g.exec(variant);
      if (match) {
        let [, char, separator, value2] = match;
        if (char === "@" && separator === "-") return [];
        if (char !== "@" && separator === "") return [];
        variant = variant.replace(`${separator}[${value2}]`, "");
        args.value = value2;
      }
    }
    if (isArbitraryValue2(variant) && !context.variantMap.has(variant)) {
      let sort = context.offsets.recordVariant(variant);
      let selector = normalize2(variant.slice(1, -1));
      let selectors = splitAtTopLevelOnly2(selector, ",");
      if (selectors.length > 1) {
        return [];
      }
      if (!selectors.every(isValidVariantFormatString)) {
        return [];
      }
      let records = selectors.map((sel, idx) => [
        context.offsets.applyParallelOffset(sort, idx),
        parseVariant(sel.trim())
      ]);
      context.variantMap.set(variant, records);
    }
    if (context.variantMap.has(variant)) {
      let isArbitraryVariant = isArbitraryValue2(variant);
      let internalFeatures = context.variantOptions.get(variant)?.[INTERNAL_FEATURES] ?? {};
      let variantFunctionTuples = context.variantMap.get(variant).slice();
      let result = [];
      let respectPrefix = (() => {
        if (isArbitraryVariant) return false;
        if (internalFeatures.respectPrefix === false) return false;
        return true;
      })();
      for (let [meta, rule2] of matches) {
        if (meta.layer === "user") {
          continue;
        }
        let container = postcss_default.root({ nodes: [rule2.clone()] });
        for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {
          let prepareBackup = function() {
            if (clone.raws.neededBackup) {
              return;
            }
            clone.raws.neededBackup = true;
            clone.walkRules((rule3) => rule3.raws.originalSelector = rule3.selector);
          }, modifySelectors = function(modifierFunction) {
            prepareBackup();
            clone.each((rule3) => {
              if (rule3.type !== "rule") {
                return;
              }
              rule3.selectors = rule3.selectors.map((selector) => {
                return modifierFunction({
                  get className() {
                    return getClassNameFromSelector(selector);
                  },
                  selector
                });
              });
            });
            return clone;
          };
          let clone = (containerFromArray ?? container).clone();
          let collectedFormats = [];
          let ruleWithVariant = variantFunction({
            // Public API
            get container() {
              prepareBackup();
              return clone;
            },
            separator: context.tailwindConfig.separator,
            modifySelectors,
            // Private API for now
            wrap(wrapper) {
              let nodes = clone.nodes;
              clone.removeAll();
              wrapper.append(nodes);
              clone.append(wrapper);
            },
            format(selectorFormat) {
              collectedFormats.push({
                format: selectorFormat,
                respectPrefix
              });
            },
            args
          });
          if (Array.isArray(ruleWithVariant)) {
            for (let [idx, variantFunction2] of ruleWithVariant.entries()) {
              variantFunctionTuples.push([
                context.offsets.applyParallelOffset(variantSort, idx),
                variantFunction2,
                // If the clone has been modified we have to pass that back
                // though so each rule can use the modified container
                clone.clone()
              ]);
            }
            continue;
          }
          if (typeof ruleWithVariant === "string") {
            collectedFormats.push({
              format: ruleWithVariant,
              respectPrefix
            });
          }
          if (ruleWithVariant === null) {
            continue;
          }
          if (clone.raws.neededBackup) {
            delete clone.raws.neededBackup;
            clone.walkRules((rule3) => {
              let before = rule3.raws.originalSelector;
              if (!before) return;
              delete rule3.raws.originalSelector;
              if (before === rule3.selector) return;
              let modified = rule3.selector;
              let rebuiltBase = (0, import_postcss_selector_parser4.default)((selectors) => {
                selectors.walkClasses((classNode) => {
                  classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;
                });
              }).processSync(before);
              collectedFormats.push({
                format: modified.replace(rebuiltBase, "&"),
                respectPrefix
              });
              rule3.selector = before;
            });
          }
          clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind, parentLayer: meta.layer };
          let withOffset = [
            {
              ...meta,
              sort: context.offsets.applyVariantOffset(
                meta.sort,
                variantSort,
                Object.assign(args, context.variantOptions.get(variant))
              ),
              collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats)
            },
            clone.nodes[0]
          ];
          result.push(withOffset);
        }
      }
      return result;
    }
    return [];
  }
  function parseRules(rule2, cache3, options = {}) {
    if (!isPlainObject(rule2) && !Array.isArray(rule2)) {
      return [[rule2], options];
    }
    if (Array.isArray(rule2)) {
      return parseRules(rule2[0], cache3, rule2[1]);
    }
    if (!cache3.has(rule2)) {
      cache3.set(rule2, parseObjectStyles(rule2));
    }
    return [cache3.get(rule2), options];
  }
  var IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
  function isValidPropName(name) {
    return IS_VALID_PROPERTY_NAME.test(name);
  }
  function looksLikeUri(declaration) {
    if (!declaration.includes("://")) {
      return false;
    }
    try {
      const url2 = new URL(declaration);
      return url2.scheme !== "" && url2.host !== "";
    } catch (err) {
      return false;
    }
  }
  function isParsableNode(node) {
    let isParsable = true;
    node.walkDecls((decl22) => {
      if (!isParsableCssValue(decl22.prop, decl22.value)) {
        isParsable = false;
        return false;
      }
    });
    return isParsable;
  }
  function isParsableCssValue(property, value2) {
    if (looksLikeUri(`${property}:${value2}`)) {
      return false;
    }
    try {
      postcss_default.parse(`a{${property}:${value2}}`).toResult();
      return true;
    } catch (err) {
      return false;
    }
  }
  function extractArbitraryProperty(classCandidate, context) {
    let [, property, value2] = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/) ?? [];
    if (value2 === void 0) {
      return null;
    }
    if (!isValidPropName(property)) {
      return null;
    }
    if (!isSyntacticallyValidPropertyValue(value2)) {
      return null;
    }
    let normalized = normalize2(value2, { property });
    if (!isParsableCssValue(property, normalized)) {
      return null;
    }
    let sort = context.offsets.arbitraryProperty();
    return [
      [
        { sort, layer: "utilities" },
        () => ({
          [asClass(classCandidate)]: {
            [property]: normalized
          }
        })
      ]
    ];
  }
  function* resolveMatchedPlugins(classCandidate, context) {
    if (context.candidateRuleMap.has(classCandidate)) {
      yield [context.candidateRuleMap.get(classCandidate), "DEFAULT"];
    }
    yield* function* (arbitraryPropertyRule) {
      if (arbitraryPropertyRule !== null) {
        yield [arbitraryPropertyRule, "DEFAULT"];
      }
    }(extractArbitraryProperty(classCandidate, context));
    let candidatePrefix = classCandidate;
    let negative = false;
    const twConfigPrefix = context.tailwindConfig.prefix;
    const twConfigPrefixLen = twConfigPrefix.length;
    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);
    if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
      negative = true;
      candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
    }
    if (negative && context.candidateRuleMap.has(candidatePrefix)) {
      yield [context.candidateRuleMap.get(candidatePrefix), "-DEFAULT"];
    }
    for (let [prefix3, modifier] of candidatePermutations(candidatePrefix)) {
      if (context.candidateRuleMap.has(prefix3)) {
        yield [context.candidateRuleMap.get(prefix3), negative ? `-${modifier}` : modifier];
      }
    }
  }
  function splitWithSeparator(input, separator) {
    if (input === NOT_ON_DEMAND) {
      return [NOT_ON_DEMAND];
    }
    return splitAtTopLevelOnly2(input, separator);
  }
  function* recordCandidates(matches, classCandidate) {
    for (const match of matches) {
      match[1].raws.tailwind = {
        ...match[1].raws.tailwind,
        classCandidate,
        preserveSource: match[0].options?.preserveSource ?? false
      };
      yield match;
    }
  }
  function* resolveMatches(candidate, context) {
    let separator = context.tailwindConfig.separator;
    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
    let important = false;
    if (classCandidate.startsWith("!")) {
      important = true;
      classCandidate = classCandidate.slice(1);
    }
    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {
      let matches = [];
      let typesByMatches = /* @__PURE__ */ new Map();
      let [plugins, modifier] = matchedPlugins;
      let isOnlyPlugin = plugins.length === 1;
      for (let [sort, plugin2] of plugins) {
        let matchesPerPlugin = [];
        if (typeof plugin2 === "function") {
          for (let ruleSet of [].concat(plugin2(modifier, { isOnlyPlugin }))) {
            let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
            for (let rule2 of rules) {
              matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
            }
          }
        } else if (modifier === "DEFAULT" || modifier === "-DEFAULT") {
          let ruleSet = plugin2;
          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
          for (let rule2 of rules) {
            matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
          }
        }
        if (matchesPerPlugin.length > 0) {
          let matchingTypes = Array.from(
            getMatchingTypes(
              sort.options?.types ?? [],
              modifier,
              sort.options ?? {},
              context.tailwindConfig
            )
          ).map(([_2, type]) => type);
          if (matchingTypes.length > 0) {
            typesByMatches.set(matchesPerPlugin, matchingTypes);
          }
          matches.push(matchesPerPlugin);
        }
      }
      if (isArbitraryValue2(modifier)) {
        if (matches.length > 1) {
          let findFallback = function(matches2) {
            if (matches2.length === 1) {
              return matches2[0];
            }
            return matches2.find((rules) => {
              let matchingTypes = typesByMatches.get(rules);
              return rules.some(([{ options }, rule2]) => {
                if (!isParsableNode(rule2)) {
                  return false;
                }
                return options.types.some(
                  ({ type, preferOnConflict }) => matchingTypes.includes(type) && preferOnConflict
                );
              });
            });
          };
          let [withAny, withoutAny] = matches.reduce(
            (group, plugin2) => {
              let hasAnyType = plugin2.some(
                ([{ options }]) => options.types.some(({ type }) => type === "any")
              );
              if (hasAnyType) {
                group[0].push(plugin2);
              } else {
                group[1].push(plugin2);
              }
              return group;
            },
            [[], []]
          );
          let fallback = findFallback(withoutAny) ?? findFallback(withAny);
          if (fallback) {
            matches = [fallback];
          } else {
            let typesPerPlugin = matches.map(
              (match) => /* @__PURE__ */ new Set([...typesByMatches.get(match) ?? []])
            );
            for (let pluginTypes of typesPerPlugin) {
              for (let type of pluginTypes) {
                let removeFromOwnGroup = false;
                for (let otherGroup of typesPerPlugin) {
                  if (pluginTypes === otherGroup) continue;
                  if (otherGroup.has(type)) {
                    otherGroup.delete(type);
                    removeFromOwnGroup = true;
                  }
                }
                if (removeFromOwnGroup) pluginTypes.delete(type);
              }
            }
            let messages = [];
            for (let [idx, group] of typesPerPlugin.entries()) {
              for (let type of group) {
                let rules = matches[idx].map(([, rule2]) => rule2).flat().map(
                  (rule2) => rule2.toString().split("\n").slice(1, -1).map((line) => line.trim()).map((x2) => `      ${x2}`).join("\n")
                ).join("\n\n");
                messages.push(
                  `  Use \`${candidate.replace("[", `[${type}:`)}\` for \`${rules.trim()}\``
                );
                break;
              }
            }
            log_default.warn([
              `The class \`${candidate}\` is ambiguous and matches multiple utilities.`,
              ...messages,
              `If this is content and not a class, replace it with \`${candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
            ]);
            continue;
          }
        }
        matches = matches.map((list22) => list22.filter((match) => isParsableNode(match[1])));
      }
      matches = matches.flat();
      matches = Array.from(recordCandidates(matches, classCandidate));
      matches = applyPrefix(matches, context);
      if (important) {
        matches = applyImportant(matches, classCandidate);
      }
      for (let variant of variants) {
        matches = applyVariant(variant, matches, context);
      }
      for (let match of matches) {
        match[1].raws.tailwind = { ...match[1].raws.tailwind, candidate };
        match = applyFinalFormat(match, { context, candidate });
        if (match === null) {
          continue;
        }
        yield match;
      }
    }
  }
  function applyFinalFormat(match, { context, candidate }) {
    if (!match[0].collectedFormats) {
      return match;
    }
    let isValid = true;
    let finalFormat;
    try {
      finalFormat = formatVariantSelector(match[0].collectedFormats, {
        context,
        candidate
      });
    } catch {
      return null;
    }
    let container = postcss_default.root({ nodes: [match[1].clone()] });
    container.walkRules((rule2) => {
      if (inKeyframes(rule2)) {
        return;
      }
      try {
        let selector = finalizeSelector(rule2.selector, finalFormat, {
          candidate,
          context
        });
        if (selector === null) {
          rule2.remove();
          return;
        }
        rule2.selector = selector;
      } catch {
        isValid = false;
        return false;
      }
    });
    if (!isValid) {
      return null;
    }
    match[1] = container.nodes[0];
    return match;
  }
  function inKeyframes(rule2) {
    return rule2.parent && rule2.parent.type === "atrule" && rule2.parent.name === "keyframes";
  }
  function getImportantStrategy(important) {
    if (important === true) {
      return (rule2) => {
        if (inKeyframes(rule2)) {
          return;
        }
        rule2.walkDecls((d2) => {
          if (d2.parent.type === "rule" && !inKeyframes(d2.parent)) {
            d2.important = true;
          }
        });
      };
    }
    if (typeof important === "string") {
      return (rule2) => {
        if (inKeyframes(rule2)) {
          return;
        }
        rule2.selectors = rule2.selectors.map((selector) => {
          return applyImportantSelector(selector, important);
        });
      };
    }
  }
  function generateRules2(candidates, context, isSorting = false) {
    let allRules = [];
    let strategy = getImportantStrategy(context.tailwindConfig.important);
    for (let candidate of candidates) {
      if (context.notClassCache.has(candidate)) {
        continue;
      }
      if (context.candidateRuleCache.has(candidate)) {
        allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
        continue;
      }
      let matches = Array.from(resolveMatches(candidate, context));
      if (matches.length === 0) {
        context.notClassCache.add(candidate);
        continue;
      }
      context.classCache.set(candidate, matches);
      let rules = context.candidateRuleCache.get(candidate) ?? /* @__PURE__ */ new Set();
      context.candidateRuleCache.set(candidate, rules);
      for (const match of matches) {
        let [{ sort, options }, rule2] = match;
        if (options.respectImportant && strategy) {
          let container = postcss_default.root({ nodes: [rule2.clone()] });
          container.walkRules(strategy);
          rule2 = container.nodes[0];
        }
        let newEntry = [sort, isSorting ? rule2.clone() : rule2];
        rules.add(newEntry);
        context.ruleCache.add(newEntry);
        allRules.push(newEntry);
      }
    }
    return allRules;
  }
  function isArbitraryValue2(input) {
    return input.startsWith("[") && input.endsWith("]");
  }
  function extractClasses(node) {
    let groups = /* @__PURE__ */ new Map();
    let container = postcss_default.root({ nodes: [node.clone()] });
    container.walkRules((rule2) => {
      (0, import_postcss_selector_parser3.default)((selectors) => {
        selectors.walkClasses((classSelector) => {
          let parentSelector = classSelector.parent.toString();
          let classes2 = groups.get(parentSelector);
          if (!classes2) {
            groups.set(parentSelector, classes2 = /* @__PURE__ */ new Set());
          }
          classes2.add(classSelector.value);
        });
      }).processSync(rule2.selector);
    });
    let normalizedGroups = Array.from(groups.values(), (classes2) => Array.from(classes2));
    let classes = normalizedGroups.flat();
    return Object.assign(classes, { groups: normalizedGroups });
  }
  var selectorExtractor = (0, import_postcss_selector_parser3.default)();
  function extractSelectors(ruleSelectors) {
    return selectorExtractor.astSync(ruleSelectors);
  }
  function extractBaseCandidates(candidates, separator) {
    let baseClasses = /* @__PURE__ */ new Set();
    for (let candidate of candidates) {
      baseClasses.add(candidate.split(separator).pop());
    }
    return Array.from(baseClasses);
  }
  function prefix2(context, selector) {
    let prefix3 = context.tailwindConfig.prefix;
    return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
  }
  function* pathToRoot(node) {
    yield node;
    while (node.parent) {
      yield node.parent;
      node = node.parent;
    }
  }
  function shallowClone(node, overrides = {}) {
    let children = node.nodes;
    node.nodes = [];
    let tmp = node.clone(overrides);
    node.nodes = children;
    return tmp;
  }
  function nestedClone(node) {
    for (let parent of pathToRoot(node)) {
      if (node === parent) {
        continue;
      }
      if (parent.type === "root") {
        break;
      }
      node = shallowClone(parent, {
        nodes: [node]
      });
    }
    return node;
  }
  function buildLocalApplyCache(root2, context) {
    let cache3 = /* @__PURE__ */ new Map();
    root2.walkRules((rule2) => {
      for (let node of pathToRoot(rule2)) {
        if (node.raws.tailwind?.layer !== void 0) {
          return;
        }
      }
      let container = nestedClone(rule2);
      let sort = context.offsets.create("user");
      for (let className of extractClasses(rule2)) {
        let list22 = cache3.get(className) || [];
        cache3.set(className, list22);
        list22.push([
          {
            layer: "user",
            sort,
            important: false
          },
          container
        ]);
      }
    });
    return cache3;
  }
  function buildApplyCache(applyCandidates, context) {
    for (let candidate of applyCandidates) {
      if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
        continue;
      }
      if (context.classCache.has(candidate)) {
        context.applyClassCache.set(
          candidate,
          context.classCache.get(candidate).map(([meta, rule2]) => [meta, rule2.clone()])
        );
        continue;
      }
      let matches = Array.from(resolveMatches(candidate, context));
      if (matches.length === 0) {
        context.notClassCache.add(candidate);
        continue;
      }
      context.applyClassCache.set(candidate, matches);
    }
    return context.applyClassCache;
  }
  function lazyCache(buildCacheFn) {
    let cache3 = null;
    return {
      get: (name) => {
        cache3 = cache3 || buildCacheFn();
        return cache3.get(name);
      },
      has: (name) => {
        cache3 = cache3 || buildCacheFn();
        return cache3.has(name);
      }
    };
  }
  function combineCaches(caches) {
    return {
      get: (name) => caches.flatMap((cache3) => cache3.get(name) || []),
      has: (name) => caches.some((cache3) => cache3.has(name))
    };
  }
  function extractApplyCandidates(params) {
    let candidates = params.split(/[\s\t\n]+/g);
    if (candidates[candidates.length - 1] === "!important") {
      return [candidates.slice(0, -1), true];
    }
    return [candidates, false];
  }
  function processApply(root2, context, localCache) {
    let applyCandidates = /* @__PURE__ */ new Set();
    let applies = [];
    root2.walkAtRules("apply", (rule2) => {
      let [candidates] = extractApplyCandidates(rule2.params);
      for (let util of candidates) {
        applyCandidates.add(util);
      }
      applies.push(rule2);
    });
    if (applies.length === 0) {
      return;
    }
    let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);
    function replaceSelector(selector, utilitySelectors, candidate) {
      let selectorList = extractSelectors(selector);
      let utilitySelectorsList = extractSelectors(utilitySelectors);
      let candidateList = extractSelectors(`.${escapeClassName2(candidate)}`);
      let candidateClass = candidateList.nodes[0].nodes[0];
      selectorList.each((sel) => {
        let replaced = /* @__PURE__ */ new Set();
        utilitySelectorsList.each((utilitySelector) => {
          let hasReplaced = false;
          utilitySelector = utilitySelector.clone();
          utilitySelector.walkClasses((node) => {
            if (node.value !== candidateClass.value) {
              return;
            }
            if (hasReplaced) {
              return;
            }
            node.replaceWith(...sel.nodes.map((node2) => node2.clone()));
            replaced.add(utilitySelector);
            hasReplaced = true;
          });
        });
        for (let sel2 of replaced) {
          let groups = [[]];
          for (let node of sel2.nodes) {
            if (node.type === "combinator") {
              groups.push(node);
              groups.push([]);
            } else {
              let last = groups[groups.length - 1];
              last.push(node);
            }
          }
          sel2.nodes = [];
          for (let group of groups) {
            if (Array.isArray(group)) {
              group.sort((a2, b2) => {
                if (a2.type === "tag" && b2.type === "class") {
                  return -1;
                } else if (a2.type === "class" && b2.type === "tag") {
                  return 1;
                } else if (a2.type === "class" && b2.type === "pseudo" && b2.value.startsWith("::")) {
                  return -1;
                } else if (a2.type === "pseudo" && a2.value.startsWith("::") && b2.type === "class") {
                  return 1;
                }
                return 0;
              });
            }
            sel2.nodes = sel2.nodes.concat(group);
          }
        }
        sel.replaceWith(...replaced);
      });
      return selectorList.toString();
    }
    let perParentApplies = /* @__PURE__ */ new Map();
    for (let apply of applies) {
      let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];
      perParentApplies.set(apply.parent, [candidates, apply.source]);
      let [applyCandidates2, important] = extractApplyCandidates(apply.params);
      if (apply.parent.type === "atrule") {
        if (apply.parent.name === "screen") {
          let screenType = apply.parent.params;
          throw apply.error(
            `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates2.map((c3) => `${screenType}:${c3}`).join(" ")} instead.`
          );
        }
        throw apply.error(
          `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`
        );
      }
      for (let applyCandidate of applyCandidates2) {
        if ([prefix2(context, "group"), prefix2(context, "peer")].includes(applyCandidate)) {
          throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
        }
        if (!applyClassCache.has(applyCandidate)) {
          throw apply.error(
            `The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`
          );
        }
        let rules = applyClassCache.get(applyCandidate);
        candidates.push([applyCandidate, important, rules]);
      }
    }
    for (let [parent, [candidates, atApplySource]] of perParentApplies) {
      let siblings = [];
      for (let [applyCandidate, important, rules] of candidates) {
        let potentialApplyCandidates = [
          applyCandidate,
          ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator)
        ];
        for (let [meta, node] of rules) {
          let parentClasses = extractClasses(parent);
          let nodeClasses = extractClasses(node);
          nodeClasses = nodeClasses.groups.filter(
            (classList) => classList.some((className) => potentialApplyCandidates.includes(className))
          ).flat();
          nodeClasses = nodeClasses.concat(
            extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
          );
          let intersects = parentClasses.some((selector) => nodeClasses.includes(selector));
          if (intersects) {
            throw node.error(
              `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
            );
          }
          let root3 = postcss_default.root({ nodes: [node.clone()] });
          root3.walk((node2) => {
            node2.source = atApplySource;
          });
          let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
          if (canRewriteSelector) {
            root3.walkRules((rule2) => {
              if (!extractClasses(rule2).some((candidate) => candidate === applyCandidate)) {
                rule2.remove();
                return;
              }
              let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
              let isGenerated = parent.raws.tailwind !== void 0;
              let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
              if (parentSelector === "") {
                parentSelector = parent.selector;
              }
              rule2.selector = replaceSelector(parentSelector, rule2.selector, applyCandidate);
              if (importantSelector && parentSelector !== parent.selector) {
                rule2.selector = applyImportantSelector(rule2.selector, importantSelector);
              }
              rule2.walkDecls((d2) => {
                d2.important = meta.important || important;
              });
              let selector = (0, import_postcss_selector_parser3.default)().astSync(rule2.selector);
              selector.each((sel) => movePseudos(sel));
              rule2.selector = selector.toString();
            });
          }
          if (!root3.nodes[0]) {
            continue;
          }
          siblings.push([meta.sort, root3.nodes[0]]);
        }
      }
      let nodes = context.offsets.sort(siblings).map((s2) => s2[1]);
      parent.after(nodes);
    }
    for (let apply of applies) {
      if (apply.parent.nodes.length > 1) {
        apply.remove();
      } else {
        apply.parent.remove();
      }
    }
    processApply(root2, context, localCache);
  }
  function expandApplyAtRules(context) {
    return (root2) => {
      let localCache = lazyCache(() => buildLocalApplyCache(root2, context));
      processApply(root2, context, localCache);
    };
  }
  function normalizeTailwindDirectives(root2) {
    let tailwindDirectives = /* @__PURE__ */ new Set();
    let layerDirectives = /* @__PURE__ */ new Set();
    let applyDirectives = /* @__PURE__ */ new Set();
    root2.walkAtRules((atRule22) => {
      if (atRule22.name === "apply") {
        applyDirectives.add(atRule22);
      }
      if (atRule22.name === "import") {
        if (atRule22.params === '"tailwindcss/base"' || atRule22.params === "'tailwindcss/base'") {
          atRule22.name = "tailwind";
          atRule22.params = "base";
        } else if (atRule22.params === '"tailwindcss/components"' || atRule22.params === "'tailwindcss/components'") {
          atRule22.name = "tailwind";
          atRule22.params = "components";
        } else if (atRule22.params === '"tailwindcss/utilities"' || atRule22.params === "'tailwindcss/utilities'") {
          atRule22.name = "tailwind";
          atRule22.params = "utilities";
        } else if (atRule22.params === '"tailwindcss/screens"' || atRule22.params === "'tailwindcss/screens'" || atRule22.params === '"tailwindcss/variants"' || atRule22.params === "'tailwindcss/variants'") {
          atRule22.name = "tailwind";
          atRule22.params = "variants";
        }
      }
      if (atRule22.name === "tailwind") {
        if (atRule22.params === "screens") {
          atRule22.params = "variants";
        }
        tailwindDirectives.add(atRule22.params);
      }
      if (["layer", "responsive", "variants"].includes(atRule22.name)) {
        if (["responsive", "variants"].includes(atRule22.name)) {
          log_default.warn(`${atRule22.name}-at-rule-deprecated`, [
            `The \`@${atRule22.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
            `Use \`@layer utilities\` or \`@layer components\` instead.`,
            "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
          ]);
        }
        layerDirectives.add(atRule22);
      }
    });
    if (!tailwindDirectives.has("base") || !tailwindDirectives.has("components") || !tailwindDirectives.has("utilities")) {
      for (let rule2 of layerDirectives) {
        if (rule2.name === "layer" && ["base", "components", "utilities"].includes(rule2.params)) {
          if (!tailwindDirectives.has(rule2.params)) {
            throw rule2.error(
              `\`@layer ${rule2.params}\` is used but no matching \`@tailwind ${rule2.params}\` directive is present.`
            );
          }
        } else if (rule2.name === "responsive") {
          if (!tailwindDirectives.has("utilities")) {
            throw rule2.error("`@responsive` is used but `@tailwind utilities` is missing.");
          }
        } else if (rule2.name === "variants") {
          if (!tailwindDirectives.has("utilities")) {
            throw rule2.error("`@variants` is used but `@tailwind utilities` is missing.");
          }
        }
      }
    }
    return { tailwindDirectives, applyDirectives };
  }
  function cloneNodes(nodes, source = void 0, raws = void 0) {
    return nodes.map((node) => {
      let cloned = node.clone();
      let shouldOverwriteSource = node.raws.tailwind?.preserveSource !== true || !cloned.source;
      if (source !== void 0 && shouldOverwriteSource) {
        cloned.source = source;
        if ("walk" in cloned) {
          cloned.walk((child) => {
            child.source = source;
          });
        }
      }
      if (raws !== void 0) {
        cloned.raws.tailwind = {
          ...cloned.raws.tailwind,
          ...raws
        };
      }
      return cloned;
    });
  }
  var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
  var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
  function toSource(source) {
    source = Array.isArray(source) ? source : [source];
    source = source.map((item) => item instanceof RegExp ? item.source : item);
    return source.join("");
  }
  function pattern(source) {
    return new RegExp(toSource(source), "g");
  }
  function any(sources) {
    return `(?:${sources.map(toSource).join("|")})`;
  }
  function optional(source) {
    return `(?:${toSource(source)})?`;
  }
  function escape(string) {
    return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
  }
  function defaultExtractor(context) {
    let patterns = Array.from(buildRegExps(context));
    return (content) => {
      let results = [];
      for (let pattern2 of patterns) {
        for (let result of content.match(pattern2) ?? []) {
          results.push(clipAtBalancedParens(result));
        }
      }
      return results;
    };
  }
  function* buildRegExps(context) {
    let separator = context.tailwindConfig.separator;
    let prefix3 = context.tailwindConfig.prefix !== "" ? optional(pattern([/-?/, escape(context.tailwindConfig.prefix)])) : "";
    let utility = any([
      // Arbitrary properties (without square brackets)
      /\[[^\s:'"`]+:[^\s\[\]]+\]/,
      // Arbitrary properties with balanced square brackets
      // This is a targeted fix to continue to allow theme()
      // with square brackets to work in arbitrary properties
      // while fixing a problem with the regex matching too much
      /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
      // Utilities
      pattern([
        // Utility Name / Group Name
        /-?(?:\w+)/,
        // Normal/Arbitrary values
        optional(
          any([
            pattern([
              // Arbitrary values
              /-(?:\w+-)*\[[^\s:]+\]/,
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\><$]*)?/
            ]),
            pattern([
              // Arbitrary values
              /-(?:\w+-)*\[[^\s]+\]/,
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\$]*)?/
            ]),
            // Normal values w/o quotes — may include an opacity modifier
            /[-\/][^\s'"`\\$={><]*/
          ])
        )
      ])
    ]);
    let variantPatterns = [
      // Without quotes
      any([
        // This is here to provide special support for the `@` variant
        pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]),
        // With variant modifier (e.g.: group-[..]/modifier)
        pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/\w+/, separator]),
        pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]),
        pattern([/[^\s"'`\[\\]+/, separator])
      ]),
      // With quotes allowed
      any([
        // With variant modifier (e.g.: group-[..]/modifier)
        pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/\w+/, separator]),
        pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]),
        pattern([/[^\s`\[\\]+/, separator])
      ])
    ];
    for (const variantPattern of variantPatterns) {
      yield pattern([
        // Variants
        "((?=((",
        variantPattern,
        ")+))\\2)?",
        // Important (optional)
        /!?/,
        prefix3,
        utility
      ]);
    }
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
  }
  var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
  var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
  function clipAtBalancedParens(input) {
    if (!input.includes("-[")) {
      return input;
    }
    let depth = 0;
    let openStringTypes = [];
    let matches = input.matchAll(SPECIALS);
    matches = Array.from(matches).flatMap((match) => {
      const [, ...groups] = match;
      return groups.map(
        (group, idx) => Object.assign([], match, {
          index: match.index + idx,
          0: group
        })
      );
    });
    for (let match of matches) {
      let char = match[0];
      let inStringType = openStringTypes[openStringTypes.length - 1];
      if (char === inStringType) {
        openStringTypes.pop();
      } else if (char === "'" || char === '"' || char === "`") {
        openStringTypes.push(char);
      }
      if (inStringType) {
        continue;
      } else if (char === "[") {
        depth++;
        continue;
      } else if (char === "]") {
        depth--;
        continue;
      }
      if (depth < 0) {
        return input.substring(0, match.index - 1);
      }
      if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {
        return input.substring(0, match.index);
      }
    }
    return input;
  }
  var builtInExtractors = {
    DEFAULT: defaultExtractor
  };
  var builtInTransformers = {
    DEFAULT: (content) => content,
    svelte: (content) => content.replace(/(?:^|\s)class:/g, " ")
  };
  function getExtractor(context, fileExtension) {
    let extractors = context.tailwindConfig.content.extract;
    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
  }
  function getTransformer(tailwindConfig, fileExtension) {
    let transformers = tailwindConfig.content.transform;
    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
  }
  var extractorCache = /* @__PURE__ */ new WeakMap();
  function getClassCandidates(content, extractor, candidates, seen) {
    if (!extractorCache.has(extractor)) {
      extractorCache.set(extractor, new import_quick_lru.default({ maxSize: 25e3 }));
    }
    for (let line of content.split("\n")) {
      line = line.trim();
      if (seen.has(line)) {
        continue;
      }
      seen.add(line);
      if (extractorCache.get(extractor).has(line)) {
        for (let match of extractorCache.get(extractor).get(line)) {
          candidates.add(match);
        }
      } else {
        let extractorMatches = extractor(line).filter((s2) => s2 !== "!*");
        let lineMatchesSet = new Set(extractorMatches);
        for (let match of lineMatchesSet) {
          candidates.add(match);
        }
        extractorCache.get(extractor).set(line, lineMatchesSet);
      }
    }
  }
  function buildStylesheet(rules, context) {
    let sortedRules = context.offsets.sort(rules);
    let returnValue = {
      base: /* @__PURE__ */ new Set(),
      defaults: /* @__PURE__ */ new Set(),
      components: /* @__PURE__ */ new Set(),
      utilities: /* @__PURE__ */ new Set(),
      variants: /* @__PURE__ */ new Set()
    };
    for (let [sort, rule2] of sortedRules) {
      returnValue[sort.layer].add(rule2);
    }
    return returnValue;
  }
  function expandTailwindAtRules(context) {
    return async (root2) => {
      let layerNodes = {
        base: null,
        components: null,
        utilities: null,
        variants: null
      };
      root2.walkAtRules((rule2) => {
        if (rule2.name === "tailwind") {
          if (Object.keys(layerNodes).includes(rule2.params)) {
            layerNodes[rule2.params] = rule2;
          }
        }
      });
      if (Object.values(layerNodes).every((n2) => n2 === null)) {
        return root2;
      }
      let candidates = /* @__PURE__ */ new Set([...context.candidates ?? [], NOT_ON_DEMAND]);
      let seen = /* @__PURE__ */ new Set();
      if (void 0) {
        for (let candidate of null.parseCandidateStringsFromFiles(
          context.changedContent
          // Object.assign({}, builtInTransformers, context.tailwindConfig.content.transform)
        )) {
          candidates.add(candidate);
        }
      } else {
        let regexParserContent = [];
        for (let item of context.changedContent) {
          let transformer = getTransformer(context.tailwindConfig, item.extension);
          let extractor = getExtractor(context, item.extension);
          regexParserContent.push([item, { transformer, extractor }]);
        }
        const BATCH_SIZE = 500;
        for (let i2 = 0; i2 < regexParserContent.length; i2 += BATCH_SIZE) {
          let batch = regexParserContent.slice(i2, i2 + BATCH_SIZE);
          await Promise.all(
            batch.map(async ([{ file, content }, { transformer, extractor }]) => {
              content = file ? await fs_default.promises.readFile(file, "utf8") : content;
              getClassCandidates(transformer(content), extractor, candidates, seen);
            })
          );
        }
      }
      let classCacheCount = context.classCache.size;
      let sortedCandidates = void 0 ? candidates : new Set(
        [...candidates].sort((a2, z2) => {
          if (a2 === z2) return 0;
          if (a2 < z2) return -1;
          return 1;
        })
      );
      generateRules2(sortedCandidates, context);
      if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
        context.stylesheetCache = buildStylesheet([...context.ruleCache], context);
      }
      let {
        defaults: defaultNodes,
        base: baseNodes,
        components: componentNodes,
        utilities: utilityNodes,
        variants: screenNodes
      } = context.stylesheetCache;
      if (layerNodes.base) {
        layerNodes.base.before(
          cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, {
            layer: "base"
          })
        );
        layerNodes.base.remove();
      }
      if (layerNodes.components) {
        layerNodes.components.before(
          cloneNodes([...componentNodes], layerNodes.components.source, {
            layer: "components"
          })
        );
        layerNodes.components.remove();
      }
      if (layerNodes.utilities) {
        layerNodes.utilities.before(
          cloneNodes([...utilityNodes], layerNodes.utilities.source, {
            layer: "utilities"
          })
        );
        layerNodes.utilities.remove();
      }
      const variantNodes = Array.from(screenNodes).filter((node) => {
        const parentLayer = node.raws.tailwind?.parentLayer;
        if (parentLayer === "components") {
          return layerNodes.components !== null;
        }
        if (parentLayer === "utilities") {
          return layerNodes.utilities !== null;
        }
        return true;
      });
      if (layerNodes.variants) {
        layerNodes.variants.before(
          cloneNodes(variantNodes, layerNodes.variants.source, {
            layer: "variants"
          })
        );
        layerNodes.variants.remove();
      } else if (variantNodes.length > 0) {
        root2.append(
          cloneNodes(variantNodes, root2.source, {
            layer: "variants"
          })
        );
      }
      const hasUtilityVariants = variantNodes.some(
        (node) => node.raws.tailwind?.parentLayer === "utilities"
      );
      if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
        log_default.warn("content-problems", [
          "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
          "https://tailwindcss.com/docs/content-configuration"
        ]);
      }
      if (void 0) {
        console.log("Potential classes: ", candidates.size);
        console.log("Active contexts: ", contextSourcesMap.size);
      }
      context.changedContent = [];
      root2.walkAtRules("layer", (rule2) => {
        if (Object.keys(layerNodes).includes(rule2.params)) {
          rule2.remove();
        }
      });
    };
  }
  var import_value_parser = __toESM2(require_value_parser());
  function isObject22(input) {
    return typeof input === "object" && input !== null;
  }
  function findClosestExistingPath(theme, path) {
    let parts = toPath(path);
    do {
      parts.pop();
      if ((0, import_dlv13.default)(theme, parts) !== void 0) break;
    } while (parts.length);
    return parts.length ? parts : void 0;
  }
  function pathToString2(path) {
    if (typeof path === "string") return path;
    return path.reduce((acc, cur, i2) => {
      if (cur.includes(".")) return `${acc}[${cur}]`;
      return i2 === 0 ? cur : `${acc}.${cur}`;
    }, "");
  }
  function list2(items) {
    return items.map((key) => `'${key}'`).join(", ");
  }
  function listKeys(obj) {
    return list2(Object.keys(obj));
  }
  function validatePath(config, path, defaultValue, themeOpts = {}) {
    const pathString = Array.isArray(path) ? pathToString2(path) : path.replace(/^['"]+|['"]+$/g, "");
    const pathSegments = Array.isArray(path) ? path : toPath(pathString);
    const value2 = (0, import_dlv13.default)(config.theme, pathSegments, defaultValue);
    if (value2 === void 0) {
      let error = `'${pathString}' does not exist in your theme config.`;
      const parentSegments = pathSegments.slice(0, -1);
      const parentValue = (0, import_dlv13.default)(config.theme, parentSegments);
      if (isObject22(parentValue)) {
        const validKeys = Object.keys(parentValue).filter(
          (key) => validatePath(config, [...parentSegments, key]).isValid
        );
        const suggestion = (0, import_didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
        if (suggestion) {
          error += ` Did you mean '${pathToString2([...parentSegments, suggestion])}'?`;
        } else if (validKeys.length > 0) {
          error += ` '${pathToString2(parentSegments)}' has the following valid keys: ${list2(
            validKeys
          )}`;
        }
      } else {
        const closestPath = findClosestExistingPath(config.theme, pathString);
        if (closestPath) {
          const closestValue = (0, import_dlv13.default)(config.theme, closestPath);
          if (isObject22(closestValue)) {
            error += ` '${pathToString2(closestPath)}' has the following keys: ${listKeys(
              closestValue
            )}`;
          } else {
            error += ` '${pathToString2(closestPath)}' is not an object.`;
          }
        } else {
          error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;
        }
      }
      return {
        isValid: false,
        error
      };
    }
    if (!(typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "function" || value2 instanceof String || value2 instanceof Number || Array.isArray(value2))) {
      let error = `'${pathString}' was found but does not resolve to a string.`;
      if (isObject22(value2)) {
        let validKeys = Object.keys(value2).filter(
          (key) => validatePath(config, [...pathSegments, key]).isValid
        );
        if (validKeys.length) {
          error += ` Did you mean something like '${pathToString2([...pathSegments, validKeys[0]])}'?`;
        }
      }
      return {
        isValid: false,
        error
      };
    }
    const [themeSection] = pathSegments;
    return {
      isValid: true,
      value: transformThemeValue(themeSection)(value2, themeOpts)
    };
  }
  function extractArgs(node, vNodes, functions) {
    vNodes = vNodes.map((vNode) => resolveVNode(node, vNode, functions));
    let args = [""];
    for (let vNode of vNodes) {
      if (vNode.type === "div" && vNode.value === ",") {
        args.push("");
      } else {
        args[args.length - 1] += import_value_parser.default.stringify(vNode);
      }
    }
    return args;
  }
  function resolveVNode(node, vNode, functions) {
    if (vNode.type === "function" && functions[vNode.value] !== void 0) {
      let args = extractArgs(node, vNode.nodes, functions);
      vNode.type = "word";
      vNode.value = functions[vNode.value](node, ...args);
    }
    return vNode;
  }
  function resolveFunctions(node, input, functions) {
    let hasAnyFn = Object.keys(functions).some((fn5) => input.includes(`${fn5}(`));
    if (!hasAnyFn) return input;
    return (0, import_value_parser.default)(input).walk((vNode) => {
      resolveVNode(node, vNode, functions);
    }).toString();
  }
  var nodeTypePropertyMap = {
    atrule: "params",
    decl: "value"
  };
  function* toPaths(path) {
    path = path.replace(/^['"]+|['"]+$/g, "");
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
    let alpha = void 0;
    yield [path, void 0];
    if (matches) {
      path = matches[1];
      alpha = matches[2];
      yield [path, alpha];
    }
  }
  function resolvePath(config, path, defaultValue) {
    const results = Array.from(toPaths(path)).map(([path2, alpha]) => {
      return Object.assign(validatePath(config, path2, defaultValue, { opacityValue: alpha }), {
        resolvedPath: path2,
        alpha
      });
    });
    return results.find((result) => result.isValid) ?? results[0];
  }
  function evaluateTailwindFunctions_default(context) {
    let config = context.tailwindConfig;
    let functions = {
      theme: (node, path, ...defaultValue) => {
        let { isValid, value: value2, error, alpha } = resolvePath(
          config,
          path,
          defaultValue.length ? defaultValue : void 0
        );
        if (!isValid) {
          let parentNode = node.parent;
          let candidate = parentNode?.raws.tailwind?.candidate;
          if (parentNode && candidate !== void 0) {
            context.markInvalidUtilityNode(parentNode);
            parentNode.remove();
            log_default.warn("invalid-theme-key-in-class", [
              `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
            ]);
            return;
          }
          throw node.error(error);
        }
        let maybeColor = parseColorFormat(value2);
        let isColorFunction = maybeColor !== void 0 && typeof maybeColor === "function";
        if (alpha !== void 0 || isColorFunction) {
          if (alpha === void 0) {
            alpha = 1;
          }
          value2 = withAlphaValue(maybeColor, alpha, maybeColor);
        }
        return value2;
      },
      screen: (node, screen) => {
        screen = screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
        let screens = normalizeScreens(config.theme.screens);
        let screenDefinition = screens.find(({ name }) => name === screen);
        if (!screenDefinition) {
          throw node.error(`The '${screen}' screen does not exist in your theme.`);
        }
        return buildMediaQuery(screenDefinition);
      }
    };
    return (root2) => {
      root2.walk((node) => {
        let property = nodeTypePropertyMap[node.type];
        if (property === void 0) {
          return;
        }
        node[property] = resolveFunctions(node, node[property], functions);
      });
    };
  }
  function substituteScreenAtRules_default({ tailwindConfig: { theme } }) {
    return function(css) {
      css.walkAtRules("screen", (atRule22) => {
        let screen = atRule22.params;
        let screens = normalizeScreens(theme.screens);
        let screenDefinition = screens.find(({ name }) => name === screen);
        if (!screenDefinition) {
          throw atRule22.error(`No \`${screen}\` screen found.`);
        }
        atRule22.name = "media";
        atRule22.params = buildMediaQuery(screenDefinition);
      });
    };
  }
  var getNode = {
    id(node) {
      return import_postcss_selector_parser10.default.attribute({
        attribute: "id",
        operator: "=",
        value: node.value,
        quoteMark: '"'
      });
    }
  };
  function minimumImpactSelector(nodes) {
    let rest = nodes.filter((node2) => {
      if (node2.type !== "pseudo") return true;
      if (node2.nodes.length > 0) return true;
      return node2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(node2.value);
    }).reverse();
    let searchFor = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]);
    let splitPointIdx = rest.findIndex((n2) => searchFor.has(n2.type));
    if (splitPointIdx === -1) return rest.reverse().join("").trim();
    let node = rest[splitPointIdx];
    let bestNode = getNode[node.type] ? getNode[node.type](node) : node;
    rest = rest.slice(0, splitPointIdx);
    let combinatorIdx = rest.findIndex((n2) => n2.type === "combinator" && n2.value === ">");
    if (combinatorIdx !== -1) {
      rest.splice(0, combinatorIdx);
      rest.unshift(import_postcss_selector_parser10.default.universal());
    }
    return [bestNode, ...rest.reverse()].join("").trim();
  }
  var elementSelectorParser = (0, import_postcss_selector_parser10.default)((selectors) => {
    return selectors.map((s2) => {
      let nodes = s2.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
      return minimumImpactSelector(nodes);
    });
  });
  var cache2 = /* @__PURE__ */ new Map();
  function extractElementSelector(selector) {
    if (!cache2.has(selector)) {
      cache2.set(selector, elementSelectorParser.transformSync(selector));
    }
    return cache2.get(selector);
  }
  function resolveDefaultsAtRules({ tailwindConfig }) {
    return (root2) => {
      let variableNodeMap = /* @__PURE__ */ new Map();
      let universals = /* @__PURE__ */ new Set();
      root2.walkAtRules("defaults", (rule2) => {
        if (rule2.nodes && rule2.nodes.length > 0) {
          universals.add(rule2);
          return;
        }
        let variable = rule2.params;
        if (!variableNodeMap.has(variable)) {
          variableNodeMap.set(variable, /* @__PURE__ */ new Set());
        }
        variableNodeMap.get(variable).add(rule2.parent);
        rule2.remove();
      });
      if (flagEnabled2(tailwindConfig, "optimizeUniversalDefaults")) {
        for (let universal of universals) {
          let selectorGroups = /* @__PURE__ */ new Map();
          let rules = variableNodeMap.get(universal.params) ?? [];
          for (let rule2 of rules) {
            for (let selector of extractElementSelector(rule2.selector)) {
              let selectorGroupName = selector.includes(":-") || selector.includes("::-") ? selector : "__DEFAULT__";
              let selectors = selectorGroups.get(selectorGroupName) ?? /* @__PURE__ */ new Set();
              selectorGroups.set(selectorGroupName, selectors);
              selectors.add(selector);
            }
          }
          if (flagEnabled2(tailwindConfig, "optimizeUniversalDefaults")) {
            if (selectorGroups.size === 0) {
              universal.remove();
              continue;
            }
            for (let [, selectors] of selectorGroups) {
              let universalRule = postcss_default.rule({
                source: universal.source
              });
              universalRule.selectors = [...selectors];
              universalRule.append(universal.nodes.map((node) => node.clone()));
              universal.before(universalRule);
            }
          }
          universal.remove();
        }
      } else if (universals.size) {
        let universalRule = postcss_default.rule({
          selectors: ["*", "::before", "::after"]
        });
        for (let universal of universals) {
          universalRule.append(universal.nodes);
          if (!universalRule.parent) {
            universal.before(universalRule);
          }
          if (!universalRule.source) {
            universalRule.source = universal.source;
          }
          universal.remove();
        }
        let backdropRule = universalRule.clone({
          selectors: ["::backdrop"]
        });
        universalRule.after(backdropRule);
      }
    };
  }
  var comparisonMap = {
    atrule: ["name", "params"],
    rule: ["selector"]
  };
  var types = new Set(Object.keys(comparisonMap));
  function collapseAdjacentRules() {
    function collapseRulesIn(root2) {
      let currentRule = null;
      root2.each((node) => {
        if (!types.has(node.type)) {
          currentRule = null;
          return;
        }
        if (currentRule === null) {
          currentRule = node;
          return;
        }
        let properties = comparisonMap[node.type];
        if (node.type === "atrule" && node.name === "font-face") {
          currentRule = node;
        } else if (properties.every(
          (property) => (node[property] ?? "").replace(/\s+/g, " ") === (currentRule[property] ?? "").replace(/\s+/g, " ")
        )) {
          if (node.nodes) {
            currentRule.append(node.nodes);
          }
          node.remove();
        } else {
          currentRule = node;
        }
      });
      root2.each((node) => {
        if (node.type === "atrule") {
          collapseRulesIn(node);
        }
      });
    }
    return (root2) => {
      collapseRulesIn(root2);
    };
  }
  function collapseDuplicateDeclarations() {
    return (root2) => {
      root2.walkRules((node) => {
        let seen = /* @__PURE__ */ new Map();
        let droppable = /* @__PURE__ */ new Set([]);
        let byProperty = /* @__PURE__ */ new Map();
        node.walkDecls((decl22) => {
          if (decl22.parent !== node) {
            return;
          }
          if (seen.has(decl22.prop)) {
            if (seen.get(decl22.prop).value === decl22.value) {
              droppable.add(seen.get(decl22.prop));
              seen.set(decl22.prop, decl22);
              return;
            }
            if (!byProperty.has(decl22.prop)) {
              byProperty.set(decl22.prop, /* @__PURE__ */ new Set());
            }
            byProperty.get(decl22.prop).add(seen.get(decl22.prop));
            byProperty.get(decl22.prop).add(decl22);
          }
          seen.set(decl22.prop, decl22);
        });
        for (let decl22 of droppable) {
          decl22.remove();
        }
        for (let declarations of byProperty.values()) {
          let byUnit = /* @__PURE__ */ new Map();
          for (let decl22 of declarations) {
            let unit = resolveUnit(decl22.value);
            if (unit === null) {
              continue;
            }
            if (!byUnit.has(unit)) {
              byUnit.set(unit, /* @__PURE__ */ new Set());
            }
            byUnit.get(unit).add(decl22);
          }
          for (let declarations2 of byUnit.values()) {
            let removableDeclarations = Array.from(declarations2).slice(0, -1);
            for (let decl22 of removableDeclarations) {
              decl22.remove();
            }
          }
        }
      });
    };
  }
  var UNITLESS_NUMBER = Symbol("unitless-number");
  function resolveUnit(input) {
    let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
    if (result) {
      return result[1] ?? UNITLESS_NUMBER;
    }
    return null;
  }
  function partitionRules(root2) {
    if (!root2.walkAtRules) return;
    let applyParents = /* @__PURE__ */ new Set();
    root2.walkAtRules("apply", (rule2) => {
      applyParents.add(rule2.parent);
    });
    if (applyParents.size === 0) {
      return;
    }
    for (let rule2 of applyParents) {
      let nodeGroups = [];
      let lastGroup = [];
      for (let node of rule2.nodes) {
        if (node.type === "atrule" && node.name === "apply") {
          if (lastGroup.length > 0) {
            nodeGroups.push(lastGroup);
            lastGroup = [];
          }
          nodeGroups.push([node]);
        } else {
          lastGroup.push(node);
        }
      }
      if (lastGroup.length > 0) {
        nodeGroups.push(lastGroup);
      }
      if (nodeGroups.length === 1) {
        continue;
      }
      for (let group of [...nodeGroups].reverse()) {
        let clone = rule2.clone({ nodes: [] });
        clone.append(group);
        rule2.after(clone);
      }
      rule2.remove();
    }
  }
  function expandApplyAtRules2() {
    return (root2) => {
      partitionRules(root2);
    };
  }
  function isRoot(node) {
    return node.type === "root";
  }
  function isAtLayer(node) {
    return node.type === "atrule" && node.name === "layer";
  }
  function detectNesting_default(_context) {
    return (root2, result) => {
      let found = false;
      root2.walkAtRules("tailwind", (node) => {
        if (found) return false;
        if (node.parent && !(isRoot(node.parent) || isAtLayer(node.parent))) {
          found = true;
          node.warn(
            result,
            [
              "Nested @tailwind rules were detected, but are not supported.",
              "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
              "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
            ].join("\n")
          );
          return false;
        }
      });
      root2.walkRules((rule2) => {
        if (found) return false;
        rule2.walkRules((nestedRule) => {
          found = true;
          nestedRule.warn(
            result,
            [
              "Nested CSS was detected, but CSS nesting has not been configured correctly.",
              "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
              "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
            ].join("\n")
          );
          return false;
        });
      });
    };
  }
  function processTailwindFeatures(setupContext) {
    return async function(root2, result) {
      let { tailwindDirectives, applyDirectives } = normalizeTailwindDirectives(root2);
      detectNesting_default()(root2, result);
      expandApplyAtRules2()(root2, result);
      let context = setupContext({
        tailwindDirectives,
        applyDirectives,
        registerDependency(dependency) {
          result.messages.push({
            plugin: "tailwindcss",
            parent: result.opts.from,
            ...dependency
          });
        },
        createContext(tailwindConfig, changedContent) {
          return createContext(tailwindConfig, changedContent, root2);
        }
      })(root2, result);
      if (context.tailwindConfig.separator === "-") {
        throw new Error(
          "The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead."
        );
      }
      issueFlagNotices(context.tailwindConfig);
      await expandTailwindAtRules(context)(root2, result);
      expandApplyAtRules2()(root2, result);
      expandApplyAtRules(context)(root2, result);
      evaluateTailwindFunctions_default(context)(root2, result);
      substituteScreenAtRules_default(context)(root2, result);
      resolveDefaultsAtRules(context)(root2, result);
      collapseAdjacentRules(context)(root2, result);
      collapseDuplicateDeclarations(context)(root2, result);
    };
  }
  var corePluginList_default = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
  function configurePlugins_default(pluginConfig, plugins) {
    if (pluginConfig === void 0) {
      return plugins;
    }
    const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
      ...new Set(
        plugins.filter((pluginName) => {
          return pluginConfig !== false && pluginConfig[pluginName] !== false;
        }).concat(
          Object.keys(pluginConfig).filter((pluginName) => {
            return pluginConfig[pluginName] !== false;
          })
        )
      )
    ];
    return pluginNames;
  }
  function warn({ version: version2, from, to }) {
    log_default.warn(`${from}-color-renamed`, [
      `As of Tailwind CSS ${version2}, \`${from}\` has been renamed to \`${to}\`.`,
      "Update your configuration file to silence this warning."
    ]);
  }
  var colors_default = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    get lightBlue() {
      warn({ version: "v2.2", from: "lightBlue", to: "sky" });
      return this.sky;
    },
    get warmGray() {
      warn({ version: "v3.0", from: "warmGray", to: "stone" });
      return this.stone;
    },
    get trueGray() {
      warn({ version: "v3.0", from: "trueGray", to: "neutral" });
      return this.neutral;
    },
    get coolGray() {
      warn({ version: "v3.0", from: "coolGray", to: "gray" });
      return this.gray;
    },
    get blueGray() {
      warn({ version: "v3.0", from: "blueGray", to: "slate" });
      return this.slate;
    }
  };
  function defaults2(target, ...sources) {
    for (let source of sources) {
      for (let k5 in source) {
        if (!target?.hasOwnProperty?.(k5)) {
          target[k5] = source[k5];
        }
      }
      for (let k5 of Object.getOwnPropertySymbols(source)) {
        if (!target?.hasOwnProperty?.(k5)) {
          target[k5] = source[k5];
        }
      }
    }
    return target;
  }
  function normalizeConfig(config) {
    let valid = (() => {
      if (config.purge) {
        return false;
      }
      if (!config.content) {
        return false;
      }
      if (!Array.isArray(config.content) && !(typeof config.content === "object" && config.content !== null)) {
        return false;
      }
      if (Array.isArray(config.content)) {
        return config.content.every((path) => {
          if (typeof path === "string") return true;
          if (typeof path?.raw !== "string") return false;
          if (path?.extension && typeof path?.extension !== "string") {
            return false;
          }
          return true;
        });
      }
      if (typeof config.content === "object" && config.content !== null) {
        if (Object.keys(config.content).some(
          (key) => !["files", "relative", "extract", "transform"].includes(key)
        )) {
          return false;
        }
        if (Array.isArray(config.content.files)) {
          if (!config.content.files.every((path) => {
            if (typeof path === "string") return true;
            if (typeof path?.raw !== "string") return false;
            if (path?.extension && typeof path?.extension !== "string") {
              return false;
            }
            return true;
          })) {
            return false;
          }
          if (typeof config.content.extract === "object") {
            for (let value2 of Object.values(config.content.extract)) {
              if (typeof value2 !== "function") {
                return false;
              }
            }
          } else if (!(config.content.extract === void 0 || typeof config.content.extract === "function")) {
            return false;
          }
          if (typeof config.content.transform === "object") {
            for (let value2 of Object.values(config.content.transform)) {
              if (typeof value2 !== "function") {
                return false;
              }
            }
          } else if (!(config.content.transform === void 0 || typeof config.content.transform === "function")) {
            return false;
          }
          if (typeof config.content.relative !== "boolean" && typeof config.content.relative !== "undefined") {
            return false;
          }
        }
        return true;
      }
      return false;
    })();
    if (!valid) {
      log_default.warn("purge-deprecation", [
        "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
        "Update your configuration file to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
      ]);
    }
    config.safelist = (() => {
      let { content, purge, safelist } = config;
      if (Array.isArray(safelist)) return safelist;
      if (Array.isArray(content?.safelist)) return content.safelist;
      if (Array.isArray(purge?.safelist)) return purge.safelist;
      if (Array.isArray(purge?.options?.safelist)) return purge.options.safelist;
      return [];
    })();
    config.blocklist = (() => {
      let { blocklist } = config;
      if (Array.isArray(blocklist)) {
        if (blocklist.every((item) => typeof item === "string")) {
          return blocklist;
        }
        log_default.warn("blocklist-invalid", [
          "The `blocklist` option must be an array of strings.",
          "https://tailwindcss.com/docs/content-configuration#discarding-classes"
        ]);
      }
      return [];
    })();
    if (typeof config.prefix === "function") {
      log_default.warn("prefix-function", [
        "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
        "Update `prefix` in your configuration to be a string to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
      ]);
      config.prefix = "";
    } else {
      config.prefix = config.prefix ?? "";
    }
    config.content = {
      relative: (() => {
        let { content } = config;
        if (content?.relative) {
          return content.relative;
        }
        return flagEnabled2(config, "relativeContentPathsByDefault");
      })(),
      files: (() => {
        let { content, purge } = config;
        if (Array.isArray(purge)) return purge;
        if (Array.isArray(purge?.content)) return purge.content;
        if (Array.isArray(content)) return content;
        if (Array.isArray(content?.content)) return content.content;
        if (Array.isArray(content?.files)) return content.files;
        return [];
      })(),
      extract: (() => {
        let extract = (() => {
          if (config.purge?.extract) return config.purge.extract;
          if (config.content?.extract) return config.content.extract;
          if (config.purge?.extract?.DEFAULT) return config.purge.extract.DEFAULT;
          if (config.content?.extract?.DEFAULT) return config.content.extract.DEFAULT;
          if (config.purge?.options?.extractors) return config.purge.options.extractors;
          if (config.content?.options?.extractors) return config.content.options.extractors;
          return {};
        })();
        let extractors = {};
        let defaultExtractor2 = (() => {
          if (config.purge?.options?.defaultExtractor) {
            return config.purge.options.defaultExtractor;
          }
          if (config.content?.options?.defaultExtractor) {
            return config.content.options.defaultExtractor;
          }
          return void 0;
        })();
        if (defaultExtractor2 !== void 0) {
          extractors.DEFAULT = defaultExtractor2;
        }
        if (typeof extract === "function") {
          extractors.DEFAULT = extract;
        } else if (Array.isArray(extract)) {
          for (let { extensions, extractor } of extract ?? []) {
            for (let extension of extensions) {
              extractors[extension] = extractor;
            }
          }
        } else if (typeof extract === "object" && extract !== null) {
          Object.assign(extractors, extract);
        }
        return extractors;
      })(),
      transform: (() => {
        let transform = (() => {
          if (config.purge?.transform) return config.purge.transform;
          if (config.content?.transform) return config.content.transform;
          if (config.purge?.transform?.DEFAULT) return config.purge.transform.DEFAULT;
          if (config.content?.transform?.DEFAULT) return config.content.transform.DEFAULT;
          return {};
        })();
        let transformers = {};
        if (typeof transform === "function") {
          transformers.DEFAULT = transform;
        }
        if (typeof transform === "object" && transform !== null) {
          Object.assign(transformers, transform);
        }
        return transformers;
      })()
    };
    for (let file of config.content.files) {
      if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
        log_default.warn("invalid-glob-braces", [
          `The glob pattern ${dim(file)} in your Tailwind CSS configuration is invalid.`,
          `Update it to ${dim(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
          // TODO: Add https://tw.wtf/invalid-glob-braces
        ]);
        break;
      }
    }
    return config;
  }
  function cloneDeep(value2) {
    if (Array.isArray(value2)) {
      return value2.map((child) => cloneDeep(child));
    }
    if (typeof value2 === "object" && value2 !== null) {
      return Object.fromEntries(Object.entries(value2).map(([k5, v2]) => [k5, cloneDeep(v2)]));
    }
    return value2;
  }
  function isFunction(input) {
    return typeof input === "function";
  }
  function mergeWith(target, ...sources) {
    let customizer = sources.pop();
    for (let source of sources) {
      for (let k5 in source) {
        let merged = customizer(target[k5], source[k5]);
        if (merged === void 0) {
          if (isPlainObject(target[k5]) && isPlainObject(source[k5])) {
            target[k5] = mergeWith({}, target[k5], source[k5], customizer);
          } else {
            target[k5] = source[k5];
          }
        } else {
          target[k5] = merged;
        }
      }
    }
    return target;
  }
  var configUtils = {
    colors: colors_default,
    negative(scale) {
      return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
        let negativeValue = negateValue(scale[key]);
        if (negativeValue !== void 0) {
          negativeScale[`-${key}`] = negativeValue;
        }
        return negativeScale;
      }, {});
    },
    breakpoints(screens) {
      return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce(
        (breakpoints, key) => ({
          ...breakpoints,
          [`screen-${key}`]: screens[key]
        }),
        {}
      );
    }
  };
  function value(valueToResolve, ...args) {
    return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;
  }
  function collectExtends(items) {
    return items.reduce((merged, { extend }) => {
      return mergeWith(merged, extend, (mergedValue, extendValue) => {
        if (mergedValue === void 0) {
          return [extendValue];
        }
        if (Array.isArray(mergedValue)) {
          return [extendValue, ...mergedValue];
        }
        return [extendValue, mergedValue];
      });
    }, {});
  }
  function mergeThemes(themes) {
    return {
      ...themes.reduce((merged, theme) => defaults2(merged, theme), {}),
      // In order to resolve n config objects, we combine all of their `extend` properties
      // into arrays instead of objects so they aren't overridden.
      extend: collectExtends(themes)
    };
  }
  function mergeExtensionCustomizer(merged, value2) {
    if (Array.isArray(merged) && isPlainObject(merged[0])) {
      return merged.concat(value2);
    }
    if (Array.isArray(value2) && isPlainObject(value2[0]) && isPlainObject(merged)) {
      return [merged, ...value2];
    }
    if (Array.isArray(value2)) {
      return value2;
    }
    return void 0;
  }
  function mergeExtensions({ extend, ...theme }) {
    return mergeWith(theme, extend, (themeValue, extensions) => {
      if (!isFunction(themeValue) && !extensions.some(isFunction)) {
        return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
      }
      return (resolveThemePath, utils) => mergeWith(
        {},
        ...[themeValue, ...extensions].map((e5) => value(e5, resolveThemePath, utils)),
        mergeExtensionCustomizer
      );
    });
  }
  function* toPaths2(key) {
    let path = toPath(key);
    if (path.length === 0) {
      return;
    }
    yield path;
    if (Array.isArray(key)) {
      return;
    }
    let pattern2 = /^(.*?)\s*\/\s*([^/]+)$/;
    let matches = key.match(pattern2);
    if (matches !== null) {
      let [, prefix3, alpha] = matches;
      let newPath = toPath(prefix3);
      newPath.alpha = alpha;
      yield newPath;
    }
  }
  function resolveFunctionKeys(object) {
    const resolvePath2 = (key, defaultValue) => {
      for (const path of toPaths2(key)) {
        let index2 = 0;
        let val = object;
        while (val !== void 0 && val !== null && index2 < path.length) {
          val = val[path[index2++]];
          let shouldResolveAsFn = isFunction(val) && (path.alpha === void 0 || index2 <= path.length - 1);
          val = shouldResolveAsFn ? val(resolvePath2, configUtils) : val;
        }
        if (val !== void 0) {
          if (path.alpha !== void 0) {
            let normalized = parseColorFormat(val);
            return withAlphaValue(normalized, path.alpha, toColorValue(normalized));
          }
          if (isPlainObject(val)) {
            return cloneDeep(val);
          }
          return val;
        }
      }
      return defaultValue;
    };
    Object.assign(resolvePath2, {
      theme: resolvePath2,
      ...configUtils
    });
    return Object.keys(object).reduce((resolved, key) => {
      resolved[key] = isFunction(object[key]) ? object[key](resolvePath2, configUtils) : object[key];
      return resolved;
    }, {});
  }
  function extractPluginConfigs(configs) {
    let allConfigs = [];
    configs.forEach((config) => {
      allConfigs = [...allConfigs, config];
      const plugins = config?.plugins ?? [];
      if (plugins.length === 0) {
        return;
      }
      plugins.forEach((plugin2) => {
        if (plugin2.__isOptionsFunction) {
          plugin2 = plugin2();
        }
        allConfigs = [...allConfigs, ...extractPluginConfigs([plugin2?.config ?? {}])];
      });
    });
    return allConfigs;
  }
  function resolveCorePlugins(corePluginConfigs) {
    const result = [...corePluginConfigs].reduceRight((resolved, corePluginConfig) => {
      if (isFunction(corePluginConfig)) {
        return corePluginConfig({ corePlugins: resolved });
      }
      return configurePlugins_default(corePluginConfig, resolved);
    }, corePluginList_default);
    return result;
  }
  function resolvePluginLists(pluginLists) {
    const result = [...pluginLists].reduceRight((resolved, pluginList) => {
      return [...resolved, ...pluginList];
    }, []);
    return result;
  }
  function resolveConfig(configs) {
    let allConfigs = [
      ...extractPluginConfigs(configs),
      {
        prefix: "",
        important: false,
        separator: ":"
      }
    ];
    return normalizeConfig(
      defaults2(
        {
          theme: resolveFunctionKeys(
            mergeExtensions(mergeThemes(allConfigs.map((t2) => t2?.theme ?? {})))
          ),
          corePlugins: resolveCorePlugins(allConfigs.map((c3) => c3.corePlugins)),
          plugins: resolvePluginLists(configs.map((c3) => c3?.plugins ?? []))
        },
        ...allConfigs
      )
    );
  }
  var import_config_full = __toESM2(require_config_full());
  function getAllConfigs(config) {
    const configs = (config?.presets ?? [import_config_full.default]).slice().reverse().flatMap((preset) => getAllConfigs(preset instanceof Function ? preset() : preset));
    const features = {
      // Add experimental configs here...
      respectDefaultRingColorOpacity: {
        theme: {
          ringColor: ({ theme }) => ({
            DEFAULT: "#3b82f67f",
            ...theme("colors")
          })
        }
      },
      disableColorOpacityUtilitiesByDefault: {
        corePlugins: {
          backgroundOpacity: false,
          borderOpacity: false,
          divideOpacity: false,
          placeholderOpacity: false,
          ringOpacity: false,
          textOpacity: false
        }
      }
    };
    const experimentals = Object.keys(features).filter((feature) => flagEnabled2(config, feature)).map((feature) => features[feature]);
    return [config, ...experimentals, ...configs];
  }
  function resolveConfig2(...configs) {
    let [, ...defaultConfigs] = getAllConfigs(configs[0]);
    return resolveConfig([...configs, ...defaultConfigs]);
  }
  async function stateFromConfig(configPromise) {
    const preparedTailwindConfig = await configPromise;
    const config = resolveConfig2(preparedTailwindConfig);
    const jitContext = createContext(config);
    const state = {
      version: "3.0.0",
      blocklist: [],
      config,
      enabled: true,
      modules: {
        postcss: {
          module: postcss_default,
          version: ""
        },
        postcssSelectorParser: { module: import_postcss_selector_parser2.default },
        jit: {
          createContext: { module: createContext },
          expandApplyAtRules: { module: expandApplyAtRules },
          generateRules: { module: generateRules2 }
        }
      },
      classNames: {
        classNames: {},
        context: {}
      },
      jit: true,
      jitContext,
      separator: config.separator,
      screens: config.theme?.screens ? Object.keys(config.theme.screens) : [],
      variants: jitContext.getVariants(),
      editor: {
        userLanguages: {},
        capabilities: {
          configuration: true,
          diagnosticRelatedInformation: true,
          itemDefaults: []
        },
        // eslint-disable-next-line require-await
        async getConfiguration() {
          return {
            editor: { tabSize: 2 },
            // Default values are based on
            // https://github.com/tailwindlabs/tailwindcss-intellisense/blob/v0.9.1/packages/tailwindcss-language-server/src/server.ts#L259-L287
            tailwindCSS: {
              emmetCompletions: false,
              classAttributes: ["class", "className", "ngClass"],
              codeActions: true,
              hovers: true,
              suggestions: true,
              validate: true,
              colorDecorators: true,
              rootFontSize: 16,
              lint: {
                cssConflict: "warning",
                invalidApply: "error",
                invalidScreen: "error",
                invalidVariant: "error",
                invalidConfigPath: "error",
                invalidTailwindDirective: "error",
                recommendedVariantOrder: "warning"
              },
              showPixelEquivalents: true,
              includeLanguages: {},
              files: {
                // Upstream defines these values, but we don’t need them.
                exclude: []
              },
              experimental: {
                classRegex: [],
                // Upstream types are wrong
                configFile: {}
              }
            }
          };
        }
        // This option takes some properties that we don’t have nor need.
      }
    };
    state.classList = jitContext.getClassList().filter((className) => className !== "*").map((className) => [className, { color: getColor(state, className) }]);
    return state;
  }
  function initialize3(tailwindWorkerOptions) {
    initialize2((ctx, options) => {
      const preparedTailwindConfig = tailwindWorkerOptions?.prepareTailwindConfig?.(options.tailwindConfig) ?? options.tailwindConfig ?? {};
      if (typeof preparedTailwindConfig !== "object") {
        throw new TypeError(
          `Expected tailwindConfig to resolve to an object, but got: ${JSON.stringify(
            preparedTailwindConfig
          )}`
        );
      }
      const statePromise = stateFromConfig(preparedTailwindConfig);
      const withDocument = (fn5) => (uri, languageId, ...args) => {
        const models = ctx.getMirrorModels();
        for (const model of models) {
          if (String(model.uri) === uri) {
            return statePromise.then(
              (state) => fn5(
                state,
                TextDocument2.create(uri, languageId, model.version, model.getValue()),
                ...args
              )
            );
          }
        }
      };
      return {
        doCodeActions: withDocument(
          (state, textDocument, range, context) => doCodeActions(state, { range, context, textDocument }, textDocument)
        ),
        doComplete: withDocument(doComplete2),
        doHover: withDocument(doHover),
        doValidate: withDocument(doValidate),
        async generateStylesFromContent(css, content) {
          const { config } = await statePromise;
          const tailwind = processTailwindFeatures(
            (processOptions) => () => processOptions.createContext(config, content)
          );
          const processor = postcss_default([tailwind]);
          const result = await processor.process(css);
          return result.css;
        },
        getDocumentColors: withDocument(getDocumentColors),
        async resolveCompletionItem(item) {
          return resolveCompletionItem(await statePromise, item);
        }
      };
    });
  }
  initialize3();
})();
/*! Bundled license information:

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

line-column/lib/line-column.js:
  (**
   * line-column - Convert efficiently index to/from line-column in a string
   * @module  lineColumn
   * @license MIT
   *)

css.escape/css.escape.js:
  (*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license *)

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
